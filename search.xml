<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++多态、虚函数笔记</title>
    <url>/2019/03/17/C++%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>
<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>

<p>C++ 多态意味着调用成员函数时，据调用函数的对象的类型来执行不同的函数。</p>

<h1>例如：</h1>

<pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Shape &#123;
protected:
    int width, height;
public:
    Shape(int a = 0, int b = 0): width(a), height(b) &#123; &#125;//初始化width, height
    int area()
    &#123;
        cout &lt;&lt; "Parent class area :" &lt;&lt; endl;
        return 0;
    &#125;
&#125;;
class Rectangle : public Shape &#123;
public:
    //Rectangle(int a = 0, int b = 0) :Shape(a, b) &#123; &#125;
    Rectangle(int a = 0, int b = 0)
    &#123;
        width = a;
        height = b;
    &#125;
    int area()
    &#123;
        cout &lt;&lt; "Rectangle class area :" &lt;&lt; width * height &lt;&lt; endl;
        return (width * height);
    &#125;
&#125;;
class Triangle : public Shape &#123;
public:
    Triangle(int a = 0, int b = 0) :Shape(a, b) &#123; &#125;//派生类先调用基类构造函数初始化width， height。然后派生类继承变量
    int area()
    &#123;
        cout &lt;&lt; "Triangle class area :" &lt;&lt; width * height &lt;&lt; endl;
        return (width * height / 2);
    &#125;
&#125;;
// 程序的主函数
int main()
&#123;
    Shape *shape;
    Rectangle rec(10, 7);
    Triangle  tri(10, 5);

    // 存储矩形的地址
    shape = &amp;rec;
    // 调用矩形的求面积函数 area
    shape-&gt;area();

    // 存储三角形的地址
    shape = &amp;tri;
    // 调用三角形的求面积函数 area
    shape-&gt;area();

    system("Pause");

    return 0;
&#125;</code></pre>

<p>运行结果为</p>

<p><img alt class="has" height="112" src="https://img-blog.csdnimg.cn/20190317230333452.png" width="255"></p>

<p>基类的指针可以指向派生类的对象，我们想达到的结果是，分别调用rec对象的area()方法，tri对象的area()方法计算面积。</p>

<p>但调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>

<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p>

<pre class="has">
<code class="language-cpp">class Shape &#123;
protected:
    int width, height;
public:
    Shape(int a = 0, int b = 0): width(a), height(b) &#123; &#125;
    virtual int area()
    &#123;
        cout &lt;&lt; "Parent class area :" &lt;&lt; endl;
        return 0;
    &#125;
&#125;;</code></pre>

<p>运行结果如下：</p>

<p><img alt class="has" height="128" src="https://img-blog.csdnimg.cn/20190317231409414.png" width="252"></p>

<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>

<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>

<h2>虚函数</h2>

<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>

<p>想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>

<h2>纯虚函数</h2>

<p>如果想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>

<p>我们可以把基类中的虚函数 area() 改写如下：</p>

<pre class="has">
<code class="language-cpp">class Shape &#123;
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      &#123;
         width = a;
         height = b;
      &#125;
      // pure virtual function
      virtual int area() = 0;
&#125;;
</code></pre>

<p>1. = 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p>

<p>2. 虚函数声明如下：</p>

<pre class="has">
<code class="language-cpp">class Shape &#123;
protected:
    int width, height;
public:
    Shape(int a = 0, int b = 0): width(a), height(b) &#123; &#125;
    virtual int area();
    //&#123;
    //    cout &lt;&lt; "Parent class area :" &lt;&lt; endl;
    //    return 0;
    //&#125;
&#125;;</code></pre>

<p>虚函数必须实现，如果不实现，编译器将报错，错误提示为</p>

<p><img alt class="has" height="104" src="https://img-blog.csdnimg.cn/20190317232503174.png" width="1055"></p>

<p>编译器对每个包含虚函数的类创建一个虚函数表VTABLE，表中每一项指向一个虚函数的地址，即VTABLE表可以看成一个函数指针的数组，每个虚函数的入口地址就是这个数组的一个元素。</p>

<p>每个含有虚函数的类都有各自的一张虚函数表VTABLE。每个派生类的VTABLE继承了它各个基类的VTABLE，如果基类VTABLE中包含某一项（虚函数的入口地址），则其派生类的VTABLE中也将包含同样的一项，但是两项的值可能不同。如果派生类中重载了该项对应的虚函数，则派生类VTABLE的该项指向重载后的虚函数，如果派生类中没有对该项对应的虚函数进行重新定义，则使用基类的这个虚函数地址。</p>

<p>在创建含有虚函数的类的对象的时候，编译器会在每个对象的内存布局中增加一个vptr指针项，该指针指向本类的VTABLE。在通过指向基类对象的指针（设为bp）调用一个虚函数时，编译器生成的代码是先获取所指对象的vptr指针，然后调用vptr所指向类的VTABLE中的对应项（具体虚函数的入口地址）。</p>

<p>当基类中<strong>没有定义虚函数</strong>时，其长度=数据成员长度；派生类长度=自身数据成员长度+基类继承的数据成员长度；</p>

<p>当基类中<strong>定义虚函数后</strong>，其长度=数据成员长度+虚函数表的地址长度；派生类长度=自身数据成员长度+基类继承的数据成员长度+虚函数表的地址长度。</p>

<p>包含一个虚函数和几个虚函数的类的长度增量为0。含有虚函数的类只是增加了一个指针用于存储虚函数表的首地址。</p>

<p>派生类与基类同名的虚函数在VTABLE中有相同的索引号（或序号）。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++ 多态 虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串分割</title>
    <url>/2019/01/29/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<span id="more"></span>
<p>函数设计时，可将多个参数通过分隔符连接成为一个参数传入，这样可减少函数的入参数字。函数内部需要对传入的合并参数进行分割，获取需要的参数即可。</p>

<p>/****************************************************************************<br>
函数名称: iMystrtok<br>
函数功能: 根据sFlg分割sData<br>
*****************************************************************************/<br>
long iMystrtok(string sData, string sFlg, vector&lt;string&gt; &amp;vStr)<br>
{<br>
    if (sData.empty())<br>
    {<br>
        return 0;<br>
    }<br>
    vStr.clear();<br>
    size_t uiOffset = 0, uiPos = 0;<br>
    uiPos = sData.find(sFlg, uiOffset);<br>
    while (uiPos != string::npos)<br>
    {<br>
        vStr.push_back(sData.substr(uiOffset, uiPos-uiOffset));<br>
        uiOffset = uiPos + sFlg.size();<br>
        uiPos = sData.find(sFlg, uiOffset);<br>
    }<br>
    vStr.push_back(sData.substr(uiOffset, sData.length() - uiOffset));    <br>
    return 0;<br>
}</p>

<p>例如：</p>

<p>string TestString = string("2019|hello|world");</p>

<p>vector&lt;string&gt; sTmp;</p>

<p>iMystrtok(TestString, "|", sTmp);</p>

<p>cout&lt;&lt;sTmp[0]&lt;&lt;endl;</p>

<p>cout&lt;&lt;sTmp[1]&lt;&lt;endl;</p>

<p>cout&lt;&lt;sTmp[2]&lt;&lt;endl;</p>

<p>输出为：</p>

<p>2019</p>

<p>hello</p>

<p>world</p>

<p> </p>]]></content>
      <tags>
        <tag>C++ 字符串分割</tag>
      </tags>
  </entry>
  <entry>
    <title>C调用Lua与解决Lua环境问题</title>
    <url>/2020/08/12/C%E8%B0%83%E7%94%A8Lua%E4%B8%8E%E8%A7%A3%E5%86%B3Lua%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>       一直是在框架上进行开发，而skynet的优点之一也是可以用lua来写逻辑，所以C调用lua这一块一直没有自己实际尝试，现在正在训练ai，刚好有时间搞搞这个。</p>

<p>       先补充概念：</p>

<p>    <strong>   1.C是需要自己管理内存的，申请、释放</strong></p>

<p><strong>       2.lua是自动管理内存的，没有引用的变量会定时被gc</strong></p>

<p><strong>       </strong>那如果，c在调用lua时，如果lua变量被释放了，就悲剧了。所以需要用一个东西一直来引用lua的变量。C与lua交互就是使用虚拟栈来交互（个人理解）。</p>

<p>       下面上代码，这些C使用lua的api可以自己去查具体的用处。</p>

<p>        附上lua 5.3中文参考手册地址：<a href="https://www.runoob.com/manual/lua53doc/contents.html#contents">https://www.runoob.com/manual/lua53doc/contents.html#contents</a></p>

<p> <strong> 1.以下为C代码</strong></p>

<pre>
<code class="language-cpp">#include &lt;stdio.h&gt;

extern "C" 
&#123;
    #include "lua.h"
    #include "lauxlib.h"    //这里需要真tm的注意，不是luaxlib
    #include "lualib.h"
&#125;

//调用lua中的add函数
int call_lua_add(lua_State *L)
&#123;
    lua_getglobal(L, "add");         //把虚拟机中全局变量 add 压入虚拟机L的栈，这里注意，一定要是全局变量
    lua_pushnumber(L, 123);            //第一个参数入栈
    lua_pushnumber(L, 456);         //第二个参数入栈
    lua_call(L, 2, 1);                //调用栈中的add函数，2个参数，1个返回值
    int sum = (int)lua_tonumber(L, -1);        //获取栈顶元素(上一步的返回值)
    lua_pop(L, 1);        //栈顶元素出战
    return sum;
&#125;

int main()
&#123;
    lua_State *L = luaL_newstate();        //新建lua虚拟机
    luaL_openlibs(L);                    //在虚拟机中载入lua所有函数库
    luaL_dofile(L, "Test.lua");            //加载 并 运行指定的文件
    lua_settop(L, 0);                    //重新设置栈底，这个过程，是为了确认栈底是空的，以便后面的操作是按照顺序入栈的且从1号栈位开始
    int ret = call_lua_add(L);
    printf("调用lua文件结果为 %d\n", ret);
    lua_close(L);                        //一定记得关闭虚拟机  

    return 0;
&#125;</code></pre>

<p><strong>2.以下为lua代码</strong></p>

<pre>
<code class="language-Delphi">function add( x, y )
    return x+y
end

print("你终于动手了")</code></pre>

<p><strong>3.编译c文件，然后发现报错了，原因时找不到头文件的，也就是环境没指定好</strong></p>

<p><img alt height="117" src="https://img-blog.csdnimg.cn/20200812142708412.png" width="792"></p>

<p><strong>4.简单查找一下</strong></p>

<p><img alt height="400" src="https://img-blog.csdnimg.cn/20200812142804341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="878"></p>

<p><strong>4.然后编译，-I参数是用来指定头文件目录 （是i），然后发现报错了</strong></p>

<p><img alt height="272" src="https://img-blog.csdnimg.cn/20200812142853903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>这个报错是说没找到这些东西，因为这些都在lualib库里，查找一下，指定一下即可。</p>

<p><img alt height="444" src="https://img-blog.csdnimg.cn/20200812143354735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="989"></p>

<p><strong>5.我是直接sudo cp /usr/lib/x86_64-linux-gnu/liblua5.3.so.0 . 将库拷贝到本目录，然后改名为liblua5.3.so。然后编译，-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名 （l），没报错。运行。结果如下</strong></p>

<p><img alt height="114" src="https://img-blog.csdnimg.cn/20200812152425666.png" width="1200"></p>

<p>       因为使用lua也有一段时间了，以前一直感觉C与lua交互是不难的，但是感觉是感觉，只有自己实际操作了，才有权力去说难不难。今天尝试了，的确不难。还是需要尽量都是自己去尝试了，才下结论。<strong>“有剑不用，和没有剑，不是用一个概念”</strong></p>

<p> </p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>c++ lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes nodes are not ready原因查看</title>
    <url>/2021/07/24/Kubernetes%20nodes%20are%20not%20ready%E5%8E%9F%E5%9B%A0%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<span id="more"></span>
<p>今早收到了Prometheus的报警，4% of Kubernetes nodes are not ready。</p>
<p>直接查看node情况即可知道原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@pro:~/helm-chart/prometheus-netease/templates$ kubectl describe nodes ip-xx-x-xxx-xxx.ap-northeast-1.compute.internal</span><br><span class="line">Name:               ip-xx-x-xxx-xxx.ap-northeast-1.compute.internal</span><br><span class="line">Roles:              node</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/instance-type=c5.xlarge</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    failure-domain.beta.kubernetes.io/region=ap-northeast-1</span><br><span class="line">                    failure-domain.beta.kubernetes.io/zone=ap-northeast-1c</span><br><span class="line">                    kubernetes.io/hostname=ip-xx-x-xxx-xxx.ap-northeast-1.compute.internal</span><br><span class="line">                    kubernetes.io/role=node</span><br><span class="line">                    node-role.kubernetes.io/node=</span><br><span class="line">Annotations:        node.alpha.kubernetes.io/ttl: 0</span><br><span class="line">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class="literal">true</span></span><br><span class="line">CreationTimestamp:  Sat, 24 Jul 2021 03:05:08 +0800</span><br><span class="line">Taints:             &lt;none&gt;</span><br><span class="line">Unschedulable:      <span class="literal">false</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----             ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  OutOfDisk        False   Sat, 24 Jul 2021 18:00:31 +0800   Sat, 24 Jul 2021 03:05:08 +0800   KubeletHasSufficientDisk     kubelet has sufficient disk space available</span><br><span class="line">  MemoryPressure   False   Sat, 24 Jul 2021 18:00:31 +0800   Sat, 24 Jul 2021 03:05:08 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure     False   Sat, 24 Jul 2021 18:00:31 +0800   Sat, 24 Jul 2021 03:05:08 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure      False   Sat, 24 Jul 2021 18:00:31 +0800   Sat, 24 Jul 2021 03:05:08 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready            True    Sat, 24 Jul 2021 18:00:31 +0800   Sat, 24 Jul 2021 03:05:28 +0800   KubeletReady                 kubelet is posting ready status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 创建属于自定义命令</title>
    <url>/2020/02/11/Linux%20%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<span id="more"></span>
<p>在家办公，再次搭建开发环境，加上这次多次碰到，做此记录</p>

<p>subl 是我安装的编辑器，如果你看到这这篇博客，把subl换成自己的编辑器(vi、vim)即可。</p>

<p><strong>1.在terminal 输入：subl ~/.bashrc</strong></p>

<p><img alt class="has" height="516" src="https://img-blog.csdnimg.cn/20200211171732628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="760"></p>

<p><strong>2.找到这个地方并添加自己的命令，可添加多个指令，用"；"隔开</strong></p>

<p><img alt class="has" height="345" src="https://img-blog.csdnimg.cn/20200211171840145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="905"></p>

<p><strong>3.在terminal 输入：source ~/.bashrc (立即生效)</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 无root权限安装tmux</title>
    <url>/2020/11/23/Linux%20%E6%97%A0root%E6%9D%83%E9%99%90%E5%AE%89%E8%A3%85tmux/</url>
    <content><![CDATA[<span id="more"></span>
<p>       在新公司中，开发是需要连接到开发机上的，而且员工作为普通用户，无法安装软件到除用户目录以外的目录(也就是没有root权限)。当我们需要下载安装一些常用工具时，因为没网，所以无法使用<code>apt-get</code>等下载指令。</p>

<p>       <strong>ps：为什么没有root，就无法使用apt-get，因为apt-get是会去写一些文件到root用户才有权限的文件夹(例如/user....)或者修改系统环境变量的。而普通用户是没有权限，所以没法使用。</strong></p>

<p><strong>       要解决这个问题，最主要的方法就是，修改安装的目录，添加自己用户下指定目录为环境变量。</strong></p>

<p>       最后使用以下方法安装tmux，亲测可行。</p>

<h1>    <strong>1.下载及其依赖软件</strong></h1>

<p>        这里有一个坑，待会儿说。       </p>

<pre>
<code>wget -c https://github.com/tmux/tmux/releases/download/3.0a/tmux-3.0a.tar.gz 

wget -c https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz 

wget -c https://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz</code></pre>

<h1>    2.解压</h1>

<p>       tar -zxvf xxxxxx</p>

<h1>    3.先安装依赖，在安装tmux</h1>

<pre>
<code># libevent
./configure --prefix=$HOME/.local --disable-shared
make &amp;&amp; make install

# ncurses
./configure --prefix=$HOME/.local
make &amp;&amp; make install

# tmux
./configure CFLAGS="-I$HOME/.local/include -I$HOME/.local/include/ncurses" LDFLAGS="-L$HOME/.local/lib -L$HOME/.local/include/ncurses -L$HOME/.local/include" --prefix=$HOME/.local/bin
make &amp;&amp; make install

cp tmux $HOME/.local/bin</code></pre>

<p>这里，如果出现类似这种错误，就是我上面说的坑。我自己也碰到了，最后改了过来，这个图是引用网上的，我的情况忘记截图了。</p>

<p><img alt height="393" src="https://img-blog.csdnimg.cn/20201123095157736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="724"></p>

<p>看这位的回答就知道原因了，原地址在<a href="https://segmentfault.com/q/1010000015949611">https://segmentfault.com/q/1010000015949611</a></p>

<p><img alt height="456" src="https://img-blog.csdnimg.cn/20201123095348446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="796"></p>

<p>我选了相应版本后，解决了以上问题。最后安装成功。</p>

<p>最后设置环境变量</p>

<pre>
<code>#环境变量设置
#将下面的语句添加到.bashrc中
export $PATH="$HOME/.local/bin:$PATH"
#重载环境
source .bashrc</code></pre>

<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 运行程序时如何保存堆栈（Linux如何把标准输出和错误输出 输出到一个文件里）</title>
    <url>/2021/04/09/Linux%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%A0%86%E6%A0%88%EF%BC%88Linux%E5%A6%82%E4%BD%95%E6%8A%8A%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA%20%E8%BE%93%E5%87%BA%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<p>最近在使用golang开发中，并发量达到一定程度时就会发生panic，想看堆栈，但是因为是跑在k8中的程序，输出都是直接输出到标准输出的。也没有日志。</p>
<p>在本地调试的时候直接运行了go程序，输出也是一大堆，一下子就被刷掉了，所以要把输出输入到一个文件里。</p>
<p>一般这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename // 把标准输出重定向到一个新文件中</span><br><span class="line">// 例如</span><br><span class="line">./programmer &gt; log.txt</span><br></pre></td></tr></table></figure>
<p>但是这样，如果发生堆栈错误还是会直接输出到屏幕。无法保存。</p>
<p>使用以下方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename 2&gt;&amp;1 // 把标准输出和标准错误一起重定向到一个文件中</span><br><span class="line">// 例如</span><br><span class="line">./programmer &gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>这样即可保存标准输出和错误输出。如果把“&gt;”换成”&gt;&gt;”就是追加输出到文件</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua for 循环</title>
    <url>/2019/04/02/Lua%20for%20%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<span id="more"></span>
<p>真的是无语，我手一个字一个字的敲的，发布一年后说我抄袭。Lua语言for循环分为两大类：<strong>数值for循环、泛型for循环</strong></p>

<h1><strong>1.数值for循环</strong></h1>

<p>Lua 编程语言中数值for循环语法格式:</p>

<pre class="has">
<code class="language-Delphi">for var=exp1,exp2,exp3 do  
    &lt;执行体&gt;  
end  </code></pre>

<p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 <strong>"执行体"</strong>。exp3 是可选的，如果不指定，默认为1。</p>

<h3>实例：</h3>

<pre class="has">
<code class="language-Delphi">for i=10,1,-2 do
    print(i)
end</code></pre>

<p>以上实例输出结果为：</p>

<p><img alt class="has" height="84" src="https://img-blog.csdnimg.cn/20190402165248152.png" width="440"></p>

<h3><strong>注意：</strong>for的三个表达式在循环开始前一次性求值，以后不再进行求值。</h3>

<pre class="has">
<code class="language-Delphi">function f(x)
    print("function")
    return x*2
end
for i=1,f(5) do 
    print(i)
end
</code></pre>

<p>以上实例输出结果为：</p>

<p><img alt class="has" height="167" src="https://img-blog.csdnimg.cn/20190402165706247.png" width="463"></p>

<h1>2.泛型for循环</h1>

<p>泛型 for 循环通过一个迭代器函数来遍历所有值，Lua 编程语言中泛型 for 循环语法格式:</p>

<pre class="has">
<code class="language-Delphi">--打印数组a的所有值  
a = &#123;"one", "two", "three"&#125;
for i, v in ipairs(a) do
    print(i, v)
end </code></pre>

<p>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。</p>

<h3>实例：</h3>

<pre class="has">
<code class="language-Delphi">days = &#123;"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;  
for i,v in ipairs(days) do 
    print(v) 
end </code></pre>

<p>以上实例输出结果为：</p>

<p><img alt class="has" height="133" src="https://img-blog.csdnimg.cn/20190402170223788.png" width="467"></p>

<p> </p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>LUA LUA语言For循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 协同程序</title>
    <url>/2019/04/17/Lua%20%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3>协同程序(coroutine)简介</h3>

<p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p>

<h3>线程和协同程序区别</h3>

<p>1.线程可以同时运行，协同程序却需要彼此协作的运行。</p>

<p>2.在任一指定时刻<strong>只有一个</strong>协同程序在运行，并且这个正在运行的协同程序只有在<strong>明确的被要求</strong>挂起的时候才会被挂起。</p>

<p>协同程序有点类似与，在等待同一个线程锁的几个线程。</p>

<h3>方法概览</h3>

<p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:225px;"><strong>方法</strong></td>
            <td style="width:624px;"><strong>描述</strong></td>
        </tr><tr><td style="width:225px;">coroutine.create(func)</td><br>            <td style="width:624px;"><br>            <p>创建coroutine，该方法只创建，如需唤醒coroutine需配合resume方法；</p></td></tr></tbody></table></p>
<pre><code>        &lt;p&gt;入参：是协程运行的函数；&lt;/p&gt;

        &lt;p&gt;返回：成功返回coroutine。&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:225px;&quot;&gt;coroutine.resume(co, val1, ...)&lt;/td&gt;
        &lt;td style=&quot;width:624px;&quot;&gt;
        &lt;p&gt;唤醒coroutine，和create配合使用；&lt;/p&gt;

        &lt;p&gt;入参：可任意输入，但是第一个入参必须是coroutine.create()的返回值。&lt;/p&gt;

        &lt;p&gt;           1.如果是第一次唤醒，其余入参作为协程运行函数的入参。多余的参数被舍弃。&lt;/p&gt;

        &lt;p&gt;           2.如果是唤醒调用yield()挂起的协程，其他输入参数将作为yield()的返回值。&lt;/p&gt;

        &lt;p&gt;           除第一个入参外，如果入参个数少于yield()返回值个数，则执行失败，如果多于yield()返回&lt;/p&gt;

        &lt;p&gt;           值个数，则多余的参数被舍弃，执行成功；&lt;/p&gt;

        &lt;p&gt;返回：成功返回true与yield()的入参。失败返回错误提示。&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:225px;&quot;&gt;coroutine.yield(val1, ...)&lt;/td&gt;
        &lt;td style=&quot;width:624px;&quot;&gt;
        &lt;p&gt;挂起coroutine，和resume配合使用能有很多有用的效果；&lt;/p&gt;

        &lt;p&gt;入参：可以任意输入，输入的入参将作为resume的返回值；&lt;/p&gt;

        &lt;p&gt;返回：resume()的入参作。&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:225px;&quot;&gt;coroutine.status(co)&lt;/td&gt;
        &lt;td style=&quot;width:624px;&quot;&gt;
        &lt;p&gt;获取coroutine的状态；&lt;/p&gt;

        &lt;p&gt;入参：coroutine.create()的返回值；&lt;/p&gt;

        &lt;p&gt;返回：返回coroutine的状态有四种：dead，suspend，running,normal。&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:225px;&quot;&gt;coroutine.wrap(func)&lt;/td&gt;
        &lt;td style=&quot;width:624px;&quot;&gt;
        &lt;p&gt;创建coroutine，返回一个函数，一旦你调用这个函数，就进入coroutine，和create功能重复；&lt;/p&gt;

        &lt;p&gt;入参：是协程运行的函数；&lt;/p&gt;

        &lt;p&gt;返回：成功返回一个函数。&lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;width:225px;&quot;&gt;coroutine.running()&lt;/td&gt;
        &lt;td style=&quot;width:624px;&quot;&gt;返回：正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就是返回一个corouting的线程号&lt;/td&gt;
    &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;方法详解&lt;/h3&gt;
</code></pre><p><strong>1. coroutine.create(func)</strong></p>

<p>创建一个主体函数为 func 的新协程。 func 必须是一个 Lua 的函数。 返回这个新协程，它是一个类型为 "thread" 的对象。不会启动该协程。</p>

<pre class="has">
<code class="language-Delphi">local co = coroutine.create(
    function()
        print("this is a coroutine")
        return "coroutine return"
    end)
print(co)
print(coroutine.resume(co))</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="71" src="https://img-blog.csdnimg.cn/20190417104732777.png" width="448"></p>

<p> </p>

<p><strong>2. coroutine.resume(co, val1, ...)与coroutine.yield(val1, ...)</strong></p>

<p><strong>coroutine.resume(co, val1, ...)，开始或唤醒协程co的运行。</strong></p>

<p><ol><li>如果第一次执行一个协程时，他会从协程函数开头处开始运行。val1,...这些值会以参数形式传入主体函数。</li>
    <li>如果该协程被挂起，resume 会重新启动它； val1, ... 这些参数会作为挂起点（yield）的返回值。</li>
    <li>如果协程运行起来没有错误，将运行到协程挂起或协程结束， resume 返回 true 加上传给 yield 的所有值 （当协程挂起）， 或是主体函数的所有返回值（当协程中止）。</li>
</ol></p><p> </p><p></p>
<p><strong>coroutine.yield(val1, ...)，挂起正在调用的协程的执行。 传递给 yield 的参数都会转为 resume 的额外返回值。</strong></p>

<pre class="has">
<code class="language-Delphi">local co = coroutine.create(
    function (input)
        print("input : "..input)
        local param1, param2 ,param3 = coroutine.yield("yield1", "learning1")
        print("param1 is : " .. param1)
        print("param2 is : " .. param2)
        print("param3 is : " .. param3)
        local param4, param5 = coroutine.yield("yield2", "learning2")
    print("param4 is : " .. param4)
    print("param5 is : " .. param5)
        -- return 也会将结果返回给 resume
        return "coroutine return" , 1+2
    end)

--第一次执行,将参数传给input
print("first resume",coroutine.resume(co, "coroutine function"))
print("this is main chunk")
--第二次执行,将参数作为yield的返回值,传给param1 param2 param3
print("second resume",coroutine.resume(co, "param1", "param2", "param3"))
--第三次执行,将参数作为yield的返回值,传给param4 param5 多余的param6被舍弃
print("third resume",coroutine.resume(co, "param4", "param5", "param6"))</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="163" src="https://img-blog.csdnimg.cn/20190417110959958.png" width="467"></p>

<p><strong>分析：</strong></p>

<p><ol><li>第一次调用resume，将协同程序唤醒，入参作为函数入参；</li>
    <li>协同程序运行；</li>
    <li>运行到yield语句；</li>
    <li>yield挂起协同程序，第一次resume返回，,resume操作成功返回true，否则返回false；（注意：此处yield入参（yield1、learning1）是resume的返回值）</li>
    <li>第二次调用resume，将协同程序唤醒，入参（param1, param2 ,param3）作为yield的返回值 ；</li>
    <li>协同程序运行；</li>
    <li>运行到yield语句；</li>
    <li>yield挂起协同程序，第二次resume返回，,resume操作成功返回true，否则返回false；（注意：此处yield入参（yield2、learning2）是resume的返回值）</li>
    <li>...</li>
</ol></p><p> </p><p></p>
<p><strong>3. coroutine.status(co)</strong></p>

<p>以字符串形式返回协程 co 的状态：</p>

<p><ul><li>当协程正在运行（它就是调用 status 的那个） ，返回 "running"；</li>
    <li>如果协程调用 yield 挂起或是还没有开始运行，返回 "suspended"；</li>
    <li>如果协程是活动的，都并不在运行（即它正在延续其它协程），返回 "normal"；</li>
    <li>如果协程运行完主体函数或因错误停止，返回 "dead"。</li>
</ul><pre class="has"><br><code class="language-Delphi">local co<br>local co2 = coroutine.create(function() print(“3.”..coroutine.status(co)) end)<br>co = coroutine.create(<br>    function ()<br>        print(“2.”..coroutine.status(co))<br>        coroutine.resume(co2)<br>        coroutine.yield()<br>    end)</code></pre></p>
<p>print(“1.”..coroutine.status(co))<br>coroutine.resume(co)<br>print(“4.”..coroutine.status(co))<br>coroutine.resume(co)<br>print(“5.”..coroutine.status(co))</p>
<p>&lt;/code&gt;&lt;/pre&gt;</p>
<p><strong>输出：</strong></p>

<p><img alt class="has" height="108" src="https://img-blog.csdnimg.cn/20190417111258814.png" width="453"></p>

<p> </p>

<p><strong>4. coroutine.wrap(func)</strong></p>

<p>创建一个主体函数为 func 的新协程。func 必须是一个 Lua 的函数。返回一个函数，每次调用该函数都会延续该协程(不需要调用resume)。传给这个函数的参数都会作为 resume 的额外参数。和 resume 返回相同的值，只是没有第一个布尔量。</p>

<pre class="has">
<code class="language-Delphi">local wrap = coroutine.wrap(
    function (input)
        print("input : "..input)
        local param1, param2 ,param3 = coroutine.yield("yield1", "learning1")
        print("param1 is : " .. param1)
        print("param2 is : " .. param2)
        print("param3 is : " .. param3)
        local param4, param5 = coroutine.yield("yield2", "learning2")
    print("param4 is : " .. param4)
    print("param5 is : " .. param5)
        -- return 也会将结果返回给 resume
        return "coroutine return" , 1+2
    end)

--第一次执行,将参数传给input
print("first resume", wrap("coroutine function"))
print("this is main chunk")
--第二次执行,将参数作为yield的返回值,传给param1 param2 param3
print("second resume", wrap("param1", "param2", "param3"))
--第三次执行,将参数作为yield的返回值,传给param4 param5 多余的param6被舍弃
print("third resume", wrap("param4", "param5", "param6"))</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="158" src="https://img-blog.csdnimg.cn/2019041711183286.png" width="462"></p>

<p><strong>注：coroutine.wrap不是保护模式运行,如果发生任何错误，抛出这个错误。如下</strong></p>

<pre class="has">
<code class="language-Delphi">local wrap = coroutine.wrap(
    function (input)
        print("input : "..input)
        local param1, param2 ,param3 = coroutine.yield("yield1", "learning1")
        print("param1 is : " .. param1)
        print("param2 is : " .. param2)
        print("param3 is : " .. param3)
        local param4 = coroutine.yield("yield2", "learning2")
    print("param4 is : " .. param4)
    print("param5 is : " .. param5)
        -- return 也会将结果返回给 resume
        return "coroutine return" , 1+2
    end)

--第一次执行,将参数传给input
print("first resume", wrap("coroutine function"))
print("this is main chunk")
--第二次执行,将参数作为yield的返回值,传给param1 param2 param3
print("second resume", wrap("param1", "param2", "param3"))
--第三次执行,将参数作为yield的返回值,传给param4 param5 多余的param6被舍弃
print("third resume", wrap("param4", "param5", "param6"))</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="94" src="https://img-blog.csdnimg.cn/20190417112301475.png" width="723"></p>

<p> </p>

<p><strong>5. coroutine.running()</strong></p>

<p>返回当前的协程,如果实在主线程,则返回nil</p>

<pre class="has">
<code class="language-Delphi">local co = coroutine.create(
    function () 
        print(coroutine.running()) 
        end)

print(coroutine.running())
coroutine.resume(co)
print(co)</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="71" src="https://img-blog.csdnimg.cn/20190417112015927.png" width="501"></p>

<p> </p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Lua 协程（coroutine）</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 表的弱引用</title>
    <url>/2020/09/15/Lua%20%E8%A1%A8%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<p>       最近被问到一个问题，什么是lua表的弱引用，之前看过lua程序设计第四版，但是当时不记得了，并不能回答出来。之后做了简单查阅，作此记录。</p>

<p>       lua的垃圾回收机制是，当一个变量不再被引用了。当触发垃圾回收机制的时候，会回收这部分内存。<strong>而弱引用，则是更好的回收内存的一种方法。</strong>下面上代码：</p>

<p>       <strong>对key设置弱引用之前：</strong></p>

<pre>
<code class="language-Delphi">local t = &#123;&#125;
local key1 = &#123; name  = 'key1' &#125;
t[key1] = 1
key1 = nil

for k,v in pairs(t) do
    print(k,v)
    for k1,v1 in pairs(k) do    --由于k是一个table，再次打印
        print(k1,v1)
    end
end</code></pre>

<p>       输出结果是这样的：</p>

<p><img alt height="63" src="https://img-blog.csdnimg.cn/20200915201431469.png" width="464"></p>

<p>       可以看到，即使我们的表key1置为空了，但是表t依然能够打印出来（是表 t 还是包含着对表 key1 的引用）。<strong>下面我们设置key的弱引用</strong>，代码如下：</p>

<pre>
<code class="language-Delphi">local t = &#123;&#125;
local key1 = &#123; name  = 'key1' &#125;
t[key1] = 1
key1 = nil
setmetatable(t, &#123;__mode = "k"&#125;)   --设置 table 中 key 的弱引用
collectgarbage()                  --手动触发垃圾回收  

for k,v in pairs(t) do
    print(k,v)
    for k1,v1 in pairs(k) do
        print(k1,v1)
    end
end</code></pre>

<p>        <strong>输出结果是这样的：</strong></p>

<p><img alt height="48" src="https://img-blog.csdnimg.cn/20200915200902928.png" width="482"></p>

<p>        可以看到，当触发垃圾回收的时候，表t 已经被清空了。这就是由于对 table key 的弱引用，<strong>当key值没有被别的值引用时，垃圾回收会直接回收含有这个指定key的表的内存。</strong></p>

<p><strong>        弱引用也可以设置位 table 的 value</strong>。</p>

<p>       <strong> 对value设置弱引用之前：</strong></p>

<pre>
<code class="language-Delphi">local t = &#123;&#125;
local key2 = &#123; name = 'key2'&#125;
table.insert(t, key2)
key2 = nil

for k,v in pairs(t) do
    print(k,v)
    for k1,v1 in pairs(v) do      --由于 v 是一个table 再次打印
        print(k1,v1)
    end
end</code></pre>

<p>        <strong>结果如下：</strong></p>

<p><img alt height="90" src="https://img-blog.csdnimg.cn/20200915201721105.png" width="542"></p>

<p>       <strong> 对value设置弱引用：</strong></p>

<pre>
<code class="language-Delphi">local t = &#123;&#125;
local key2 = &#123; name = 'key2'&#125;
table.insert(t, key2)
key2 = nil

setmetatable(t, &#123;__mode = "v"&#125;)   --设置 table value的弱引用
collectgarbage()                  --手动触发垃圾回收

for k,v in pairs(t) do
    print(k,v)
    for k1,v1 in pairs(v) do
        print(k1,v1)
    end
end</code></pre>

<p>         <strong>结果如下：</strong></p>

<p><img alt height="59" src="https://img-blog.csdnimg.cn/2020091520251692.png" width="418"></p>

<p>        <strong>也可以同时设置对 key 和 value 的弱引用。</strong>这样一旦有一个被置为nil，则垃圾回收时直接触发回收。</p>

<pre>
<code class="language-Delphi">local t = &#123;&#125;
local key2 = &#123; name = 'key2'&#125;
table.insert(t, key2)
key2 = nil

setmetatable(t, &#123;__mode = "v"&#125;)   --设置 table，key 和 value 的弱引用
collectgarbage()                  --手动触发垃圾回收

for k,v in pairs(t) do
    print(k,v)
    for k1,v1 in pairs(v) do
        print(k1,v1)
    end
end</code></pre>

<p>        <strong> 结果如下：</strong></p>

<p><img alt height="59" src="https://img-blog.csdnimg.cn/2020091520251692.png" width="418"></p>

<p> </p>

<p><strong>         </strong>最后，合理的使用弱引用，可以加强垃圾回收。但是如果不熟悉，也可能造成意想不到的后果。</p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 表的排序，table.sort应用</title>
    <url>/2020/02/28/Lua%20%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%8Ctable.sort%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<p>       最近项目使用到表的排序，我使用table.sort通过表的value排序，使用key进行排序暂未研究。之前一直不是很清楚table.sort这个方法，刚好有机会记录一下。</p>

<p>方法原型：<strong>table.sort (table, funtion(a,b))</strong></p>

<p>两个入参：1.table-----------需要排序的table</p>

<p>                  2.function-------排序方法，可自定义。如果不填，则按默认排序。形式是固定的，<strong>入参a,b为排序table中的value1、value2....(这个具体不知道怎么描述)</strong></p>

<p> </p>

<p><strong>1.不传排序方法，采用自定义：</strong></p>

<p><img alt height="233" src="https://img-blog.csdnimg.cn/20200228181909324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="820"></p>

<p>结果：</p>

<p><img alt height="273" src="https://img-blog.csdnimg.cn/20200228181946524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="588"></p>

<p>可以看到，table.sort默认是使用table中存贮的 value进行从小到大的排序，有一点需要注意的是，如果table中含有number和string，使用默认的方法进行比较会报 number和string比较的错误。也有一些别的坑，使用的时候需要谨慎(默认的我用的比较少)</p>

<p><strong>2.传入自定义的排序方法：</strong></p>

<p>例如传入的table是 :</p>

<p><img alt height="151" src="https://img-blog.csdnimg.cn/20200228200424965.png" width="540"></p>

<p>传入的方法的格式是固定的，也就是一个</p>

<p>匿名函数function(a,b)</p>

<p>               ........(你的实现)</p>

<p>              end</p>

<p>匿名函数中的a,b是传入的table的2个value，table.sort每次会返回两个value传入比较函数。上例是t中的value。</p>

<p>比较函数是这样的：</p>

<p><img alt height="83" src="https://img-blog.csdnimg.cn/20200228201556405.png" width="397"></p>

<p>结果为：</p>

<p><img alt height="335" src="https://img-blog.csdnimg.cn/20200228201704536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="657"></p>

<p>自定义的比较函数功能十分强大，但是也有一些坑。</p>

<p><strong>注意：</strong></p>

<p><strong>1.table.sort并不稳定，当条件的两个元素相等时，它们在排序后的相对位置可能会改变(据说，我自己暂未出现，可能用的少)</strong></p>

<p><strong>2.要求需要排序table中间元素不能有nil，否则会报错</strong></p>

<p><strong>3.当比较的两个元素相等的时候，比较函数一定要返回false，返回true会报错，table.sort会根据你返回的bool来判断两个value是否保持原来的顺序</strong></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
  </entry>
  <entry>
    <title>Lua位操作</title>
    <url>/2020/07/07/Lua%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>
<p>       在用redis写排行榜的时候，相同积分的情况要按照到达时间排序，用到了Lua的位操作，网上很少这方面的资料，写一下做简单笔记。</p>

<p>       lua位操作其实和c语言一样，例子如下:</p>

<p>      <img alt height="119" src="https://img-blog.csdnimg.cn/20200707200527919.png" width="479"></p>

<p>      结果为:</p>

<p>     <img alt height="64" src="https://img-blog.csdnimg.cn/20200707200654971.png" width="561"></p>

<p> </p>

<p>    实际应用可以看看我的另一篇博客，《使用redis做排行榜相同积分情况下，如何使用到达时间来排序》</p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua元表（__index方法个人理解）</title>
    <url>/2019/04/16/Lua%E5%85%83%E8%A1%A8%EF%BC%88__index%E6%96%B9%E6%B3%95%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<p><strong>什么是Lua元表：</strong></p>

<p>原表可理解为“一个<strong>方法表</strong>（类似函数表）“，里面包含了一些解决方案。当一个table设置元表之后，相当于关联了这个方法表</p>

<p><ul><li><strong>setmetatable(table,metatable):</strong> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li>
    <li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li>
</ul></p><h3>实例：</h3><p></p>
<pre>
<code class="language-Lua">mytable = &#123;&#125; ;                         -- 普通表
mymetatable = &#123;&#125; ;                     -- 元表
setmetatable(mytable,mymetatable);     -- 把 mymetatable 设为 mytable 的元表</code></pre>

<h3>以下为返回对象元表：</h3>

<pre>
<code class="language-Lua">getmetatable(mytable)                            -- 这回返回mymetatable</code></pre>

<p> </p>

<p>元表中有很多原方法，下面以<strong>__index元方法</strong>为例：</p>

<p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。</p>

<h3>例如：</h3>

<pre>
<code class="language-Lua">house = &#123;house_computer = "Macbook"&#125;;
company = &#123;company_computer = "Acer"&#125;;
setmetatable(house, company);                  --把company设置为house的metatable
print(house.company_computer);</code></pre>

<p>输出的结果是<strong>nil</strong>。</p>

<p> </p>

<p>把代码改为：</p>

<pre>
<code class="language-Lua">house = &#123;house_computer = "Macbook"&#125;;
company = &#123;company_computer = "Acer"&#125;;
company.__index = company;               -- 把company的__index方法指向自己
setmetatable(house, company);            --把company设置为house的metatable
print(house.company_computer);</code></pre>

<p>输出的结果是<strong>Acer</strong>。</p>

<p>在刚学习时，对<strong>__index</strong>方法有所误解：<strong>如果house 的元表是company ，如果访问了一个house中不存在的成员，就会访问查找company中有没有这个成员。</strong>而这个理解实际上是错误的，即使将house的元表设置为company，而且company中也确实有这个成员，返回结果仍然会是nil，原因就是company的__index元方法没有赋值。之前有说过，原表类似于“<strong>方法表</strong>”，设置元表相当于关联了方法表，但是并不是在方法表里查找元素，而应该是调用方法表里相应的方法。<span style="color:#f33b45;"><strong>__index就是定义了当表在查找相应的key值对应的value时，查找失败，应该怎么办。</strong></span></p>

<p>把代码改为：</p>

<pre>
<code class="language-Lua">house = &#123;house_computer = "Macbook"&#125;;
company = &#123;company_computer = "Acer"&#125;;
company.__index = function()
                    return "hello world!";
                    end
setmetatable(house, company);    --把company设置为house的metatable
print(house.company_computer);</code></pre>

<p>输出的结果是<strong>hello world!</strong>。</p>

<p>在上述例子中，访问house.company_computer时，house中没有company_computer这个成员，但Lua接着发现house有元表company，注意：<span style="color:#f33b45;">此时，Lua并不是直接在company中找名为company_computer的成员，而是调用company的__index方法</span>，如果__index方法为nil，则返回nil，如果是一个表，那么就到__index方法所指的这个表中查找名为company_computer的成员，于是，最终找到了company_computer成员。__index方法除了可以是一个表，还可以是一个函数，如果是一个函数，__index方法被调用时将返回该函数的返回值。</p>

<p> </p>

<blockquote>
<h3>总结</h3>

<p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p>

<ul><li>1.在表中查找，如果找到，返回该元素，找不到则继续</li>
    <li>2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li>
    <li>3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li>
</ul><p>该部分内容来自作者寰子：https://blog.csdn.net/xocoder/article/details/9028347</p>
</blockquote>

<h2>注：别的元方法也一样，调用的是实际上是设置的元表的元方法。</h2>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Lua 元表 __index</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua时间函数os.time()与os.data()的具体运用-------如何得知条件天数后的日期</title>
    <url>/2019/11/17/Lua%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0os.time()%E4%B8%8Eos.data()%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%90%E7%94%A8-------%E5%A6%82%E4%BD%95%E5%BE%97%E7%9F%A5%E6%9D%A1%E4%BB%B6%E5%A4%A9%E6%95%B0%E5%90%8E%E7%9A%84%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<span id="more"></span>
<p>      最近的工作是要求写一个任务系统，需要在特定日期重置任务，或者在天数后重置任务。</p>

<p>      这就延伸出一个问题，如何得知条件天数后的日期。</p>

<p>      这个问题的难点在于，每个月的天数不一样，加上相同的天数后每个月变化后的日期怎么处理。</p>

<p>      例如，我们要求40天后的日期</p>

<h3>     其实lua的时间函数十分强大，可以用以下方法:    </h3>

<p>     1.算出当时间，以表表示。</p>

<p>     2.算出40天后的日期。</p>

<p>     程序与结果如下</p>

<pre class="has">
<code class="language-Go">local now_time = os.date("*t", os.time())
for k,v in pairs(now_time) do
    print(k,v)
end
print("----------------分割--------------------------")

now_time.day = now_time.day + 40
local next_monday = os.date("*t", os.time(now_time))
for k,v in pairs(next_monday) do
    print(k,v)
end</code></pre>

<p>      <img alt class="has" height="347" src="https://img-blog.csdnimg.cn/20191117130731630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="494"></p>

<h3>      特别说明</h3>

<p>      1.os.date创建日期表时now_time，所有的字段均在有效范围之内。(例如, now_time.daya+40之后，now_time.day = 57)</p>

<p>      2.os.time传入一个修改后的日期表now_time(now_time.day = 57)时，其中的字段不需要归一化，会自动处理，得到新时间戳</p>

<p>      3.得到的t2时间戳通过os.date转化为日期表，及可得到40天后的被归一化日期表。</p>

<p>      4.同理也可以通过改变hour来计算5小时后，改变min来计算100分钟后，改变month来计算6个月后的日期。</p>

<p>     </p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Lua 时间函数 os.time os.date</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua逻辑运算符and，or，not</title>
    <url>/2019/04/15/Lua%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6and%EF%BC%8Cor%EF%BC%8Cnot/</url>
    <content><![CDATA[<span id="more"></span>
<p>在Lua中合理使用and，or，not可提高代码效率，减少代码量，增加可读性。</p>

<p>Lua逻辑运算符and，or，not规则如下：</p>

<p>设定 <strong>A 的值为 true</strong>，<strong>B 的值为 false</strong>：</p>

<p><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:72px;"><strong>操作符</strong></td>
            <td style="width:621px;"><strong>描述</strong></td>
            <td style="width:178px;"><strong>实例</strong></td>
        </tr><tr><td style="width:72px;">and</td>
            <td style="width:621px;">逻辑与操作符。 若 A 为 true，则返回 B；若A为false，则返回A。</td>
            <td style="width:178px;">(A and B) 为 false。</td>
        </tr><tr><td style="width:72px;">
            <p>or</p>
            </td>
            <td style="width:621px;">逻辑或操作符。 若 A 为 true，则返回 A，若A为false，则返回 B。</td>
            <td style="width:178px;">(A or B) 为 true。</td>
        </tr><tr><td style="width:72px;">not</td>
            <td style="width:621px;">逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td>
            <td style="width:178px;">not(A and B) 为 true。</td>
        </tr></tbody></table></p><p><strong>优先级and&gt;or，意味着当一行代码同时出现and与or的时候，先进行and操作。</strong></p><p></p>
<pre class="has">
<code class="language-Delphi">A or B and C == A or (B and C）</code></pre>

<p><strong>例子：</strong></p>

<pre class="has">
<code class="language-Delphi">print('---------------and--------------------')
print(true and true)
print(true and false)
print(false and true)
print(false and false)
print('---------------or---------------------')
print(true or true)
print(true or false)
print(false or true)
print(false or false)
print('--------------not---------------------')
print(not(true))
print(not(false))
print('------------and，or-------------------')
print(true or false and false)</code></pre>

<p><strong>输出：</strong></p>

<p><img alt class="has" height="210" src="https://img-blog.csdnimg.cn/20190415115145741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="506"></p>

<p><strong>lua三目运算符：</strong></p>

<pre>
<code class="language-html hljs">ret = a &gt; b and a or b</code></pre>

<p>a&gt;b时：a&gt;b and a or b-----&gt;a or b-----&gt;a</p>

<p>a&lt;=b时：a&gt;b and a or b -----&gt;a&gt;b or b-----&gt;b</p>

<p><strong>lua并不能完全实现三目运算符</strong></p>

<p><ul><li><br>    <p>三目运算的一般形式a ? b : c</p></li></ul></p>
<pre><code>&lt;p&gt;a = true,结果为b&lt;br /&gt;
a = false,结果为c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应Lua中的a and b or c&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;b = true
    &lt;ul&gt;&lt;li&gt;a = true
        &lt;ul&gt;&lt;li&gt;a and b –&amp;gt; true&lt;/li&gt;
            &lt;li&gt;b or c –&amp;gt; b&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
        &lt;li&gt;a = false
        &lt;ul&gt;&lt;li&gt;a and b –&amp;gt; false&lt;/li&gt;
            &lt;li&gt;b or c –&amp;gt; c&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
    &lt;li&gt;b = false
    &lt;ul&gt;&lt;li&gt;a = true
        &lt;ul&gt;&lt;li&gt;a and b –&amp;gt; false&lt;/li&gt;
            &lt;li&gt;b or c –&amp;gt; c&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
        &lt;li&gt;a = false
        &lt;ul&gt;&lt;li&gt;a and b –&amp;gt; false&lt;/li&gt;
            &lt;li&gt;b or c –&amp;gt; c&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
</code></pre><p>&lt;/ul&gt;</p><p>由此可见，lua要想实现三目运算符要注意</p><p></p>
<h3><strong>注意：Lua中的and与or，和C/C++的与、或有所区别。不要混淆使用。</strong></h3>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Lua and、or、no&amp;#039;t lua三目运算符浅析</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua，pairs与ipairs区别</title>
    <url>/2019/04/02/Lua%EF%BC%8Cpairs%E4%B8%8Eipairs%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<span id="more"></span>
<p>pairs遍历表中全部key，value</p>

<p>ipairs 这个迭代器只能遍历所有数组下标的值，这是前提，也是和 pairs 的最根本区别，也就是说如果 ipairs 在迭代过程中是会直接跳过所有手动设定key值的变量。</p>

<p>特别注意一点，和其他多数语言不同的地方是，迭代的下标是从1开始的。</p>

<h3>pairs实例：</h3>

<pre class="has">
<code class="language-Delphi">tab = &#123;1, 2, 3, key1 = nil, key2 = "val2", nil,  "d"&#125;
for k, v in pairs(tab) do
    print(k,v)
end</code></pre>

<p>以上实例结果：</p>

<p><img alt class="has" height="95" src="https://img-blog.csdnimg.cn/20190402171306522.png" width="493"></p>

<p><strong>注意：pairs遍历过程中元素出现的顺序可能是随机的，唯一能确定的是，每个元素只会出现一次。</strong></p>

<p> </p>

<h3>ipairs实例：</h3>

<pre class="has">
<code class="language-Delphi">tab = &#123;1, 2, 3, key1 = nil, key2 = "val2", nil,  "d"&#125;
for k, v in ipairs(tab) do
    print(k,v)
end


tab = &#123;1, 2, 3, key1 = nil, key2 = "val2", "d"&#125;
for k, v in ipairs(tab) do
    print(k,v)
end

</code></pre>

<p>以上实例结果：</p>

<p><img alt class="has" height="152" src="https://img-blog.csdnimg.cn/20190402172336252.png" width="464"></p>

<p>ps：中间那道杠（-------）是分隔符，插入代码时不能选择LUA，选择了别的语言代替，上面实例代码中删除了打印分隔符，如果没删除，代码会变成纯白色，可读性不强。</p>

<h2>总结：</h2>

<h3><strong>1.pairs</strong> 能迭代所有键值对。</h3>

<h3><strong>2.ipairs</strong> 可以想象成 <strong>int+pairs</strong>，只会迭代键为数字的键值对。</h3>

<h3>3.ipairs在迭代过程中如果遇到nil时会直接停止。</h3>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>LUA中pairs与ipairs区别</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC之Tab Control简单使用</title>
    <url>/2019/01/10/MFC%E4%B9%8BTab%20Control%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>
<p>    <strong>Tab Control</strong>是MFC中一个常用的功能，可实现切换界面，将不同功能的控件放置在不同页面中。</p>

<p><strong>1.在工具栏中选择Tab Control控件，将控件大小拉满整个对话框，如图：</strong></p>

<p><img alt class="has" height="330" src="https://img-blog.csdnimg.cn/20190109152640207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="708"></p>

<p><strong>2.在对话框类中声明一个 CTabCtrl变量：</strong></p>

<p>CTabCtrl m_tab;</p>

<p>变量用于与Tab Control控件交互,为此要在DoDataExchange函数中加入DDX_Control语句：</p>

<p>DDX_Control(pDX, IDC_TAB1, m_tab);    //IDC_TAB1为控件ID</p>

<p><img alt class="has" height="214" src="https://img-blog.csdnimg.cn/20190109160421504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="645"></p>

<p><strong>3.选择资源视图插入两个测试页面，右键点击Dialog，选择插入Dialog中，作为Tab Control控件切换的界面，然后将插入的对话框的Border属性设置为None，Style设置为Child，设置后的效果如下图所示：</strong></p>

<p><img alt class="has" height="683" src="https://img-blog.csdnimg.cn/20190109162504991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>4.为创建的两个话框建立类，如DlgSS、DlgFinance。添加类的方法：右击对话框界面，在弹出框中选择添加类；</strong></p>

<p><img alt class="has" height="392" src="https://img-blog.csdnimg.cn/20190109162658726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="704"></p>

<p><strong>5.在Tab Control控件所在的<span>对话框类的</span><span style="color:#f33b45;">头文件</span>中添加插入的<span style="color:#f33b45;">页面对话框的头文件</span>，然后添加以下内容：</strong></p>

<p>int m_FuncTab;<br>
    DlgSS m_page0;    //没加头文件会报错<br>
    DlgFinance m_page1;//没加头文件会报错<br>
    std::vector&lt;CDialog*&gt; m_pDialog;  //用来保存对话框对象指针，记得添加vector的头文件<br>
    afx_msg void OnTcnSelchangeTab1(NMHDR *pNMHDR, LRESULT *pResult);</p>

<p><strong>6.在对话框类的初始化函数中需要把DlogSS和Tab Control关联起来，并保存页面地址，设置初始页面，在OnInitDialog()中添加以下实现代码：</strong></p>

<p>  </p>

<p>    // 为Tab Control增加页面<br>
    m_tab.InsertItem(0, _T("测试0"));<br>
    m_tab.InsertItem(1, _T("测试1"));</p>

<p>    //创建对话框<br>
    m_page0.Create(IDD_DIALOG_SS, &amp;m_tab);<br>
    m_page1.Create(IDD_DIALOG_Finance, &amp;m_tab);<br>
    //设定在Tab内显示的范围<br>
    CRect rc;<br>
    m_tab.GetClientRect(rc);<br>
    rc.top += 20;<br>
    rc.bottom -= 0;<br>
    rc.left += 0;<br>
    rc.right -= 0;<br>
    m_page0.MoveWindow(&amp;rc);    //设置子对话框尺寸并移动到指定位置<br>
    m_page1.MoveWindow(&amp;rc);    //设置子对话框尺寸并移动到指定位置</p>

<p>    //把对话框对象指针保存起来<br>
    m_pDialog.push_back(&amp;m_page0);<br>
    m_pDialog.push_back(&amp;m_page1);<br>
    //显示初始页面<br>
    m_pDialog[0]-&gt;ShowWindow(SW_SHOW);<br>
    <br>
    //保存当前选择<br>
    m_FuncTab = 0;</p>

<p><strong>7.为Tab Control添加消息处理程序，双击Tab Control控件，自动进入消息处理程序代码：</strong></p>

<p><img alt class="has" height="246" src="https://img-blog.csdnimg.cn/20190109171224342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="677"></p>

<p><strong>8.运行结果如图：</strong></p>

<p><img alt class="has" height="389" src="https://img-blog.csdnimg.cn/20190110101036693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="576"></p>

<p><img alt class="has" height="389" src="https://img-blog.csdnimg.cn/20190110101045142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="576"></p>

<p> </p>

<p>本文参考的资料有：http://blog.csdn.net/hustspy1990/article/details/5425365</p>

<p> </p>]]></content>
      <tags>
        <tag>MFC学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC应用程序类型：单文档、多文档与基于对话框</title>
    <url>/2019/01/09/MFC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%8D%95%E6%96%87%E6%A1%A3%E3%80%81%E5%A4%9A%E6%96%87%E6%A1%A3%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>单文档：记事本类程序的标准模式，有菜单栏、工具栏等，只能进行一份文档的操作，即不能同时在同一个应用程序中打开两个文件</p>

<p>多文档：WORD类或浏览器程序的标准模式，可多个窗口显示不同的信息，进行不同的任务，有过个视图环境，可同时操作多个文件。多个文件共享同一菜单栏、工具栏等</p>

<p>对话框：可方便的使用控件，所见即所得的编程，没有菜单栏、工具栏等</p>

<p><br>
怎样看出一个MFC应用程序是基于单文档、多文档还是对话框？</p>

<p>1.运行应用程序观看，对话框一般没有菜单栏、工具栏等，单文档和多文档有，另多文档可产生子窗口，会有一个childframe class</p>

<p>2.从源码中的类观看：</p>

<p>   基于对话框—&gt;一般含以下3个类：CAboutDlg、程序名App、程序名Dlg</p>

<p>   基于单文档—&gt;一般含以下4个类：CMainFrame、程序名App、程序名Doc、程序名View</p>

<p>   基于多文档—&gt;一般含以下5个类：CMainFrame、CChildFrame、程序名App、程序名Doc、程序名View<br>
---------------------<br>
作者：Lemon萫<br>
来源：CSDN<br>
原文：https://blog.csdn.net/shushuidewoniu/article/details/8631721<br>
版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中如何设置set中的元素过期</title>
    <url>/2021/04/15/Redis%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEset%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%87%E6%9C%9F/</url>
    <content><![CDATA[<span id="more"></span>
<p>最近在工作中碰到了这个问题，我需要在一个set中记录集群中k8s pod的ip，但是pod随时会挂，所以采取一个定时让每个pod去update cache的做法。但是set中是无法设置其中元素过期时间的。有两个解决方法</p>
<h2 id="把set改用sorted-set"><a href="#把set改用sorted-set" class="headerlink" title="把set改用sorted set"></a>把set改用sorted set</h2><p>每个元素都带上分数，这个分数就是你的过期时间。先用ZRemRangeByScore删除过期元素（分数之外的元素），然后每个pod带上过期时间戳去定时去EasyZAdd，下面是伪代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">	nowTime := time.Now().Unix()</span><br><span class="line">	redis.ZRemRangeByScore(<span class="string">&quot;setName&quot;</span>, <span class="string">&quot;0&quot;</span>, strconv.FormatInt((nowTime-5), 10))</span><br><span class="line">	urlInfo := redis.Z&#123;</span><br><span class="line">		Score:  float64(nowTime), //以秒为单位</span><br><span class="line">		Member: *h.SqsUrl&#125;</span><br><span class="line">	redis.ZAdd(<span class="string">&quot;setName&quot;</span>, &amp;urlInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不用set，用string"><a href="#不用set，用string" class="headerlink" title="不用set，用string"></a>不用set，用string</h2><p>这个就是使用固定的开头，例如:my<em>server_ip_xxx.xxx.xxx。然后使用传统的setex，获取key的时候使用模糊匹配，keys my_server_ip</em>*也可。</p>
<p>用哪种仁者见仁智者见智。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04.3 安装redis，配置端口与密码</title>
    <url>/2019/08/12/Ubuntu%2018.04.3%20%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<span id="more"></span>
<p>     实际开发中，经常需要配置redis的端口与密码，硬盘坏了，换个硬盘，重新装开发环境</p>

<p>     1.sudo  apt-get install redis-server </p>

<p>     2.查看是否安装成功，安装成功，会自动启动</p>

<p>        ps -aux | grep redis  </p>

<p>      <img alt class="has" height="64" src="https://img-blog.csdnimg.cn/20190812175832794.png" width="865"></p>

<p>     3.修改端口</p>

<p>      sudo subl /etc/redis/redis.conf </p>

<p>      <img alt class="has" height="112" src="https://img-blog.csdnimg.cn/20190812191828737.png" width="811"></p>

<p>       将6379改为自己需要的端口。然后保存</p>

<p>      4.重启redis，然后查看</p>

<p>        sudo service redis-server restart</p>

<p>        ps -aux | grep redis</p>

<p>      <img alt class="has" height="47" src="https://img-blog.csdnimg.cn/20190812192049810.png" width="1200"></p>

<p>        已修改成功。</p>

<p>       5.继续修改redis.conf </p>

<p>       找到一个  # requirepass foobared  的字段将这个字段的注释取消掉，这个字段是数据的访问密码，将foobared替换成自己想要设置的密码。</p>

<p>       <img alt class="has" height="151" src="https://img-blog.csdnimg.cn/20190812193802128.png" width="487"> </p>

<p>       修改之后</p>

<p>       <img alt class="has" height="134" src="https://img-blog.csdnimg.cn/2019081219385547.png" width="438"></p>

<p>      6.重启redis</p>

<p>      sudo service redis-server restart</p>

<p> </p>

<p>      sbul是我装了sublime text之后的编辑器，如果没有安装，将subl换成vi/vim即可。我自己通过以上方式，已能修改，做次记录。</p>

<p> </p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Ubuntu redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04.3 安装svn</title>
    <url>/2019/08/12/Ubuntu%2018.04.3%20%E5%AE%89%E8%A3%85svn/</url>
    <content><![CDATA[<span id="more"></span>
<p>        今天早上上班后，发现电脑的机械硬盘居然崩了，原来以为这种情况只会存在传说中，没想到自己真正碰到了。由于基本上所有的资料和开发环境都是存在机械硬盘上的，一切的一切只能重来，借此机会，记录一下自己走过的路。</p>

<p>      <strong> </strong>使用的是：</p>

<p>       VMware:Workstation 15 Pro          <a href="https://www.7down.com/soft/310739.html">https://www.7down.com/soft/310739.html</a></p>

<p>       Ubuntu:18.04.3                                <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p>

<p> </p>

<p>       <strong>这些下载好之后，便开始装svn：</strong></p>

<p>      <strong> 1.sudo apt-get update</strong></p>

<p><strong>       2.sudo apt install subversion</strong></p>

<p><strong>       3.输入 svn help 查看是否安装成功 </strong></p>

<p>         <img alt class="has" height="317" src="https://img-blog.csdnimg.cn/20190812150011860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="771"></p>

<p>出现这个，则表示安装成功。</p>

<p>        <strong>4.安装成功后，输入svn co + 你的地址，会提示你输入svn账号与密码。</strong></p>

<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>svn Ubuntu 18.04.3</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Lua调用C函数。</title>
    <url>/2020/10/09/Ubuntu%20Lua%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>      用了很久lua，框架原因，今天写一下lua调用so库。</p>

<p>      真的是不做不知道，一做真奇妙。网上那么多篇文章，基本上都是你抄我，我抄你。错误都一样，验证都没验证过。。。</p>

<p>      先声明一下我的环境，Ubuntu 18.04，lua5.3</p>

<p><strong>1.概念补充，lua和c交互是通过一个虚拟的栈来交互的，为什么是这样？</strong></p>

<p>C与Lua之间通信关键内容在于一个虚拟的栈。几乎所有的调用都是对栈上的值进行操作，所有C与Lua之间的数据交换也都通过这个栈来完成。另外，也可以使用栈来保存临时变量。每一个与Lua通信的C函数都有其独有的虚拟栈，虚拟栈由Lua管理。<br>
栈的使用解决了C和Lua之间两个不协调的问题：第一，Lua会自动进行垃圾收集，而C要求显式的分配存储单元，两者引起的矛盾。第二，Lua中的动态类型和C中的静态类型不一致引起的混乱。</p>

<p><strong>2.要想调用C中的方法，则需要把C编译成动态库，我是在linux下，所以是.so，代码如下</strong></p>

<p>c_so.cpp</p>

<pre>
<code class="language-cpp">extern "C" &#123;
  #include &lt;stdio.h&gt;
  #include &lt;lua.h&gt;
  #include &lt;lualib.h&gt;
  #include &lt;lauxlib.h&gt;
&#125;


//自定义函数
static int my_add(lua_State *L)
&#123;
    int x = lua_tonumber(L,1); //第一个参数,转换为数字
    int y = lua_tonumber(L,2); //第二个参数,转换为数字
    int sum = x + y;           
    lua_pushnumber(L, sum);    //将函数的结果压入栈中。如果有多个返回值，可以在这里多次压入栈中。
    return 1; //返回sum计算结果
&#125;

static int showstr(lua_State *L)
&#123;
   //从lua中传入的第一个参数
   const char *str = lua_tostring (L, 1);

   printf ("c program str = %s\n", str);
   return 0;
&#125;

/* 需要一个"luaL_Reg"类型的结构体，其中每一个元素对应一个提供给Lua的函数。
 * 每一个元素中包含此函数在Lua中的名字，以及该函数在C库中的函数指针。
 * 最后一个元素为“哨兵元素”（两个"NULL"），用于告诉Lua没有其他的函数需要注册。
 */
static luaL_Reg funclist[] =
&#123;
    &#123;"add", my_add&#125;, //my_add()函数，lua中访问时使用名称为add
    &#123;"show", showstr&#125;, //showstr()函数，lua中访问时使用名称为show
    &#123;NULL, NULL&#125;,  //最后必须有这个
&#125;;

/* 此函数为C库中的“特殊函数”。
 * 通过调用它注册所有C库中的函数，并将它们存储在适当的位置。
 * 此函数的命名规则应遵循：
 * 1、使用"luaopen_"作为前缀。
 * 2、前缀之后的名字将作为"require"的参数。
 */
extern "C" int luaopen_mylib(lua_State *L )
&#123;
     /* void luaL_newlib (lua_State *L, const luaL_Reg l[]);
     * 创建一个新的"table"，并将"l"中所列出的函数注册为"table"的域。
     */ 
    luaL_newlib(L, funclist);
    return 1;
&#125;</code></pre>

<p>然后编译 <strong>gcc -shared -fPIC c_so.cpp -o mylib.so -I /home/lk/my_skynet_learning/skynet/3rd/lua/</strong></p>

<p>编译完成后将会得到mylib.so</p>

<p><img alt height="41" src="https://img-blog.csdnimg.cn/20201009195100952.png" width="474"></p>

<p>testso.lua</p>

<pre>
<code class="language-bash">local mylib = require "mylib"

local i = mylib.add(1, 2)
print(i)

local j = mylib.show('真的太多坑了')</code></pre>

<p>运行结果如下</p>

<p><img alt height="137" src="https://img-blog.csdnimg.cn/20201009195329107.png" width="680"></p>

<p> </p>

<p>网上搜的真的是各种坑。哎。</p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装、使用SVN</title>
    <url>/2020/02/10/Ubuntu%20%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8SVN/</url>
    <content><![CDATA[<span id="more"></span>
<p>      <strong>1.在terminal 输入 svn 看是否有安装svn</strong></p>

<p><strong>       </strong><img alt class="has" height="99" src="https://img-blog.csdnimg.cn/20200210135345374.png" width="519"></p>

<p>      <strong>2.如果和我一样没装有svn则执行 sudo apt install subversion</strong></p>

<p><strong>      </strong><img alt class="has" height="265" src="https://img-blog.csdnimg.cn/20200210135528732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="582"></p>

<p>    <strong> 3.在首次使用svn check out的时候，会直接提示输入账号密码。</strong></p>

<p><strong>     4.如果想要修改svn的账号与密码，删除目录 ~/.subversion/auth/ 下的所有文件。下一次操作svn时会提示你重新输入用户名和密码的。换成你想用的就可以了。然后系统默认会记录下来的。</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu svn</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04.3 安装redis，配置端口与密码</title>
    <url>/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Ubuntu-18-04-3-安装redis，配置端口与密码"><a href="#Ubuntu-18-04-3-安装redis，配置端口与密码" class="headerlink" title="Ubuntu 18.04.3 安装redis，配置端口与密码"></a>Ubuntu 18.04.3 安装redis，配置端口与密码</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>sudo apt-get install redis-server</code></p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><code>ps -aux | grep redis</code><br><img src="/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/803319237335.png" alt></p>
<h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><p><code>sudo subl /etc/redis/redis.conf</code>，改为自己想要的端口。<br><img src="/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/1589519230469.png" alt></p>
<h2 id="重启redis"><a href="#重启redis" class="headerlink" title="重启redis"></a>重启redis</h2><p><code>sudo service redis-server restart</code><br><code>ps -aux | grep redis</code><br><img src="/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/2428019220999.png" alt></p>
<h2 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h2><p>继续修改<code>/etc/redis/redis.conf</code>，找到一个  # requirepass foobared  的字段将这个字段的注释取消掉，这个字段是数据的访问密码，将foobared替换成自己想要设置的密码。<br><img src="/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/3274819223503.png" alt><br>修改后重启redis，<code>sudo service redis-server restart</code><br><img src="/2022/05/08/Ubuntu-18-04-3-%E5%AE%89%E8%A3%85redis%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AF%86%E7%A0%81/3825619232450.png" alt></p>
<p>sbul是我装了sublime text之后的编辑器，如果没有安装，将subl换成vi/vim即可。我自己通过以上方式，已能修改，做次记录。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu连接redis时可指定ip，端口，密码。</title>
    <url>/2019/09/04/Ubuntu%E8%BF%9E%E6%8E%A5redis%E6%97%B6%E5%8F%AF%E6%8C%87%E5%AE%9Aip%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%AF%86%E7%A0%81%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>       转做游戏服务器开发之后，基本上都在写游戏逻辑，关于redis的操作也已经有了现成的接口。今天提交了代码有点空闲时间打算学一学redis。</p>

<p>       博主是按照网上的教程使用redis-cli去连接redis，但是之前本地的redis已经改过redis的默认配置文件，直接使用redis-cil发现并不能连接上。</p>

<p>       <img alt class="has" height="89" src="https://img-blog.csdnimg.cn/20190904165940392.png" width="671"></p>

<p>查询资料后发现可以指定ip，端口，和密码如下。</p>

<p>    <strong>  redis-cli -h xxx.xxx.xxx.xxx -p xxxx -a mima   例如（redis-cli -h 127.0.0.1 -p 12345 -a zheshimima）</strong></p>

<p>即可连接。作此记录。</p>
]]></content>
      <categories>
        <category>redis Linux</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 启动 redis cluster，使用出现CLUSTERDOWN Hash slot not served（redis cluster重新分配slot）</title>
    <url>/2021/12/07/docker%20%E5%90%AF%E5%8A%A8%20redis%20cluster%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0CLUSTERDOWN%20Hash%20slot%20not%20served%EF%BC%88redis%20cluster%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8Dslot%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>就像上一篇所说，我使用了docker-componse启动了redis cluster集群。经过了一天的测试，本来测试已经完毕了，但是今天修改了点代码，再次测试的时候发现redis cluster起不来了。报错<code>CLUSTERDOWN Hash slot not served</code>。从这个错误提示，可以看出是slot分配原因造成的。上网找，真的蛋疼，你复制我，我复制你，最后还是得自己解决。</p>
<h1 id="查看详细"><a href="#查看详细" class="headerlink" title="查看详细"></a>查看详细</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@banfushen:~/redis-cluster$ redis-cli -p 16379</span><br><span class="line">127.0.0.1:16379&gt;</span><br><span class="line">127.0.0.1:16379&gt;</span><br><span class="line">127.0.0.1:16379&gt; CLUSTER info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">...</span><br><span class="line">127.0.0.1:16379&gt; CLUSTER SLOTS</span><br><span class="line">Empty slot</span><br></pre></td></tr></table></figure>
<h1 id="直接修复"><a href="#直接修复" class="headerlink" title="直接修复"></a>直接修复</h1><p>猜测就是slot分配的问题，进入具体container，重新分配slot<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@banfushen:~/redis-cluster$ docker <span class="built_in">exec</span> -it redis-node-0 /bin/bash</span><br><span class="line">root@a77b8222eba2:/<span class="comment">#</span></span><br><span class="line"><span class="comment">## 先查看命令</span></span><br><span class="line">root@a77b8222eba2:/<span class="comment"># redis-cli --cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-from-user &lt;arg&gt;</span><br><span class="line">                 --cluster-from-pass &lt;arg&gt;</span><br><span class="line">                 --cluster-from-askpass</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br><span class="line"></span><br><span class="line">Cluster Manager Options:</span><br><span class="line">  --cluster-yes  Automatic <span class="built_in">yes</span> to cluster commands prompts</span><br><span class="line"></span><br><span class="line"><span class="comment">## 直接修复</span></span><br><span class="line">root@a77b8222eba2:/<span class="comment"># redis-cli --cluster fix --cluster-search-multiple-owners 127.0.0.1:6379</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Covering slot 694 with 192.168.88.3:6379</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> multiple slot owners...</span><br><span class="line">[OK] No multiple owners found.</span><br><span class="line">root@f3f2043dba55:/<span class="comment">#</span></span><br><span class="line">root@f3f2043dba55:/<span class="comment">#</span></span><br><span class="line">root@f3f2043dba55:/<span class="comment">#</span></span><br><span class="line">root@f3f2043dba55:/<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:6</span><br><span class="line">cluster_current_epoch:33</span><br><span class="line">cluster_my_epoch:30</span><br><span class="line">cluster_stats_messages_ping_sent:489</span><br><span class="line">cluster_stats_messages_pong_sent:523</span><br><span class="line">cluster_stats_messages_meet_sent:6</span><br><span class="line">cluster_stats_messages_sent:1018</span><br><span class="line">cluster_stats_messages_ping_received:523</span><br><span class="line">cluster_stats_messages_pong_received:495</span><br><span class="line">cluster_stats_messages_received:1018</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br><span class="line">root@f3f2043dba55:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis docker linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 一些操作命令记录</title>
    <url>/2021/01/30/gitlab%20%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<pre><code>  之前在上一家公司用的都是svn，现在使用gitlab。最近又在测试cicd，反复查询了一些命令，
  也敲了一些命令，自己也记录一下，持续更新。
</code></pre><p><img src="https://img-blog.csdnimg.cn/20210130141337117.png" alt="在这里插入图片描述"><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;addr&gt; 					// 拷贝远程仓库到本地</span><br><span class="line">git status							// 查看仓库当前的状态，显示有变更的文件（有的情况下文件增减看不到）</span><br><span class="line">git diff &lt;file&gt;						// 比较文件的不同，即暂存区和工作区的差异。</span><br><span class="line">git add .							// 添加文件到暂存区</span><br><span class="line">git add -f &lt;file&gt;					// 在文件增加没有提示时，手动添加文件</span><br><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span> 				// 将暂存区内容添加到仓库中</span><br><span class="line">git push origin &lt;branch&gt;			// 提交本地仓库到指定分支</span><br><span class="line">git pull origin &lt;branch&gt;			// 拉取远程分支更新本地仓库</span><br><span class="line">git tag &lt;v1.x.x&gt;					// 给本地打标签</span><br><span class="line">git tag -d &lt;v1.x.x&gt;		  			// 删除本地标签</span><br><span class="line">git push origin &lt;tag&gt; 				// 提交本地标签到远程仓库</span><br><span class="line">git push origin :refs/tags/&lt;tag&gt;	// 删除远程仓库tag</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>golang ”优雅关闭的 Go Web 服务器“，可能会碰到的坑。</title>
    <url>/2021/01/18/golang%20%E2%80%9D%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E7%9A%84%20Go%20Web%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%9C%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>          在最近的项目中，使用了go 搭建了web服务器，所以"优雅的关闭服务器"，经过查资料，发现go在1.8之后，http包已经有Shutdown()方法，但是使用起来还是有一些要注意的地方。</p>

<p>          如果对go很熟悉的，对这些包很熟悉的人，肯定不会碰到这个问题。只怪我太菜。。。碰到了坑。下面直接上代码。</p>

<p>          查询资料的时候，在网上看到这样的代码</p>

<pre>
<code class="language-Go">func gracefullShutdown(server *http.Server, logger *log.Logger, quit &lt;-chan os.Signal, done chan&lt;- bool) &#123;
  &lt;-quit
  logger.Println("Server is shutting down...")

  ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
  defer cancel()

  server.SetKeepAlivesEnabled(false)
  if err := server.Shutdown(ctx); err != nil &#123;
    logger.Fatalf("Could not gracefully shutdown the server: %v\n", err)
  &#125;
  close(done)
&#125;</code></pre>

<p>           像这种写法，是启动了别的goroutin去执行gracefullShoudown，所以需要额外的一个done channel来阻塞主线程。我们的http服务器必然会调用这个ListenAndServer(如下)，<strong>当调用了gracefullShutdown中server.Shutdown(ctx)，ListenAndServer会直接返回</strong>，而主线程直接结束了的话，别的线程也就会跟着一起结束。也就没有了等待服务器关闭这么一说法了。</p>

<pre>
<code class="language-Go">router := http.NewServeMux()
router.HandleFunc("/healthcheck", healthcheck)
port := fmt.Sprint(":8080")
srv := &amp;http.Server&#123;
    Addr:         port,
    Handler:      router,
&#125;

if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed &#123;
    logger.Error("[HTTP] server listen on", port, ", err:", err)
&#125;

</code></pre>

<h3><strong>       注意：server.ListenAndServe() 方法在 Shutdown 时会立刻返回，Shutdown 方法会阻塞至所有连接闲置或 context 完成，所以 Shutdown 的方法要写在主 goroutine 中或者。如果像上面一样使用在新的goroutine中，则需要自己写好阻塞主携程的方法。</strong></h3>

<p><strong> </strong></p>

<p><strong>最后附上完整使用新goroutine监听关闭服务器的demo：</strong></p>

<pre>
<code class="language-Go">package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func gracefullShutdown(server *http.Server, quit &lt;-chan os.Signal, done chan&lt;- bool) &#123;
    &lt;-quit
    // 30s，让服务器做一些清理操作
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    server.SetKeepAlivesEnabled(false)
    if err := server.Shutdown(ctx); err != nil &#123;
        fmt.Println("server.Shutdown err ..... ", err)
    &#125;
    //do Something ：
    fmt.Println("do something start ..... ", time.Now())
    time.Sleep(5 * time.Second)
    fmt.Println("do something end ..... ", time.Now())
    close(done)
&#125;

func main() &#123;
    var (
        done = make(chan bool, 1)
        quit = make(chan os.Signal, 1)
    )

    router := http.NewServeMux()
    port := fmt.Sprint(":36010")
    srv := &amp;http.Server&#123;
        Addr:    port,
        Handler: router,
    &#125;

    // 给信号挖个坑，如果抓到这些信号就退出程序
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    go gracefullShutdown(srv, quit, done)

    fmt.Println("[HTTP] http server listen", port)
    if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed &#123;
        fmt.Println("ListenAndServe err ..... ", err)
        os.Exit(1)
    &#125;
    &lt;-done
    fmt.Println("[HTTP] Showdown end")
&#125;
</code></pre>

<p><img alt height="159" src="https://img-blog.csdnimg.cn/20210118173824843.png" width="699"></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 使用time包碰到数字与时间相乘的问题</title>
    <url>/2021/01/25/golang%20%E4%BD%BF%E7%94%A8time%E5%8C%85%E7%A2%B0%E5%88%B0%E6%95%B0%E5%AD%97%E4%B8%8E%E6%97%B6%E9%97%B4%E7%9B%B8%E4%B9%98%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>       在项目中使用time包时，睡眠时间时想要通过配置文件获取，然而整数与时间相乘又报错。如下</p>

<p><img alt height="165" src="https://img-blog.csdnimg.cn/20210125204313549.png" width="988"></p>

<p>查询time包发现</p>

<pre>
<code class="language-Go">// A Duration represents the elapsed time between two instants
// as an int64 nanosecond count. The representation limits the
// largest representable duration to approximately 290 years.
type Duration int64</code></pre>

<p>即，其实就是一个int64的数。最后先把需要的数字进行转换，这样解决即可</p>

<pre>
<code class="language-Go">err = client.Set(ctx, key, data, time.Duration(ex)*time.Second).Err()</code></pre>

<p><img alt height="173" src="https://img-blog.csdnimg.cn/20210125204542483.png" width="694"></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 实际项目中连接redis集群碰到的坑</title>
    <url>/2021/01/26/golang%20%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9E%E6%8E%A5redis%E9%9B%86%E7%BE%A4%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<span id="more"></span>
<p>       项目中redis直接是使用了aws的redis服务，redis是集群，也就是golang连接redis集群碰到的坑，如下</p>

<p>       首先我使用的是redisgo，因为看着api比较方便，比较像redis-cli，而且aws也推荐。然后一开始连接也没事，我部署了不下10遍，然而有一天部署时。服务器在操作redis时忽然报错。“(error) MOVED xxxx xxx.xxx.xxx.xxx:xxxx”，经过查询得知这是由于redis没有选择连接集群导致的，再次查询，发现aws官方推荐了两个redis库，redisgo和go-redis两个库，<strong>redisgo是不支持集群的(太坑了)，而且我部署了那么多次都没问题。可能一直都连到master上了，</strong>忽然就连到slave就报错了。还好发现的早。</p>

<p>       go-redis/redis连接数据库的时候，官方的demo给的就是一堆端口，</p>

<pre>
<code class="language-Go">import "github.com/go-redis/redis/v8"

rdb := redis.NewClusterClient(&amp;redis.ClusterOptions&#123;
    Addrs: []string&#123;":7000", ":7001", ":7002", ":7003", ":7004", ":7005"&#125;,

    // To route commands by latency or randomly, enable one of the following.
    //RouteByLatency: true,
    //RouteRandomly: true,
&#125;)</code></pre>

<p>      这个是可以填好多地址的，只要把自己的地址填入string的切片即可，<strong>如果只有一个地址，就只填一个(项目中redis集群可能对外只暴露一个地址)</strong></p>

<pre>
<code class="language-Go">clusterClient = redis.NewClusterClient(&amp;redis.ClusterOptions&#123;
    Addrs: []string&#123;"your addr1"&#125;,
&#125;)</code></pre>

<p>      <strong>redis.NewClusterClient这个接口默认是连接master的，如果只想连接slave，则通过参数控制，具体查看接口的说明即可。</strong></p>

<p><strong>     </strong> 最后切换了包之后，成功解决了redis集群连接的问题。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang如何快速查询并发写map的位置(concurrent map iteration and map write)</title>
    <url>/2021/04/15/golang%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%8F%91%E5%86%99map%E7%9A%84%E4%BD%8D%E7%BD%AE(concurrent%20map%20iteration%20and%20map%20write)/</url>
    <content><![CDATA[<span id="more"></span>
<p>最近项目中高并发时碰到golang碰到了map并发读写的问题。<br>找问题找了好久，可以借助这个方发，编译的时候加上-race，在发生并发读写的地方会有提醒。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go -race</span><br></pre></td></tr></table></figure><br>会出现DATA RACE，这张图是网上找的，我也尝试过，图找不到了。借用网友的图。<br><img src="https://img-blog.csdnimg.cn/20210415194250384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是一个方法，使用这个也会有所缺陷，例如你的协程就不能开太多了，我记得好像只能开8000多个。而我开启了之后因为协程不够，并发不够又无法触发，最后是领导找到的。</p>
<p>最后我的原因是因为一般一个变量会定义在循环之外（这不是理所应当的么，当时写的时候没想那么多，而又是自己的思路，找了好久没找到），我在循环之外定义了变量，然后这个变量赋值的时候里面有map，导致了这个问题，最后把变量定义放在循环里就可以了。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang非阻塞读写channel</title>
    <url>/2021/07/23/golang%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%86%99channel/</url>
    <content><![CDATA[<span id="more"></span>
<p>服务器最近压测的时候发现了问题。发现是往channel写数据，但是channel满了，导致服务器部分功能阻塞。golang的channel读或写是会造成阻塞的，但是可以用select的多路复用解决这个问题。</p>
<p>不阻塞读channel（也可以加上超时）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num := &lt;-c:</span><br><span class="line">		<span class="keyword">return</span> num, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;chan do not have data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChanWithTimeout</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	timeout := time.NewTimer(time.Microsecond * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num := &lt;-c:</span><br><span class="line">		<span class="keyword">return</span> num , <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;read chan time out&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非阻塞写入channel（也可以加上超时）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(num <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ch &lt;- num:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;chan is full&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChanWithTimeout</span><span class="params">(num <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	timeout := time.NewTimer(time.Microsecond * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- num:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;write chan time out&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>iptable为什么之后pod的probability越来越大</title>
    <url>/2022/02/10/iptable%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%8B%E5%90%8Epod%E7%9A%84probability%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%A7/</url>
    <content><![CDATA[<span id="more"></span>
<p>项目集群是使用k8s管理的，流量分发使用的是iptable，据压测反馈说负载不均衡，吓得老夫赶紧去查看，发现原来是压测同学搞错了。在查询的过程中，发现iptable规则之后的probability越来越大，记录一下原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ip-10-1-34-89:/home/admin<span class="comment"># iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain KUBE-SVC-7XZINH2IMK6FHKPK (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">KUBE-SEP-TOX5PBICM2IS3QEP  all  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.20000000019</span><br><span class="line">KUBE-SEP-BHWNMZ5XNYG7AESG  all  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.25000000000</span><br><span class="line">KUBE-SEP-OQLKQS2OMOJTYZF6  all  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.33332999982</span><br><span class="line">KUBE-SEP-EQOKMESPFMECIZJJ  all  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.50000000000</span><br><span class="line">KUBE-SEP-GVLV4E5D2AGR4O5J  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，总共5条记录，刚开始probability为0.2—-&gt;0.25—-&gt;0.33—-&gt;0.5—-无，为什么会这样。<br>因为流量进入之后，按照iptable规则转发，公共5条，所以第一条接收20%的流量。<br>剩下还有4条，下一条应该接收剩余流量的1/4，也就是25%。<br>剩下还有3条，下一条应该接收剩余流量的1/3，也就是33%。<br>……<br>最后一条因为只剩下它了，所有流量都会走这里，所以不用写probability。</p>
]]></content>
      <categories>
        <category>Linux k8s</category>
      </categories>
      <tags>
        <tag>负载均衡 运维</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s中，启动pod失败，调试方法。</title>
    <url>/2020/12/21/k8s%E4%B8%AD%EF%BC%8C%E5%90%AF%E5%8A%A8pod%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>         在k8s中，是不能够直接启动容器的，容器必须要依附于pod的形式启动。当pod启动失败的时候，可以这么去调试。</p>

<p>        1.找到pod启动的镜像，将镜像进行二次封装，修改镜像的入口</p>

<pre>
<code>FROM xxxxx            //pod启动的镜像
ENTRYPOINT ["python", "-m", "SimpleHTTPServer", "8080"] //修改镜像的入口</code></pre>

<p>        2.将镜像上传到镜像库</p>

<p>        3.修改pod的yaml文件，修改镜像地址，修改探针</p>

<pre>
<code>containers:
    - name: containers_name
    image: image_path

//这里要注意要把levenesspoint给屏蔽了，要不会一直kill掉containers，然后重启</code></pre>

<p>        4.使用kubectl exec -it -n &lt;namespaces&gt;  &lt;podname&gt; /bin/sh进入到containers内部进行运行自己的代码，调试。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>kubernetes 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s中，怎么在container中切换角色</title>
    <url>/2020/12/21/k8s%E4%B8%AD%EF%BC%8C%E6%80%8E%E4%B9%88%E5%9C%A8container%E4%B8%AD%E5%88%87%E6%8D%A2%E8%A7%92%E8%89%B2/</url>
    <content><![CDATA[<span id="more"></span>
<p>    工作中，需要在k8s中调试container，但是container中有可能很多东西又没有，比如vim等，没有就无法修改代码，想使用su 更改为root用户又不知道密码。可以使用以下方法。</p>

<p>    直接修改pod的yaml文件</p>

<pre>
<code>containers:
  - name: ...
    image: ...
    securityContext:
      runAsUser: 0</code></pre>

<p>这样登录进去就是root角色，<strong>0指root用户的uid</strong>。在里面就可以安装自己想安装的工具进行调试。</p>

<p>比如我，进去调试之后安装了vim</p>

<pre>
<code>apt update
apt install vim</code></pre>

<p> </p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes cluster autoscale 不会删除nodes</title>
    <url>/2022/04/16/kubernetes%20cluster%20autoscale%20%E4%B8%8D%E4%BC%9A%E5%88%A0%E9%99%A4nodes/</url>
    <content><![CDATA[<span id="more"></span>
<p>项目上线后，通过<code>kubectl top</code> node，发现有的node上使用的资源非常少，<code>kubectl describe node</code> 发现完全可以驱逐。但是cluster autoscaler缺没有驱逐。</p>
<p>按照官方的说法<br><img src="https://img-blog.csdnimg.cn/a4b1a9d504e14982a6a3d10099797bbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>检查了node上的pod，没发现有什么pod满足以上。<br>查看cluster autoscaler的日志<br><img src="https://img-blog.csdnimg.cn/7cabdae5acf3437fb40eed34249bcf19.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>gitlab runner原来装在kube-system namespace下，最后把node上的gitlab runner删除，node即可被驱逐，猜测gitlab runner可能满足了以下导致。<br><img src="https://img-blog.csdnimg.cn/aaff910d278f47a2940968bf3a257dd0.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>linux grep/ag 匹配反斜杠“\“，记录一下这个有意思的问题</title>
    <url>/2021/06/10/linux%20grep!ag%20%E5%8C%B9%E9%85%8D%E5%8F%8D%E6%96%9C%E6%9D%A0%E2%80%9C!%E2%80%9C%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>今天项目中抓取日志的时候，因为日志打印出来的数据存是josn字符串，我要匹配的是这串<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\&quot;userId\&quot;:\&quot;867340f5-b992-4fe5-92cc-5390de659491\&quot;，</span><br></pre></td></tr></table></figure><br>按照经验，”和\是需要转换的，特殊字符串使用\做转换，”用\”转义，\用\\转换，在使用ag做匹配时这样写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> log1.txt | ag <span class="string">&quot;&#123;\\\&quot;userId\\\\\&quot;:\\\\\&quot;867340f5-b992-4fe5-92cc-5390de659491\\\&quot;,&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是却没有结果<br><img src="https://img-blog.csdnimg.cn/20210610165816778.png" alt="在这里插入图片描述"><br>经过尝试，发现原来\是需要使用\\来转义才可以匹配，多一个少一个都不行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> log1.txt | ag <span class="string">&quot;&#123;\\\\\&quot;userId\\\\\&quot;:\\\\\&quot;867340f5-b992-4fe5-92cc-5390de659491\\\\\&quot;,&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210610170429522.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>正则表达式 字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>linux top显示CPU占用高，Steal高</title>
    <url>/2021/12/26/linux%20top%E6%98%BE%E7%A4%BACPU%E5%8D%A0%E7%94%A8%E9%AB%98%EF%BC%8CSteal%E9%AB%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>开发这么久，第一次这种问题，记录一下。<br>在某天开发中，开发机的cpu忽然飙升，一直降不下来，刚开始没注意，一直删除cpu占用高的进程，一直无效，仔细看。top显示Steal高。<img src="https://img-blog.csdnimg.cn/b51ef36628bb49698905550605f2054c.png" alt="blog.csdnimg.cn/b5e3e319214548e19d47151304d9c346.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16)"><br>经过查询是因为宿主机出了问题，<a href="https://scoutapm.com/blog/understanding-cpu-steal-time-when-should-you-be-worried">详细说明看这里。</a><br>然后联系了运维，更换了宿主机，解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux 运维 服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 使用tcpdump抓包</title>
    <url>/2021/07/21/linux%20%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<span id="more"></span>
<p>最近更换了服务器的消息队列，客户端反馈说服务器有时候会多发消息下去，十分纳闷，只改了服务器的消息队列，但是服务器像客户端发消息的代码一行没改，日志也只是发一条消息下去，但是因为改了消息队列，最后使用linux抓包看看，以证清白。</p>
<p>tcpdump输出demo如下（这不是调试时的数据，只是demo）。这里我指定查看8060端口。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@mdev-2:/home/banfushen/webclient<span class="comment"># tcpdump port 8060</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">17:41:07.061086 IP 10.xxx.xxx.xxx.51321 &gt; 11.xxx.xxx.xxx.8060: Flags [.], <span class="built_in">seq</span> 2312385062:2312385063, ack 2244282406, win 1021, length 1</span><br><span class="line">17:41:07.061177 IP 11.xxx.xxx.xxx.8060 &gt; 10.xxx.xxx.xxx.51321: Flags [.], ack 1, win 101, options [nop,nop,sack 1 &#123;0:1&#125;], length 0</span><br></pre></td></tr></table></figure><br>抓包之后，发现的确只发下去一条，然后去抓客户端，在客户端打断点调试，最后发现是客户端自己的确收到一条，但是别的逻辑导致事件重复触发。最后证明清白。</p>
<p>tcpdump还有一些别的命令做一下记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听指定网卡</span></span><br><span class="line">tcpdump -i en0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听本机与192.xxx.xxx.xx之间的通信包，出\入都会监听</span></span><br><span class="line">tcpdump host 192.xxx.xxx.xx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听192.xxx.xxx.xx来源的通信</span></span><br><span class="line">tcpdump src host 192.xxx.xxx.xx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听192.xxx.xxx.xx为目标的通信</span></span><br><span class="line">tcpdump dst host 192.xxx.xxx.xx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听3000端口</span></span><br><span class="line">tcpdump port 3000</span><br></pre></td></tr></table></figure>
<p>tcpdump非常强大，还有一些更多的功能用到的时候再查询。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 磁盘IO满导致的宿主机卡机，pod失败(/kubepods/besteffort/pod4909103c-cdc)</title>
    <url>/2021/09/29/linux%20%E7%A3%81%E7%9B%98IO%E6%BB%A1%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%8D%A1%E6%9C%BA%EF%BC%8Cpod%E5%A4%B1%E8%B4%A5(!kubepods!besteffort!pod4909103c-cdc)/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>开发机上装了minikube，起了一个docker镜像当minikube的宿主机，在启动了一定量的deployment A之后，deployment A就全挂了（启动1~2个deployment A，没有问题，启动到第三个，就全挂）。然后宿主机卡爆。</p>
<h1 id="查询pod挂的原因"><a href="#查询pod挂的原因" class="headerlink" title="查询pod挂的原因"></a>查询pod挂的原因</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  Exit Code:    137</span><br><span class="line">      Started:      Wed, 29 Sep 2021 16:02:30 +0800</span><br><span class="line">      Finished:     Wed, 29 Sep 2021 16:04:19 +0800</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  12</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>看到了其中镜像挂了的返回值是137，此状态码一般是因为 pod 中容器内存达到了它的资源限制(resources.limits)，一般是内存溢出(OOM)，CPU达到限制只需要不分时间片给程序就可以。因为限制资源是通过 linux 的 cgroup 实现的，所以 cgroup 会将此容器强制杀掉，类似于 kill -9。<br>但是通过top查看发现cpu和内存都没满，但是内存交换满了（KiB Swap），感觉是因为宿主机没资源了，所以干掉pod中的资源，接着往下查，寻找更多node的信息。</p>
<p>因为minikube是起在docker中的，所以查看一下docker状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats</span><br><span class="line"></span><br><span class="line">94ec0f757f48        banfushen6_elasticsearch_1         1.24%               1.653GiB / 4.657GiB   35.49%              9.15GB / 6.79GB     85.3MB / 38.6GB     205</span><br><span class="line">a57d56927433        banfushen6_dynamodb_1              17.73%              329.7MiB / 31.42GiB   1.02%               223MB / 188MB       17MB / 12.3kB       86</span><br><span class="line">6aa3384e7433        banfushen6_mongooseim_1            0.02%               287.6MiB / 31.42GiB   0.89%               4.22MB / 0B         19.3MB / 1.03MB     27</span><br><span class="line">6f8203c6c8bd        banfushen6_rabbitmq_1              0.11%               98.38MiB / 31.42GiB   0.31%               4.22MB / 0B         19.9MB / 3.94MB     307</span><br><span class="line">722f40c6405f        minikube                           205.57%             7.398GiB / 7.812GiB   94.69%              441MB / 8.04MB      4.08MB / 48.1kB     2218</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这下，找到了pod失败的原因。接下来查找宿主机卡住的原因。</p>
<h1 id="查看node信息"><a href="#查看node信息" class="headerlink" title="查看node信息"></a>查看node信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe node minikube</span><br><span class="line">Name:               minikube</span><br><span class="line">Roles:              master</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    kubernetes.io/arch=amd64</span><br><span class="line">                    kubernetes.io/hostname=minikube</span><br><span class="line">                    kubernetes.io/os=linux</span><br><span class="line">                    minikube.k8s.io/commit=2c82918e2347188e21c4e44c8056fc80408bce10</span><br><span class="line">                    minikube.k8s.io/name=minikube</span><br><span class="line">                    minikube.k8s.io/updated_at=2021_07_20T17_14_34_0700</span><br><span class="line">                    minikube.k8s.io/version=v1.14.2</span><br><span class="line">                    node-role.kubernetes.io/master=</span><br><span class="line">Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock</span><br><span class="line">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class="line">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class="literal">true</span></span><br><span class="line">CreationTimestamp:  Tue, 20 Jul 2021 17:14:27 +0800</span><br><span class="line">Taints:             &lt;none&gt;</span><br><span class="line">Unschedulable:      <span class="literal">false</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----             ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  MemoryPressure   False   Wed, 29 Sep 2021 17:02:14 +0800   Wed, 29 Sep 2021 16:37:39 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure     False   Wed, 29 Sep 2021 17:02:14 +0800   Wed, 29 Sep 2021 16:37:39 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure      False   Wed, 29 Sep 2021 17:02:14 +0800   Wed, 29 Sep 2021 16:37:39 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready            True    Wed, 29 Sep 2021 17:02:14 +0800   Wed, 29 Sep 2021 16:57:04 +0800   KubeletReady                 kubelet is posting ready status</span><br></pre></td></tr></table></figure>
<p>看到了这句话kubelet has no disk pressure，在结合之前top的交换内存满了，判定磁盘的问题。通过公司的monitor查看到机器的磁盘io使用率已满。<br><img src="https://img-blog.csdnimg.cn/883d70f6cf0546e0b201a61923f999b0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="找出导致io爆炸的容器"><a href="#找出导致io爆炸的容器" class="headerlink" title="找出导致io爆炸的容器"></a>找出导致io爆炸的容器</h1><p>我先用了pidstat -d 1查看哪个进程对io的占用最高，但是缺没找到任何相关信息，然后直接在宿主机查看内核日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages | ag killed</span><br><span class="line"></span><br><span class="line">Sep 29 17:50:31 bfs kernel: [5618442.047786] Task <span class="keyword">in</span> /docker/722f40c6405f6933ac2722e40a40fef4c52e36b2ba0e44bdd1a8aba0027ca313/kubepods/besteffort/pod4909103c-cdc2-432e-92aa-2e06c2c7d1e3/9d62c1f82041c40d691498b2ded86caa663404489f7c3a62ad37c72eb2470911 killed as a result of <span class="built_in">limit</span> of /docker/722f40c6405f6933ac2722e40a40fef4c52e36b2ba0e44bdd1a8aba0027ca313</span><br></pre></td></tr></table></figure>
<p>可以看到，docker被内核干掉了，拿到docker的id前缀，去查找看是什么容器造成的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker@minikube:~$ docker ps | grep  e5bdaaef</span><br><span class="line">e5bdaaefff4a        7c797432e61c           <span class="string">&quot;/usr/local/bin/dock…&quot;</span>   11 minutes ago      Up 11 minutes                               k8s_elasticsearch</span><br></pre></td></tr></table></figure>
<p>发现，原来是pod中启动了es，多个es导致io炸裂，最后修改pod资源，不启动es，解决问题</p>
]]></content>
      <categories>
        <category>Linux k8s</category>
      </categories>
      <tags>
        <tag>linux docker elasticsearch kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用docker + docker compose 本地搭建redis cluster集群</title>
    <url>/2021/12/05/linux%E4%BD%BF%E7%94%A8docker%20+%20docker%20compose%20%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAredis%20cluster%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目用到一个redis库，对于里面的集群相关功能要自己测试（就像《代码简洁之道》中说的，使用第三方库需要自己有测试用例，这样即使第三方库更新了，直接用原来的测试用例，也知道是否能兼容）。所以需要自己本地搭建redis集群测试。</p>
<p><strong>搭建是使用docker搭建的，一下需要启动很多个container，所以使用docker-compose作为容器编排</strong>我的环境已经有了，没有的自己下载</p>
<h2 id="直接上redis-cluster模式"><a href="#直接上redis-cluster模式" class="headerlink" title="直接上redis-cluster模式"></a>直接上redis-cluster模式</h2><p>redis集群有三种模式：<strong>master+slave(主从)、sentinel(哨兵)、cluster(集群)</strong><br>我实际项目用的cluster模式，所以这里直接使用cluster模式。这个docker-compose.yml参考至<a href="https://blog.csdn.net/weixin_45444133/article/details/119642841">docker 部署 redis 的三种集群模式</a>，里面还有一些关于redis集群的说明，docker-compose.yml我亲自使用，没问题。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis-node-0:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-0</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-0:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis-node-1:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16380</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-1:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis-node-2:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16381</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-2:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.4</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis-node-3:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-3</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16382</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-3:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis-node-4:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-4</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16383</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-4:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis-node-5:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-node-5</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/redis-cluster:6.2</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">16384</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data-5:/bitnami/redis/data</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-node-0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-node-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-node-2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-node-3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-node-4</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDISCLI_AUTH=bfsbfs&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_CLUSTER_REPLICAS=1&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_NODES=redis-node-0 redis-node-1 redis-node-2 redis-node-3 redis-node-4 redis-node-5&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;REDIS_CLUSTER_CREATOR=yes&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">redis-cluster-network:</span> </span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.7</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">redis-cluster-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure><br>直接<code>docker-compose up -d</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在dockers-compose.yml目录</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">Creating network <span class="string">&quot;rediscluster_redis-cluster-network&quot;</span> with driver <span class="string">&quot;bridge&quot;</span></span><br><span class="line">Pulling redis-node-4 (docker.io/bitnami/redis-cluster:6.2)...</span><br><span class="line">6.2: Pulling from bitnami/redis-cluster</span><br><span class="line">1d7019cad1df: Pull complete</span><br><span class="line">0c20d9bbd5c0: Pull complete</span><br><span class="line">7434cc9f2f61: Pull complete</span><br><span class="line">01dd376516ef: Pull complete</span><br><span class="line">a10fc7cec580: Pull complete</span><br><span class="line">2e7c2cbaa852: Pull complete</span><br><span class="line">eef01af132bf: Pull complete</span><br><span class="line">234dbecfe19a: Pull complete</span><br><span class="line">Digest: sha256:57e9093dfaa412c691592e7e2ca6402a6f7d76b10cff04669fca4a82365f1874</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> bitnami/redis-cluster:6.2</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">Creating redis-node-2</span><br><span class="line">Creating redis-node-4</span><br><span class="line">Creating redis-node-0</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">Creating redis-node-3</span><br><span class="line">Creating redis-node-1</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">WARNING: Connection pool is full, discarding connection: localhost</span><br><span class="line">Creating redis-node-5</span><br></pre></td></tr></table></figure>
<p>测试完毕，停止redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在dockers-compose.yml目录</span></span><br><span class="line">docker-compose stop</span><br><span class="line">docker-compose <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis Linux</category>
      </categories>
      <tags>
        <tag>docker redis linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lua中的整除与取整数</title>
    <url>/2019/09/04/lua%E4%B8%AD%E7%9A%84%E6%95%B4%E9%99%A4%E4%B8%8E%E5%8F%96%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<p>        书籍是人类进步的阶梯，在没看lua程序设计第四版之前，并不知道lua有整除运算符，需要返回整除结果的时候，自己还得进行多余的运算，减去小数部分。前几天需求刚好需要用到整除和取一个浮点数的整数部分，运用之，作此记录。</p>

<p> </p>

<h1>整除</h1>

<p>lua中“<strong> / </strong>”代表除法，计算结果都是存在小数的。lua5.3后还提供了一个整除的运算符“<strong> // </strong>"。</p>

<p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/2019090419572156.png" width="617"></p>

<h1>取整数</h1>

<p>lua数学库提供了三个取整函数</p>

<p><strong>math.floor()，math.ceil()和math.modf()</strong></p>

<p>math.floor()向负无穷取整</p>

<p><img alt class="has" height="127" src="https://img-blog.csdnimg.cn/20190904200121599.png" width="546"></p>

<p>math.ceil()向正无穷取证</p>

<p><img alt class="has" height="106" src="https://img-blog.csdnimg.cn/20190904200225114.png" width="393"></p>

<p>modf向零取整(有两个返回值，返回整数与小数部分)</p>

<p><img alt class="has" height="103" src="https://img-blog.csdnimg.cn/20190904200327478.png" width="326"></p>

<p> </p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs aes192加密，在golang中解密碰到的坑</title>
    <url>/2021/01/25/nodejs%20aes192%E5%8A%A0%E5%AF%86%EF%BC%8C%E5%9C%A8golang%E4%B8%AD%E8%A7%A3%E5%AF%86%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<span id="more"></span>
<p>         最近改写服务器，集群中服务器是nodejs写的，把其中一个服务器改成golang写的，碰到了nodejs aes192加密，再golang中解密碰到的坑，如下。</p>

<p>         在nodejs中是这样加密的</p>

<pre>
<code class="language-javascript">const encrypt = (toEncrypt) =&gt; &#123;
    const cipher = crypto.createCipher('aes192', cryptoKey);
    let encrypted = cipher.update(toEncrypt, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  &#125;;</code></pre>

<p>发现golang中根本不知道aes192对应的到底是aes192中的那种加密模式，经过查询接口已经废弃</p>

<p><img alt height="218" src="https://img-blog.csdnimg.cn/20210125201828320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1029"></p>

<p>使用新的接口，原来的接口文档已经找不到了，刚开始顺着这个方法一直找，首先AES 有五种加密模式：电码本模式（Electronic Codebook Book (ECB)）、密码分组链接模式（Cipher Block Chaining (CBC)）、计算器模式（Counter (CTR)）、密码反馈模式（Cipher FeedBack (CFB)）和输出反馈模式（Output FeedBack (OFB)），要查到具体nodejs中使用的到底是哪个方法，<strong>查看新的接口说明，这里是重点一，通过接口说明，一步一步找出具体调用的是五个模式中的哪个</strong></p>

<p><img alt height="595" src="https://img-blog.csdnimg.cn/20210125202402933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>然后查看用的到底是什么，可以看到，用的是DES-192-CBC</p>

<p><img alt height="148" src="https://img-blog.csdnimg.cn/20210125202429309.png" width="673"></p>

<p>然后查看对应的golang的解密方法，发现，必须要给定密钥，和向量。而原来的nodejs接口，只需要给一个字符串就可以了，再次查询资料，最后在第三方的资料中，找到</p>

<p><strong>crypto.createCipher(algorithm, password)：用给定的算法和密钥，创建并返回一个Cipher加密算法的对象。参数：algorithm算法是依赖OpenSSL库支持的算法, 例如: 'aes192'算法等，password是用来派生key和iv的，它必须是一个 'binary'二进制格式的字符串或者是一个Buffer可以看到给定password参数，是用来生成key和iv的，具体怎么生成的，无从得知，或者说，要搞懂这个太麻烦了。</strong></p>

<p><strong>所以最后得出的结论是：nodejs使用原来的接口根本无法在golang中解密，所以必须修改nodejs的接口为新的接口。这里是重点二</strong></p>

<p>将nodejs的接口修改为</p>

<pre>
<code class="language-javascript">encrypt(toEncrypt) &#123;
        const cipher = crypto.createCipheriv('aes192', this.cryptoKey, this.cryptoVi);
        let encrypted = cipher.update(toEncrypt, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return encrypted;
    &#125;</code></pre>

<p>然后在golang中用同样的密钥和向量解密，这个解密方法不难，随便搜索即可找到。</p>

<pre>
<code class="language-Go">//对密文删除填充
func unPadDing(cipherText []byte) []byte &#123;
    //取出密文最后一个字节end
    end := cipherText[len(cipherText)-1]
    //删除填充
    cipherText = cipherText[:len(cipherText)-int(end)]
    return cipherText
&#125;

//AEC解密（CBC模式）
func aesCbcDecrypt(cipherText []byte) string &#123;
    //指定解密算法，返回一个AES算法的Block接口对象
    block, err := aes.NewCipher(cryp2Key)
    if err != nil &#123;
        panic(err)
    &#125;
    //指定分组模式，返回一个BlockMode接口对象
    blockMode := cipher.NewCBCDecrypter(block, iv)
    //解密
    plainText := make([]byte, len(cipherText))
    blockMode.CryptBlocks(plainText, cipherText)
    //删除填充
    plainText = unPadDing(plainText)

    return string(plainText)
&#125;
</code></pre>

<p>这样就可以成功解密了。</p>

<p> </p>

<p><strong>最后：最坑的就是nodejs的接口，找了好久都找不到解密方法，原来要用新接口，而且必须找到接口到底对应哪个加密方法才能在golang解密。</strong></p>

<p> </p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>perf对多线程Profile简单流程</title>
    <url>/2022/02/13/perf%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8BProfile%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Perf是用于软件性能分析的工具，通过Perf，应用程序可以利用PMU，tracepoint和内核中的特殊计数器进行性能统计。Perf不但可以分析应用程序的性能问题(per thread)，也可以分析内核的性能问题，处理所有性能相关的事件：程序运行期间的硬件事件，如instructions retired ，processor clock cycles等；软件事件，如Page Fault和进程切换。</p>
<p>Perf基本原理是对被监测对象进行采样，最简单的情形是根据tick中断进行采样，即在tick中断内触发采样点，在采样点里判断程序当前的上下文。假如一个程序90%的时间都花费在函数func1()上，那么90%的采样点都应该落在函数func1()的上下文中，采样时间越长，上述推论越可靠。<strong>使用perf要有管理员权限</strong></p>
<h2 id="使用perf对多线程进行profile"><a href="#使用perf对多线程进行profile" class="headerlink" title="使用perf对多线程进行profile"></a>使用perf对多线程进行profile</h2><h3 id="准备多线程程序"><a href="#准备多线程程序" class="headerlink" title="准备多线程程序"></a>准备多线程程序</h3><p>在此程序中，创建了两个线程。分别跑了不同次数的func1()方法。<code>gcc -lpthread main.c</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thread[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">10000</span>)</span><br><span class="line">        ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">10000</span>)</span><br><span class="line">        i = i*<span class="number">2</span>;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            func1();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            func2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;thread, <span class="number">0</span>, <span class="keyword">sizeof</span>(thread));</span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程1创建失败!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程1被创建\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程2创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程2被创建\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        thread_create();</span><br><span class="line">        pthread_join(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1加入&quot;</span>);</span><br><span class="line">        pthread_join(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2加入&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用perf对程序进行采样"><a href="#使用perf对程序进行采样" class="headerlink" title="使用perf对程序进行采样"></a>使用perf对程序进行采样</h3><h4 id="对还没启动的程序"><a href="#对还没启动的程序" class="headerlink" title="对还没启动的程序"></a>对还没启动的程序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ma100:/home/banfushen/perf_cpu/multi_thread# perf record -h</span><br><span class="line">Usage: perf record [&lt;options&gt;] [&lt;command&gt;]</span><br><span class="line">    or: perf record [&lt;options&gt;] -- &lt;command&gt; [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    -F, --freq &lt;n&gt;        profile at this frequency</span><br><span class="line">    -g                    enables call-graph recording</span><br><span class="line">    -p, --pid &lt;pid&gt;       record events on existing process id</span><br><span class="line">    -t, --tid &lt;tid&gt;       record events on existing thread id</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>perf record -g -F 99 ./a.out</code>，对多线程程序进行采样，采样频率99，(-F 99: sample at 99 Hertz (samples per second). I’ll sometimes sample faster than this (up to 999 Hertz), but that also costs overhead. 99 Hertz should be negligible. Also, the value ‘99’ and not ‘100’ is to avoid lockstep sampling, which can produce skewed results.)。运行完毕会得到一个<code>perf.data</code>，要想得到火焰图，还需要借助别的工具。</p>
<h4 id="对已经启动的程序"><a href="#对已经启动的程序" class="headerlink" title="对已经启动的程序"></a>对已经启动的程序</h4><p>对于已经启动的程序，要拿到pid，<code>perf record -g -F 99 -p &lt;pid&gt;</code></p>
<h3 id="下载工具FlameGraph"><a href="#下载工具FlameGraph" class="headerlink" title="下载工具FlameGraph"></a>下载工具FlameGraph</h3><p><code>git clone https://github.com/brendangregg/FlameGraph.git</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">banfushen@ma100:~/perf_cpu/FlameGraph$ pwd</span><br><span class="line">/home/banfushen/perf_cpu/FlameGraph</span><br></pre></td></tr></table></figure></p>
<h3 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h3><h4 id="对perf-data生成火焰图-按照上面来说就是一个进程的"><a href="#对perf-data生成火焰图-按照上面来说就是一个进程的" class="headerlink" title="对perf.data生成火焰图(按照上面来说就是一个进程的)"></a>对perf.data生成火焰图(按照上面来说就是一个进程的)</h4><p><code>perf script |/home/banfushen/perf_cpu/FlameGraph/stackcollapse-perf.pl|/home/banfushen/perf_cpu/FlameGraph/flamegraph.pl &gt; output.svg</code><br><img src="https://img-blog.csdnimg.cn/cedfefcf300a468b9c32fc84ffc19bfb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-68Nci8QI-1644756192593)(_v_images/20211214172626556_19376.png)\]"></p>
<h4 id="对单个线程生成火焰图"><a href="#对单个线程生成火焰图" class="headerlink" title="对单个线程生成火焰图"></a>对单个线程生成火焰图</h4><p>要知道线程id<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ma100:/home/banfushen/perf_cpu/multi_thread# perf script -h</span><br><span class="line"></span><br><span class="line"> Usage: perf script [&lt;options&gt;]</span><br><span class="line">    or: perf script [&lt;options&gt;] record &lt;script&gt; [&lt;record-options&gt;] &lt;command&gt;</span><br><span class="line">    or: perf script [&lt;options&gt;] report &lt;script&gt; [script-args]</span><br><span class="line">    or: perf script [&lt;options&gt;] &lt;script&gt; [&lt;record-options&gt;] &lt;command&gt;</span><br><span class="line">    or: perf script [&lt;options&gt;] &lt;top-script&gt; [script-args]</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    -v, --verbose         be more verbose (show symbol address, etc)</span><br><span class="line">        --pid &lt;pid[,pid...]&gt;</span><br><span class="line">        --tid &lt;tid[,tid...]&gt;</span><br><span class="line">                          only consider symbols in these tids</span><br></pre></td></tr></table></figure><br><code>perf script -v --tid &lt;tid&gt; 指定线程</code><br><code>perf script -v --tid 2283471|/home/banfushen/perf_cpu/FlameGraph/stackcollapse-perf.pl|/home/banfushen/perf_cpu/FlameGraph/flamegraph.pl &gt; output1.svg</code><br><img src="https://img-blog.csdnimg.cn/db320151507f4c3a8ecb2e5258e0e704.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UAKuRRSC-1644756192594)(_v_images/20211214172949738_20703.png)\]"></p>
<h4 id="对多个线程生成火焰图"><a href="#对多个线程生成火焰图" class="headerlink" title="对多个线程生成火焰图"></a>对多个线程生成火焰图</h4><p><code>perf script -v --tid &lt;tid[,tid...]&gt; 指定多个线程</code><br><code>perf script -v --tid 2283472,2283471|/home/banfushen/perf_cpu/FlameGraph/stackcollapse-perf.pl|/home/banfushen/perf_cpu/FlameGraph/flamegraph.pl &gt; output3.svg</code><br><img src="https://img-blog.csdnimg.cn/6fbc37032b3c4efba64387ab5f115c22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFuRlM=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-y7qrS028-1644756192595)(_v_images/20211214173120899_8466.png)\]"><br>参考资料:<br><a href="https://www.brendangregg.com/perf.html">perf Examples</a><br><a href="https://melonshell.github.io/2019/10/09/tool1_perf/">perf性能分析</a><br><a href="http://walkerdu.com/2018/09/13/perf-event/">性能分析利器之perf浅析</a><br><a href="https://blog.gmem.cc/perf">利用perf剖析Linux应用程序</a><br><a href="https://segmentfault.com/a/1190000021465563">Linux性能分析工具Perf简介</a></p>
]]></content>
      <categories>
        <category>Linux 性能优化</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis (error) MOVED 11863 xxx.xxx.xxx.xxx:6379</title>
    <url>/2021/04/15/redis%20(error)%20MOVED%2011863%20xxx.xxx.xxx.xxx!6379/</url>
    <content><![CDATA[<span id="more"></span>
<p>最近在集群中查询redis碰到这个问题，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(error) MOVED 11863 xxx.xxx.xxx.xxx:6379</span><br></pre></td></tr></table></figure>
<p>简单查询后发现，是因为redis是集群方式的，而使用redis-cli连接redis的时候，没有指定集群模式，指定后即可。</p>
<p>这样指定即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -h xxx.xxx.xxx -p 6379 -c</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis cluster 查看各个节点的slot</title>
    <url>/2022/02/10/redis%20cluster%20%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84slot/</url>
    <content><![CDATA[<span id="more"></span>
<p><code>redis-cli -p xxxx -c cluster nodes</code></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis cluster使用lua脚本的坑，非同一个slot也可以使用lua脚本</title>
    <url>/2022/02/10/redis%20cluster%E4%BD%BF%E7%94%A8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%9D%91%EF%BC%8C%E9%9D%9E%E5%90%8C%E4%B8%80%E4%B8%AAslot%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<span id="more"></span>
<p>在项目中，需要用lua脚本操作redis cluster中的多个key，但是非同slot的时候会报错，例如下面test3、test6在同一个node，但是却不是同一个slot。redis使用lua脚本可以这样<code>redis-cli -a xxxxx--eval demo.lua key1 key2 , val1 val2</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@ma100:~/redis-cluster$ redis-cli -p 16380 -c</span><br><span class="line">192.168.88.7:6379&gt; <span class="built_in">set</span> test3 3333</span><br><span class="line">-&gt; Redirected to slot [13026] located at 192.168.88.3:6379</span><br><span class="line">OK</span><br><span class="line">192.168.88.6:6379&gt; <span class="built_in">set</span> test5 3333</span><br><span class="line">-&gt; Redirected to slot [4644] located at 192.168.88.5:6379</span><br><span class="line">OK</span><br><span class="line">192.168.88.5:6379&gt; <span class="built_in">set</span> test6 3333</span><br><span class="line">-&gt; Redirected to slot [8775] located at 192.168.88.3:6379</span><br><span class="line">OK</span><br><span class="line">192.168.88.3:6379&gt; cluster keyslot test3</span><br><span class="line">(<span class="built_in">integer</span>) 13026</span><br><span class="line">192.168.88.3:6379&gt; cluster keyslot test6</span><br><span class="line">(<span class="built_in">integer</span>) 8775</span><br><span class="line">192.168.88.3:6379&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="通过key传入"><a href="#通过key传入" class="headerlink" title="通过key传入"></a>通过key传入</h1><p>一般在redis cluster中使用lua脚本，会碰到<code>(error) CROSSSLOT Keys in request don&#39;t hash to the same slot</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@ma100:~/test$ <span class="built_in">cat</span> get.lua</span><br><span class="line"><span class="built_in">local</span> key1 = KEYS[1]</span><br><span class="line"><span class="built_in">local</span> key1 = KEYS[2]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> value1 = redis.call(<span class="string">&quot;GET&quot;</span>, key1)</span><br><span class="line"><span class="built_in">local</span> value2 = redis.call(<span class="string">&quot;GET&quot;</span>, key2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;value1, value2&#125;</span><br><span class="line">banfushen@ma100:~/test$  redis-cli -p 16380 -c --<span class="built_in">eval</span> get.lua test3 test6</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don<span class="string">&#x27;t hash to the same slot</span></span><br></pre></td></tr></table></figure></p>
<h1 id="通过value传入"><a href="#通过value传入" class="headerlink" title="通过value传入"></a>通过value传入</h1><p>在官方的说明中，redis 使用lua脚本是限制在用一个node上使用的，可是这里明明是同一个node，却无法使用，但是如果我们把脚本改成下面这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@ma100:~/test$ <span class="built_in">cat</span> get.lua</span><br><span class="line"><span class="built_in">local</span> key1 = ARGV[1]</span><br><span class="line"><span class="built_in">local</span> key2 = ARGV[2]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> value1 = redis.call(<span class="string">&quot;GET&quot;</span>, key1)</span><br><span class="line"><span class="built_in">local</span> value2 = redis.call(<span class="string">&quot;GET&quot;</span>, key2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;value1, value2&#125;</span><br><span class="line">banfushen@ma100:~/test$ redis-cli -p 16380 -c --<span class="built_in">eval</span> get.lua  , test6 test3</span><br><span class="line">1) <span class="string">&quot;3333&quot;</span></span><br><span class="line">2) <span class="string">&quot;3333&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样即可解决。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>应该是按照KEY传入的时候，redis为了防止key不在同一个node上，对key进行slot判断，如果不是同一个slot就直接返回了，但是是支持同一个node的，<strong>只要我们对我们需要操作的key进行分类，同一个node的key通过value传入，即可在lua脚本中对同一个node的key操作。</strong>在我们设计redis cluster的时候，是知道每个node的slot的，每个key的solt可以使用以下计算<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.88.3:6379&gt; cluster keyslot test3</span><br><span class="line">(<span class="built_in">integer</span>) 13026</span><br></pre></td></tr></table></figure><br>我们只需要先判断slot在某个范围内，属于一个node，即可进行批量操作。</p>
]]></content>
      <categories>
        <category>lua redis</category>
      </categories>
      <tags>
        <tag>lua redis 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis list插入失败，服务器与redis调试过程记录（redis连接列表，redis日志，redis监视着模式）。</title>
    <url>/2021/07/20/redis%20list%E6%8F%92%E5%85%A5%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Eredis%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%88redis%E8%BF%9E%E6%8E%A5%E5%88%97%E8%A1%A8%EF%BC%8Credis%E6%97%A5%E5%BF%97%EF%BC%8Credis%E7%9B%91%E8%A7%86%E7%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%89%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>前段时间在项目中碰到一个redis list插不进去的问题。背景是使用了redis list做消息队列，有两个服务器，server1存贮的redis string 类型的key的value是服务器1自己的mq1，server2要将消息插入server1的mq1。然后server1在读出这个mq1中存贮的消息。再去做一些业务操作。server1对mq1采用的是brpop，也就是阻塞的拿消息。</p>
<p>下面将mq这个redis list的key成为mq1。</p>
<p>我碰到了一个很奇葩的问题，server2从redis中读出了mq1，然后往mq1插入也没有报错。但是server1对mq1进行brpop一直拿不到消息。很是纳闷。甚至一度以为redis除了问题。下面进入艰难的调试过程。</p>
<h1 id="先查看redis有多少连接"><a href="#先查看redis有多少连接" class="headerlink" title="先查看redis有多少连接"></a>先查看redis有多少连接</h1><p>因为无论哪个server，对redis来说都是client进行操作，就想查看redis的连接。是会不会有别的server和我pop了同一个list，可以用client list命令查看。下面的输出是举例，调试时的输出已经过去太久找不到了。例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6006&gt; client list</span><br><span class="line"><span class="built_in">id</span>=381 addr=192.xxx.xx.x:27804 fd=15 name= age=1367 idle=36 flags=b db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=brpop</span><br><span class="line"><span class="built_in">id</span>=385 addr=192.xxx.xx.x:52192 fd=10 name= age=8 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line"><span class="built_in">id</span>=378 addr=192.xxx.xx.x:27316 fd=12 name= age=1367 idle=254 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get</span><br><span class="line"><span class="built_in">id</span>=382 addr=192.xxx.xx.x:27820 fd=16 name= age=1367 idle=33 flags=b db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=brpop</span><br><span class="line"><span class="built_in">id</span>=379 addr=192.xxx.xx.x:27328 fd=13 name= age=1367 idle=1367 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=info</span><br><span class="line"><span class="built_in">id</span>=380 addr=192.xxx.xx.x:27334 fd=14 name= age=1367 idle=1212 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=<span class="built_in">exec</span></span><br><span class="line"><span class="built_in">id</span>=10 addr=192.168.96.5:51404 fd=9 name= age=950692 idle=950692 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span><br><span class="line"><span class="built_in">id</span>=9 addr=192.168.96.5:51402 fd=8 name= age=950692 idle=950692 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=info</span><br></pre></td></tr></table></figure><br>在我查看之后，发现的确时一个lpush，一个pop都没有。（这些输出参数都有意义，感兴趣可以自己查一下）</p>
<h1 id="查redis日志"><a href="#查redis日志" class="headerlink" title="查redis日志"></a>查redis日志</h1><p>每个服务器对于redis来说都是client，如果能查日志就好了，经过查询资料，可以用以下方式查日志。这个方式一般来说是用来查询慢查询的日志，但是可以设置，把慢查询的日志设置为0，既可以获取所有日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">log</span>的时间阀值(微秒，一毫秒等于1000微秒)，大于该数字的语句才会记录。负数表示不记录，0记录所有的。</span></span><br><span class="line">`config get slowlog-log-slower-than`  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置<span class="built_in">log</span>的时间阀值为0毫秒</span></span><br><span class="line">`config set slowlog-log-slower-than 0`  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">log</span>的最大条数。大于该数字，旧的会被丢弃。</span></span><br><span class="line">`config get slowlog-max-len`  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置<span class="built_in">log</span>的最大条数为300</span></span><br><span class="line">`config set slowlog-max-len 300`  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取最近20条日志</span></span><br><span class="line">`slowlog get 20`  </span><br></pre></td></tr></table></figure>
<p>在获取了日志之后，也没发现什么问题，server2的确插入了（这里的输出也是demo，调试输出找不到了）。而且并没有pop，这就奇怪了，难道有什么阻塞了么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6006&gt; slowlog get 20</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 2</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1626785061</span><br><span class="line">   3) (<span class="built_in">integer</span>) 16357</span><br><span class="line">   4) 1) <span class="string">&quot;lpush&quot;</span></span><br><span class="line">      2) <span class="string">&quot;game&quot;</span></span><br><span class="line">      3) <span class="string">&quot;&#123;\&quot;msg\&quot;:&#123;\&quot;data\&quot;:&#123;\&quot;playerName\&quot;:\&quot;bfs\&quot;,\&quot;msg\&quot;:\&quot;\xe6\xb6\x88\xe6\x81\xaf\xe4\xbd\x938\&quot;,\&quot;playerId\&quot;:\&quot;832a3d73-317c-4a39-8df8-c2fd8965a1b3\&quot;,\&quot;timestamp\&quot;:162380889111... (185 more bytes)&quot;</span></span><br><span class="line">   5) <span class="string">&quot;192.xxx.xx.x:27334&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="进入redis监视着模式"><a href="#进入redis监视着模式" class="headerlink" title="进入redis监视着模式"></a>进入redis监视着模式</h1><p>最后尝试了进入reids monitor，这个模式下可以动态观看日志。输入类似这样，所有的无所遁形。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6006&gt; monitor</span><br><span class="line">OK</span><br><span class="line">1626787232.810556 [0 192.xxx.xx.x:27316] <span class="string">&quot;get&quot;</span> <span class="string">&quot;AuthToken-747b1041-7390-4d85-bcc2-a9f2221ce52d&quot;</span></span><br><span class="line">1626787232.831783 [0 192.xxx.xx.x:27316] <span class="string">&quot;setex&quot;</span> <span class="string">&quot;AuthToken-747b1041-7390-4d85-bcc2-a9f2221ce52d&quot;</span> <span class="string">&quot;1800&quot;</span> <span class="string">&quot;&#123;\&quot;tokenId\&quot;:\&quot;747b1041-7390-4d85-bcc2-a9f2221ce52d\&quot;,\&quot;generated\&quot;:1626783720,\&quot;userId\&quot;:\&quot;832a3d73-317c-4a39-8df8-c2fd8965a1b3\&quot;,\&quot;expire\&quot;:1784463720&#125;&quot;</span></span><br></pre></td></tr></table></figure><br>进入这个monitor之后，发现的确也是发现server2的确插入了，但是server1就是没能brpop出消息，就在人发呆之际，发现server1 brpop的key和server2插入的key不一样。server1 brpop的key是直接写死的mq1，然是server1在存贮mq1的时候进行了json化，导致server2拿到的mq1是\“mq1\”，所以一直插错了。。。</p>
<p>最后是自己坑了自己，但是是一个有节奏的调试过程，做记录。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 怎么查询一个key有多大</title>
    <url>/2022/01/09/redis%20%E6%80%8E%E4%B9%88%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AAkey%E6%9C%89%E5%A4%9A%E5%A4%A7/</url>
    <content><![CDATA[<span id="more"></span>
<p>在项目开发过程中，最好是能估计出自己开发的功能要使用多大的redis内存</p>
<h1 id="使用redis自带的方法"><a href="#使用redis自带的方法" class="headerlink" title="使用redis自带的方法"></a>使用redis自带的方法</h1><h2 id="debug-object-key"><a href="#debug-object-key" class="headerlink" title="debug object key"></a>debug object key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6006&gt; get testkey</span><br><span class="line"><span class="string">&quot;this is a test&quot;</span></span><br><span class="line">127.0.0.1:6006&gt; debug object testkey</span><br><span class="line">Value at:0x7f4f19e2b500 refcount:1 encoding:embstr serializedlength:15 lru:14327341 lru_seconds_idle:6</span><br></pre></td></tr></table></figure>
<ul>
<li>Value at: 内存地址</li>
<li>refcount: 引用次数</li>
<li>encoding: 编码类型</li>
<li>serializedlength: 序列化后的长度（注意这里的长度是序列化后的长度，保存为rdb文件时使用了该算法，不是真正存贮在内存的大小，不过可以用于比较）<h2 id="memory-usage"><a href="#memory-usage" class="headerlink" title="memory usage"></a>memory usage</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6006&gt; memory usage queuesSet</span><br><span class="line">(<span class="built_in">integer</span>) 1489075554</span><br></pre></td></tr></table></figure>
返回字节数</li>
</ul>
<h1 id="借助工具"><a href="#借助工具" class="headerlink" title="借助工具"></a>借助工具</h1><p>借助redis rdb tools工具，需要下载rdbtools，<code>pip install rdbtools</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@banfushen:~$ redis-memory-for-key -p 6006 testkey</span><br><span class="line">Key                             testkey</span><br><span class="line">Bytes                           72</span><br><span class="line">Type                            string</span><br></pre></td></tr></table></figure>
<h1 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">h = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">p = <span class="number">6006</span></span><br><span class="line"></span><br><span class="line">rd = redis.Redis(host=h, port=p, decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(rd.<span class="built_in">type</span>(<span class="string">&#x27;testkey&#x27;</span>), rd.strlen(<span class="string">&#x27;testkey&#x27;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@banfushen:~/gitlab/dbsync/test$ python redis_size.py </span><br><span class="line">(u<span class="string">&#x27;string&#x27;</span>, 14)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 执行lua脚本实际项目的应用。</title>
    <url>/2020/07/13/redis%20%E6%89%A7%E8%A1%8Clua%E8%84%9A%E6%9C%AC%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>       写博客还是习惯先写一下，写下这篇博客的原因。前几天撸的博客《使用redis做排行榜相同积分情况下，如何使用到达时间来排序》，我使用了这个方法修改了原来写的排行榜，之前的排行榜我是没有这样做。修改之后，需要运营先暂停排行榜，将之前排行榜的分数记录，发奖之后再开启新的排行榜。但是策划最后说我忘记了，周四更新之后，导致旧方法记录的分数存在，同时新方法也在记录分数，排行榜就乱了，只能临时暂停排行榜，等我修复后再开启。</p>

<p>       混乱的原因是redis中记录的分数，旧分数是实际分数，新分数为 score&lt;&lt;26 + time。这样新进排行榜的玩家就算是只得1分，也会比之前第一名的玩家分数高，这样旧乱套了。修复的方法就是修改redis中旧分数，用旧分数&lt;&lt;26 + time，写个lua脚本直接让redis运行即可。</p>

<p>       redis执行lua有两种方法：</p>

<p>  <strong>     1.连接redis后，在命令行输入一串字符串，这串字符串是按照一定规则连接起来的lua字符串，这种方法我没有深入研究，大概如下：</strong>       <img alt height="114" src="https://img-blog.csdnimg.cn/2020071309025779.png" width="1153"></p>

<p><strong>       2.将要执行的lua脚本写成一个文件，直接运行，我用的是第二种方法，也比较推荐第二种方法，第二种方法自己写的清楚，看的清楚，而且执行方便。</strong></p>

<p><strong>     </strong>  lua_2_redis.lua如下<strong>：</strong></p>

<p><strong>      </strong><img alt height="345" src="https://img-blog.csdnimg.cn/20200713090531602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="749"></p>

<p>      执行方法如下：</p>

<p><strong>      redis-cli -h 127.0.0.1 -p 36001 -a xxxxxxx --eval lua_2_redis.lua &gt;&gt; ret.txt</strong></p>

<p>      在脚本中写return，则会把自己想要的结果返回，我这里使用了 &gt;&gt;ret.txt是做了重定向，把输出保存到ret.txt文件。执行结果可以看到redis中对应的分数已经被改变：</p>

<p><img alt height="116" src="https://img-blog.csdnimg.cn/20200713090931323.png" width="1082"></p>

<p><strong>      </strong>输出的文件ret.txt：</p>

<p><img alt height="158" src="https://img-blog.csdnimg.cn/20200713091022111.png" width="371"></p>

<p><strong>注意：因为redis中支持lua只是辅助，所以lua中有些方法是不支持的，例如os.time()、也不支持位操作。所以我上面时间直接写死了个计算后的时间。位操作用乘法代替。不支持的方法需要自己另外想办法解决了。</strong></p>

<p> </p>

<p><strong>最后有个感悟，在项目中碰到问题不要怕，代码都是人写的，总会有解决方法。</strong></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        <category>lua redis</category>
      </categories>
      <tags>
        <tag>redis lua</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群数据倾斜查询过程</title>
    <url>/2021/07/23/redis%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>
<p>项目上redis cluster数据产生了倾斜，项目是有3个节点，但第一个节点用了80%的内存，第二第三个节点基本没存数据。</p>
<h1 id="redis-cluster存贮规律"><a href="#redis-cluster存贮规律" class="headerlink" title="redis cluster存贮规律"></a>redis cluster存贮规律</h1><p>redis 集群有16384个槽，会先对要存贮的key进行hash，将得到的结果放到对应的槽。一般会对整个key进行hash，如果key中含有{}，会对{}中的字符串进行哈希。</p>
<h1 id="先查看集群中是否是因为key的原因造成倾斜"><a href="#先查看集群中是否是因为key的原因造成倾斜" class="headerlink" title="先查看集群中是否是因为key的原因造成倾斜"></a>先查看集群中是否是因为key的原因造成倾斜</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h xxx.xxx.xxx.xxx -p xxx -c</span><br><span class="line">keys *&#123;*&#125;*</span><br></pre></td></tr></table></figure>
<p>查看之后发现，并不是因为{}导致key全部塞到第一个节点，说明应该不是key的原因</p>
<h1 id="查找集群中的大key"><a href="#查找集群中的大key" class="headerlink" title="查找集群中的大key"></a>查找集群中的大key</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h xxx.xxx.xxx.xxx -p xxx -c --bigkeys</span><br><span class="line">redis-memory-for-key -s xxx.xxx.xxx.xxx -p xxx keyname</span><br></pre></td></tr></table></figure>
<p>这里有一点需要注意，bigkeys命令会再各个节点中遍历，一个节点一个节点的插，所以要多执行几遍。最后发现有一个list里面有3W多个数据，查看大小，就是这个原因导致的，最后再查询代码，发现是业务代码问题，解决即可。<br>redis-memory-for-key也可能没连接到指定节点，需要多执行几次。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>skynet踩坑记录(一)客户端连接之watchdog gate agent复杂错乱关系。</title>
    <url>/2019/08/19/skynet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95(%E4%B8%80)%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E4%B9%8Bwatchdog%20gate%20agent%E5%A4%8D%E6%9D%82%E9%94%99%E4%B9%B1%E5%85%B3%E7%B3%BB%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>        笔者转行做游戏服务器开发有四个月了，现在公司用的是skynet框架，由于之前没做过服务器开发，现在还是处于边学习，边跟项目的情况。由于工作原因，网络这一块断断续续看了两个星期，一直没理解，今天再看的时候，终于懂了skynet监听网络端口的流程，也懂了，客户端是怎么连接的。果然应了那句话：<strong>欠了技术债，早晚要还的。（学习一定要专注啊！！！可以省好多时间。）</strong></p>

<p><strong>       </strong>这张图是在网上找的，非常的清晰，要顺着标识看，并结合代码，就能大致了解这个过程。<img alt class="has" height="652" src="https://img-blog.csdnimg.cn/20190819195844523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1083"></p>

<p><span style="color:#333333;">1.在main中会newservice watchdog</span><span style="color:#333333;">启动看门狗服务，</span><span style="color:#333333;">lua start conf</span><span style="color:#333333;">给看门狗发送</span><span style="color:#333333;">lua</span><span style="color:#333333;">消息</span><span style="color:#333333;">start</span><span style="color:#333333;">参数为</span><span style="color:#333333;">conf</span><span style="color:#333333;">。</span></p>

<p><span style="color:#333333;">2.在watchdog服务中会，newservice gate启动网关服务(实际上是通过gateserver.start启动)，然后监听传入或者默认的端口。</span></p>

<p><span style="color:#333333;">3.当有新连接接入的时候，实际上是gate server监听到的。</span></p>

<p><span style="color:#333333;">4.gate server send2watchdog open，并传入参数。</span></p>

<p><span style="color:#333333;">5.在watchdog server中会创建一个agent(每个连接接入，创建一个agent)，并传入相关的信息(gate，fd，watchdog)。</span></p>

<p><span style="color:#333333;">6.由于有watchdog传入的信息，agent可以call2gate server forward(用于打开fd，一定要打开，链接成功不代表马上可以读到数据，需要打开这个套接字，允许fd接收数据，这样才能接受到client传入的数据)。</span></p>

<p><span style="color:#333333;">7.当client send requste，首先到达gate。</span></p>

<p><span style="color:#333333;">8.gate server 的</span><span style="color:#333333;">message方法中处理，转发给agent。</span></p>

<p><span style="color:#333333;">9.agent处理之后，在发回给client。</span></p>

<p> </p>

<p><span style="color:#333333;">需要注意的是：</span></p>

<p><span style="color:#333333;">1.实际上client连接到的是gate server。</span></p>

<p><span style="color:#333333;">2.gate server把具体的client消息转发给agent由agent处理具体逻辑。</span></p>

<p><span style="color:#333333;">3.gate 与 watchdog 与 agent是相互配合的。</span></p>

<p> </p>

<p><span style="color:#333333;">至于为什么要这么做，目前我也不是很清楚。。。</span></p>

<p> </p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>skynet 网络模块</tag>
      </tags>
  </entry>
  <entry>
    <title>skynet踩坑记录（三）skynet.call的挂起实际中可能造成的后果。</title>
    <url>/2020/09/18/skynet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89skynet.call%E7%9A%84%E6%8C%82%E8%B5%B7%E5%AE%9E%E9%99%85%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E7%9A%84%E5%90%8E%E6%9E%9C%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>       在刚开始使用skynet的时候，就已经知道call方法会挂起。但是一直到今天，都无法深刻理解这个挂起的意思。直到碰到了这个问题。解决后做此记录。</p>

<p>       1.先描述一下出现的情况。</p>

<p>        <img alt height="309" src="https://img-blog.csdnimg.cn/20200918162401369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="993"></p>

<p>       先暂且不管为什么要对db进行这么多次操作（原因太多）。在这个需求下，我本是想执行顺序为 1234，但是实际上确时1324。这会导致3拿到的是2更新之前的数据。今日参加次数就会在执行4的时候，没有能更新到2更新的内容。</p>

<p>       2.为什么会出现这样的情况呢。</p>

<p>       首先要了解 lua协程。<strong>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</strong>一般使用协程的时候，因为cpu的性能问题，会让我们感觉和多线程差不多。但是重点就是，同一时刻，只有一个协程在运行，而且在他让出cpu的时候，cpu才回去处理别的协程。</p>

<p>       在上面的情况下，就是因为在步骤1的时候，调用了skynet.call。这个东西会挂起协程，也就是让出cpu。然后cpu就是处理了下面的协程，所以先调用了3。</p>

<p>       3.怎么处理</p>

<p>       有两个方法：a.修改业务，将这两个增加写到一起。</p>

<p>                            b.使用消息队列，skynet.queue。(代码很简单，就几行，即处理完当前协程的方法再调用下一个协程的方法)（云风前辈在blog也写过，skynet.queue，就是用来处理这了多协程，又要保证次序的问题。）</p>

<p>       4.处理的注意事项，使用skynet.queue的时候，一定要确保丢进队列的顺序是1234，我自己就因为没有能很好的理解call的挂起，让上面两个协程分别把方法丢到队列里（再次踩坑，加深理解），最后丢进去的顺序又是1324。。。。查了好久，才找到。再次提醒，<strong>skynet.call会挂起协程。</strong>其实再很多游戏业务中，也会有这种场景，需要多注意。（如果是关于重要数据的修改，麻烦就大了，例如金币变动等）</p>

<p>       5.虽然从技术上也解决了，但是最后我是修改了逻辑，将两个方法写成一个。没必要进行四次DB操作。但是这次的确也加深了我对协程挂起的理解。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>skynet踩坑记录（二）agent引用代码模块。</title>
    <url>/2019/07/28/skynet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89agent%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>       前几天，在写游戏逻辑时，需要在不同的代码块中引用我写的逻辑模块（以下简称C模块）来对玩家数据进行修改。由于对skynet理解不够，多模块中调用自己写的逻辑时，例如：A模块调用C，B模块也调用C，我在C模块中多次对数据库进行了操作，以便可以让不同的模块能操作到同一组数据。</p>

<p>       经理看了我的代码之后，对我进行了指导，作此记录：</p>

<p>       1.每个agent都是一个独立的虚拟机。</p>

<p>       2.在一个虚拟机中，引用同一块代码后，再次引用会直接返回，并引用到同一块代码。(A引用C，B引用C，最后会共享同一块C代码，所以在C中可以直接用变量存贮玩家数据，不用每次都从数据库中读取)</p>

<p> </p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>skynet lua</tag>
      </tags>
  </entry>
  <entry>
    <title>skynet踩坑记录（四）cluster集群通信中，传递的消息过大造成的问题。</title>
    <url>/2020/10/23/skynet%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89cluster%E9%9B%86%E7%BE%A4%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E4%BC%A0%E9%80%92%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E5%A4%A7%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>      昨天更新后，一直触发这个报错。第一眼看我都吓懵了，这什么鬼报错，call fail。框架级别的报错。这怎么解决。</p>

<p><img alt height="260" src="https://img-blog.csdnimg.cn/20201023090638345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="778"></p>

<p>理性分析，然后在同事的提醒下查看了core的日志，然后发现</p>

<p><img alt height="368" src="https://img-blog.csdnimg.cn/20201023090722415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="682"></p>

<p>一查代码，发现</p>

<p><img alt height="402" src="https://img-blog.csdnimg.cn/20201023090801288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="705"></p>

<p>原来是集群通信中，传递的包过大造成的。获取玩家排行榜历史的时候，我缓存的所有玩家的历史，这样每个玩家只需要去拿就行了，不需要再进行多余的db操作。检查自己的逻辑，的确是发了很大的包。测试的时候数据不足，并没有发现。</p>

<p>想起在云风的blog中也说过，集群通信有错误会提示，但是业务层面要自己重新处理。</p>

<p> </p>

<p>最后修改业务层面的代码解决，其实也可以把过大的包拆成几分发送。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu apt-get安装软件Unable to locate package...</title>
    <url>/2020/02/10/ubuntu%20apt-get%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6Unable%20to%20locate%20package/</url>
    <content><![CDATA[<span id="more"></span>
<p>      由于受疫情影响(希望快点好起来)，只能在家办公，再一次安装开发环境。</p>

<p>      使用 <strong>apt-get install</strong>碰到以下问题</p>

<p>      <img alt class="has" height="87" src="https://img-blog.csdnimg.cn/2020021011014055.png" width="583"></p>

<p>     <strong> 1.sudo apt-get update 更新软件源</strong></p>

<p>      <img alt class="has" height="235" src="https://img-blog.csdnimg.cn/20200210110410941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="748"></p>

<p>      如果更新成功，无报错，无警告，则执行自己的下载即可</p>

<p>      但是我执行最后有警告</p>

<p>      <strong>Some index files failed to download. They have been ignored, or old ones used instead.</strong></p>

<p><strong>      </strong>查询资料之后发现是自己的更新源问题，需要切换更新源，执行以下步骤</p>

<p>      <strong>2.搜索打开 software&amp;update</strong></p>

<p>      <img alt class="has" height="234" src="https://img-blog.csdnimg.cn/20200210122059355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="749"></p>

<p>      打开之后选择</p>

<p>      <img alt class="has" height="446" src="https://img-blog.csdnimg.cn/20200210122414928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="817"></p>

<p>      <strong>选择other</strong></p>

<p><strong>      </strong><img alt class="has" height="457" src="https://img-blog.csdnimg.cn/20200210122519647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="831"></p>

<p>      <strong>更换源之后执行 sudo apt-get update，无报错，之后再下载自己需要下载的即可</strong></p>

<p>      可能是这次下载的Ubuntu的问题，导致这个问题的出现，以前没碰到过。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>vs code golang代码不会自动对齐问题</title>
    <url>/2021/04/09/vs%20code%20golang%E4%BB%A3%E7%A0%81%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="做此纪录"><a href="#做此纪录" class="headerlink" title="做此纪录"></a>做此纪录</h2><p>本来使用vs做golang开发的时候，代码都会对齐的，忽然有一天，就不能对齐了。<br>在网上找了好多都没找到答案，最后今天看了Effective Go前面的Formatting，觉得是这个东西出问题了。<br>然后查看vs配置，File—-&gt;Preferences—-&gt;settting—-&gt;go。<br>    <img src="https://img-blog.csdnimg.cn/20210409175728336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击后查看发现没有这一项，加上就好了。非常的简单。做此纪录<br><img src="https://img-blog.csdnimg.cn/20210409175815920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么数组遍历比链表快，从CPU和内存的角度理解。</title>
    <url>/2021/01/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%AF%94%E9%93%BE%E8%A1%A8%E5%BF%AB%EF%BC%8C%E4%BB%8ECPU%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<p>      回家的路上看了一下cpu的结构，想起了前两天和领导吃饭时聊到的问题，为什么数组遍历比链表快，明明都知道地址了。</p>

<p>      其实要理解这个问题，从cpu的结构和内存角度来理解就很清晰了。</p>

<p>      <strong>读取速度:缓存&gt;内存（剧吐多少倍差距，得看什么cpu，大概都有100倍左右）。</strong></p>

<p><strong>      </strong>cpu读取数据是按照缓存行读取到缓存的，简单来说就是cpu会把需要的数据加载到缓存中，查找数据时，会先从缓存找，找不到再到内存找。</p>

<p>      而数组作为连续内存，cpu缓存会把一片连续的内存空间读入，这样连续内存的数组会更易于整块读取到缓存中，当进行遍历时，直接命中缓存。而链表是跳跃式的地址，很轻易就会跳出缓存，跑到内存中去查找数据。所以会慢很多。</p>

<p><img alt height="498" src="https://img-blog.csdnimg.cn/20210130000547597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1095"></p>

<p>看下面的程序</p>

<pre>
<code class="language-cpp">#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

void show_arr_addr()&#123;
    long arr[2][8];
    for(int i=0; i&lt;2; i++)
    &#123;
        printf("row addr:%X\n", arr[i]);
        printf("column addr: ");
        for(int j=0; j&lt;8; j++)
        &#123;
            printf("%X, ", &amp;arr[i][j]);
        &#125;
        printf("\n");
    &#125;
&#125;

int main() &#123;
    double start = 0, finish = 0;
    long arr[100000][8];

    show_arr_addr();
    printf("---------------------------\n");

    // 先遍历行，在遍历列
    start=(double) clock(); 
    for(int i=0; i&lt;100000; i++)
        for(int j=0; j&lt;8; j++)
            arr[i][j] = 1;

    finish=(double)clock(); 
    printf("use time:%.5f ms\n",finish-start);

    // 先遍历列，再遍历行
    start=(double) clock(); 
    for(int j=0; j&lt;8; j++)
        for(int i=0; i&lt;100000; i++)
            arr[i][j] = 1;

    finish=(double)clock(); 
    printf("use time:%.5f ms\n",finish-start);
&#125;</code></pre>

<p>我是64位的cpu，所以cpu读取一次是按照64根总线，也就是64位。我构造了一个二维数组，每行是64位，可以看数组的地址，是连续的。</p>

<p>下面先进行遍历，两种遍历，先遍历列会跳出上次读取的缓存行。所以会比先遍历行慢。链表的道理也是一样，如果地址是存在缓存之外的，就会花费更多的时间。</p>

<p><img alt height="152" src="https://img-blog.csdnimg.cn/20210131131308704.png" width="929"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>数组 链表</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（1）main入口干了什么</title>
    <url>/2020/10/24/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%881%EF%BC%89main%E5%85%A5%E5%8F%A3%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<span id="more"></span>
<p>       使用skynet一年半了。源码也断断续续读了不少，也看了几篇skynet的源码分析。他们都说的很好。但是觉得分析只是给你一个理解代码的观点，但是没个人的理解方式是不一样的，我也写一写我自己的理解。</p>

<p>       下面进入正题。</p>

<p>       首先，还是要有一个观念，skynet是干嘛的，云风前辈的Skynet 设计综述，wiki什么的都是要读的。然后进入正题。</p>

<p>       从我学习开始，我理解的一个C/C++程序都是从main函数开始运行的，skynet也不例外。<strong>以下的代码关键部分都带有注释。</strong></p>

<p><strong>skynet_main.c    </strong></p>

<p><strong>main函数其实就是，解析配置，做一些初始化，然后使用配置去调用启动函数。</strong></p>

<pre>
<code class="language-cpp">int
main(int argc, char *argv[]) &#123;
    const char * config_file = NULL ;
    if (argc &gt; 1) &#123;
        config_file = argv[1];
    &#125; else &#123;
        fprintf(stderr, "Need a config file. Please read skynet wiki : https://github.com/cloudwu/skynet/wiki/Config\n"
            "usage: skynet configfilename\n");
        return 1;
    &#125;

    //这里做一些初始化
    luaS_initshr();
    skynet_globalinit();  //全局数据的一些初始化
    skynet_env_init();    //环境初始化

    sigign();

    struct skynet_config config;

    //打开一个lua虚拟机用于解析传入的配置
    struct lua_State *L = luaL_newstate();    
    luaL_openlibs(L);    // link lua lib

    int err =  luaL_loadbufferx(L, load_config, strlen(load_config), "=[skynet config]", "t");
    assert(err == LUA_OK);
    lua_pushstring(L, config_file);

    err = lua_pcall(L, 1, 1, 0);
    if (err) &#123;
        fprintf(stderr,"%s\n",lua_tostring(L,-1));
        lua_close(L);
        return 1;
    &#125;
    _init_env(L);    //这里看函数就知道是初始化环境

    //记录配置
    config.thread =  optint("thread",8);
    config.module_path = optstring("cpath","./cservice/?.so");
    config.harbor = optint("harbor", 1);
    config.bootstrap = optstring("bootstrap","snlua bootstrap");
    config.daemon = optstring("daemon", NULL);
    config.logger = optstring("logger", NULL);
    config.logservice = optstring("logservice", "logger");
    config.profile = optboolean("profile", 1);

    //解析完，关闭用于解析的lua虚拟机
    lua_close(L);

    //通过配置启动调用skynet_start
    skynet_start(&amp;config);
    skynet_globalexit();
    luaS_exitshr();

    return 0;
&#125;</code></pre>

<p><strong>skynet_start.c</strong></p>

<p><strong>skynet_start做的就是继续初始化，这里需要注意的是bootstrap，这里通过配置可以知道，其实是启动的是snlua（用C写的模块），之后所有的lua服务都是通过snlua启动的（snlua加载lua文件））先记着，之后再分析。</strong></p>

<pre>
<code class="language-cpp">void 
skynet_start(struct skynet_config * config) &#123;
    // register SIGHUP for log file reopen
    // 这里处理一些信号的问题。
    struct sigaction sa;
    sa.sa_handler = &amp;handle_hup;
    sa.sa_flags = SA_RESTART;
    sigfillset(&amp;sa.sa_mask);
    sigaction(SIGHUP, &amp;sa, NULL);

    //看看是否配置了守护进程
    if (config-&gt;daemon) &#123;
        if (daemon_init(config-&gt;daemon)) &#123;
            exit(1);
        &#125;
    &#125;
    skynet_harbor_init(config-&gt;harbor);            // harbor(港口)初始化
    skynet_handle_init(config-&gt;harbor);            // handler初始化，存贮全部的服务句柄
    skynet_mq_init();                            // 全局队列初始化
    skynet_module_init(config-&gt;module_path);    // C模块初始化
    skynet_timer_init();                        // 定时器初始化
    skynet_socket_init();                        // socket初始化
    skynet_profile_enable(config-&gt;profile);        

    //启动logger服务
    struct skynet_context *ctx = skynet_context_new(config-&gt;logservice, config-&gt;logger);
    if (ctx == NULL) &#123;
        fprintf(stderr, "Can't launch %s service\n", config-&gt;logservice);
        exit(1);
    &#125;

    skynet_handle_namehandle(skynet_context_handle(ctx), "logger");

    //启动配置中的bootstrap服务
    bootstrap(ctx, config-&gt;bootstrap);

    //调用start传入配置线程数量
    start(config-&gt;thread);

    // harbor_exit may call socket send, so it should exit before socket_free
    skynet_harbor_exit();
    skynet_socket_free();
    if (config-&gt;daemon) &#123;
        daemon_exit(config-&gt;daemon);
    &#125;
&#125;
</code></pre>

<p>然后调用，start，这是整个逻辑的启动，下篇先分析bootstrap。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>1024程序员节 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（2）服务器启动的前置任务 bootstrap 与 skynte.newservice</title>
    <url>/2020/12/13/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E7%9A%84%E5%89%8D%E7%BD%AE%E4%BB%BB%E5%8A%A1%20bootstrap%20%E4%B8%8E%20skynte.newservice/</url>
    <content><![CDATA[<span id="more"></span>
<p>      上一篇分析之后，本来第二部分分析是想分析start之后的逻辑的，这样会让人比较快速的理解skynet框架。但想想还是顺着代码启动的思路写下去会比较好，我觉得这样我自己更容易理解。</p>

<p>      bootstrap是引导程序的意思，在skynet中，的确也是做了服务器工作的前置任务。</p>

<p>再skynet_start.c中</p>

<pre>
<code class="language-cpp">//启动logger服务
struct skynet_context *ctx = skynet_context_new(config-&gt;logservice, config-&gt;logger);
    if (ctx == NULL) &#123;
    fprintf(stderr, "Can't launch %s service\n", config-&gt;logservice);
    exit(1);
    &#125;

skynet_handle_namehandle(skynet_context_handle(ctx), "logger");

//启动配置中的bootstrap服务
bootstrap(ctx, config-&gt;bootstrap);

//调用start传入配置线程数量
start(config-&gt;thread);</code></pre>

<p>查询配置</p>

<p><img alt height="326" src="https://img-blog.csdnimg.cn/20201213131031565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="873"></p>

<p>可以得知，传入的参数是"snlua bootsrtap"，再看到函数的实现</p>

<pre>
<code class="language-cpp">static void
bootstrap(struct skynet_context * logger, const char * cmdline) &#123;
    int sz = strlen(cmdline);
    char name[sz+1];
    char args[sz+1];
    sscanf(cmdline, "%s %s", name, args);
    //name = snlua, args = bootstrap
    struct skynet_context *ctx = skynet_context_new(name, args);
    if (ctx == NULL) &#123;
    skynet_error(NULL, "Bootstrap error : %s\n", cmdline);
    skynet_context_dispatchall(logger);
    exit(1);
    &#125;
&#125;</code></pre>

<p>接下来看到skynet_context_new方法，在skynet_server.c</p>

<pre>
<code class="language-cpp">struct skynet_context * 
skynet_context_new(const char * name, const char *param) &#123;
        //先查询snlua模块，这是一个C写的服务，在skynet_start.c中
        //skynet_statc方法，skynet_module_init(config-&gt;module_path)进行初始化
    struct skynet_module * mod = skynet_module_query(name);

    if (mod == NULL)
        return NULL;

        //分析1
        //这里创建一个新的lua虚拟机，所以会有各个服务的隔离
    void *inst = skynet_module_instance_create(mod);
    if (inst == NULL)
        return NULL;
    struct skynet_context * ctx = skynet_malloc(sizeof(*ctx));
    CHECKCALLING_INIT(ctx)

    ctx-&gt;mod = mod;
    ctx-&gt;instance = inst;
    ctx-&gt;ref = 2;
    ctx-&gt;cb = NULL;
    ctx-&gt;cb_ud = NULL;
    ctx-&gt;session_id = 0;
    ctx-&gt;logfile = NULL;

    ctx-&gt;init = false;
    ctx-&gt;endless = false;

    ctx-&gt;cpu_cost = 0;
    ctx-&gt;cpu_start = 0;
    ctx-&gt;message_count = 0;
    ctx-&gt;profile = G_NODE.profile;
    // Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle
    ctx-&gt;handle = 0;    
    ctx-&gt;handle = skynet_handle_register(ctx);
    struct message_queue * queue = ctx-&gt;queue = skynet_mq_create(ctx-&gt;handle);
    // init function maybe use ctx-&gt;handle, so it must init at last
    context_inc();

    CHECKCALLING_BEGIN(ctx)
        //分析2
        //这里使用snlua，启动传入的bootstrap.lua
    int r = skynet_module_instance_init(mod, inst, ctx, param);
    CHECKCALLING_END(ctx)
    if (r == 0) &#123;
        struct skynet_context * ret = skynet_context_release(ctx);
        if (ret) &#123;
            ctx-&gt;init = true;
        &#125;
        skynet_globalmq_push(queue);
        if (ret) &#123;
            skynet_error(ret, "LAUNCH %s %s", name, param ? param : "");
        &#125;
        return ret;
    &#125; else &#123;
        skynet_error(ctx, "FAILED launch %s", name);
        uint32_t handle = ctx-&gt;handle;
        skynet_context_release(ctx);
        skynet_handle_retire(handle);
        struct drop_t d = &#123; handle &#125;;
        skynet_mq_release(queue, drop_message, &amp;d);
        return NULL;
    &#125;
&#125;</code></pre>

<p>按照分析1、分析2的顺序。先看到skynet_module_instance_create，分析1</p>

<pre>
<code class="language-cpp">void * 
skynet_module_instance_create(struct skynet_module *m) &#123;
    if (m-&gt;create) &#123;
        return m-&gt;create(); // 调用c模块的create
    &#125; else &#123;
        return (void *)(intptr_t)(~0);
    &#125;
&#125;</code></pre>

<p>看到snlua的create，再service_snlua.c，构建新的lua虚拟机，所以有服务之间的隔离。</p>

<pre>
<code class="language-cpp">struct snlua *
snlua_create(void) &#123;
    struct snlua * l = skynet_malloc(sizeof(*l));    
    memset(l,0,sizeof(*l));
    l-&gt;mem_report = MEMORY_WARNING_REPORT;
    l-&gt;mem_limit = 0;
    l-&gt;L = lua_newstate(lalloc, l); // 这里构建了新的lua虚拟机
    return l;
&#125;</code></pre>

<p>创建完虚拟机后，看到分析2，到skynet_module_instance_init，在skynet_module.c中，可以看到，其实就是上面代码注释说的，使用snlua的init去启动bootstarp</p>

<pre>
<code class="language-cpp">int
skynet_module_instance_init(struct skynet_module *m, void * inst, struct skynet_context *ctx, const char * parm) &#123;
    return m-&gt;init(inst, ctx, parm);
&#125;</code></pre>

<p>接下来我们到service_snlua.lua中看是怎么使用snlua去启动一个lua脚本的，skynet中，C模块的定义，必须要有一些方法，比如init，上面的m-&gt;init，最后会调用到下面的函数</p>

<pre>
<code class="language-cpp">int
snlua_init(struct snlua *l, struct skynet_context *ctx, const char * args) &#123;
    int sz = strlen(args);
    char * tmp = skynet_malloc(sz);
    memcpy(tmp, args, sz);
        //给需要初始化的服务设置回调函数为上面的luanch_cb
    skynet_callback(ctx, l , launch_cb);
    const char * self = skynet_command(ctx, "REG", NULL);
    uint32_t handle_id = strtoul(self+1, NULL, 16);
    // it must be first message
        // 给服务发送消息触发上面的launch_cb
        // 这里先知道触发上面，具体的消息处理我们的分析会说明
        // 给服务发送消息之后，具体的服务是怎么去处理的
    skynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz);
    return 0;
&#125;</code></pre>

<p>发送消息后，调用到luanch_cb</p>

<pre>
<code class="language-cpp">static int
launch_cb(struct skynet_context * context, void *ud, int type, int session, uint32_t source , const void * msg, size_t sz) &#123;
    assert(type == 0 &amp;&amp; session == 0);
    struct snlua *l = ud;
    skynet_callback(context, NULL, NULL);
    int err = init_cb(l, context, msg, sz);//再这进行服务的最后初始化，分析在下面
    if (err) &#123;
        skynet_command(context, "EXIT", NULL);
    &#125;

    return 0;
&#125;</code></pre>

<p>最后调用init_cb，下面是精简了的代码，只是为了说明调用流程</p>

<pre>
<code class="language-cpp">static int
init_cb(struct snlua *l, struct skynet_context *ctx, const char * args, size_t sz) &#123;
        ......

        //这里，就是使用loader.lua去加载我们的bootstrap
        const char * loader = optstring(ctx, "lualoader", "./lualib/loader.lua");

    int r = luaL_loadfile(L,loader);
    if (r != LUA_OK) &#123;
        skynet_error(ctx, "Can't load %s : %s", loader, lua_tostring(L, -1));
        report_launcher_error(ctx);
        return 1;
    &#125;
    lua_pushlstring(L, args, sz);
    r = lua_pcall(L,1,0,1); // 这里，就又通过C语言的lua接口，调用回了lua层面。
    if (r != LUA_OK) &#123;
        skynet_error(ctx, "lua loader error : %s", lua_tostring(L, -1));
        report_launcher_error(ctx);
        return 1;
    &#125;
    lua_settop(L,0);
    if (lua_getfield(L, LUA_REGISTRYINDEX, "memlimit") == LUA_TNUMBER) &#123;
        size_t limit = lua_tointeger(L, -1);
        l-&gt;mem_limit = limit;
        skynet_error(ctx, "Set memory limit to %.2f M", (float)limit / (1024 * 1024));
        lua_pushnil(L);
        lua_setfield(L, LUA_REGISTRYINDEX, "memlimit");
    &#125;
    lua_pop(L, 1);

    lua_gc(L, LUA_GCRESTART, 0);

    return 0;
&#125;</code></pre>

<p>启动了bootstrap又怎样呢，往下看bootstrap.lua</p>

<pre>
<code class="language-Lua">skynet.start(function()
    local sharestring = tonumber(skynet.getenv "sharestring" or 4096)
    memory.ssexpand(sharestring)

    local standalone = skynet.getenv "standalone"

        // 这里又用snlua去启动了launcher.lua，启动过程和bootstrap一样
        // 这个launcher服务先记住，待会儿就知道干嘛的了
    local launcher = assert(skynet.launch("snlua","launcher"))
    skynet.name(".launcher", launcher)

        // 这下面还有一些是bootstrap这个前置任务做的
        // 这里skynet.newservice是啥？
    ......
        skynet.newservice "service_mgr"
    pcall(skynet.newservice,skynet.getenv "start" or "main")
    skynet.exit()// 启动完上面的，完成了任务，这个服务就退出了

end)</code></pre>

<p>看到skynet.newservice，这个在skynet中，就是lua层用来启动新服务的。在skynet.lua中，可以看到，call  .launcher就是使用上面启动的launcher.lua去启动一个服务</p>

<pre>
<code class="language-Lua">function skynet.newservice(name, ...)
        // 这个参数 "LAUNCH", "snlua", name, ...特别注意一下
        // 最后也是用调用snlua去启动一个lua服务
    return skynet.call(".launcher", "lua" , "LAUNCH", "snlua", name, ...)
end</code></pre>

<p>在看到launcher中的LAUNCH，在launcher.lua中</p>

<pre>
<code class="language-Lua">require "skynet.manager"    -- import manager apis

local function launch_service(service, ...)
    local param = table.concat(&#123;...&#125;, " ")
    local inst = skynet.launch(service, param)
    local session = skynet.context()
    local response = skynet.response()
    if inst then
        services[inst] = service .. " " .. param
        instance[inst] = response
        launch_session[inst] = session
    else
        response(false)
        return
    end
    return inst
end

function command.LAUNCH(_, service, ...)
    launch_service(service, ...)
    return NORET
end</code></pre>

<p>下面看到skyne.launch，在manager.lua</p>

<pre>
<code class="language-cpp">local c = require "skynet.core"

function skynet.launch(...)
    local addr = c.command("LAUNCH", table.concat(&#123;...&#125;," "))
    if addr then
        return tonumber("0x" .. string.sub(addr , 2))
    end
end</code></pre>

<p>调用到c.command，</p>

<p>这里的skynet.core是一个C语言模块，至此，我们将进入C语言实现部分，调用skynet.core.command(“LAUNCH”, “snlua ...”)。</p>

<p>我们先总结一下lua部分的内容：</p>

<p>newservice–&gt;skynet.call .launcher–&gt;.launcher=skynet.launch(“snlua”, “launcher”)–&gt;skynet.core.command(“LAUNCH”, “snlua ...”)</p>

<p>skynet.core其实是在lua_skynet.c中定义的，其command对应于lcommand函数。 这时的参数其实都压进了lua_State中。</p>

<pre>
<code class="language-cpp">static int
lcommand(lua_State *L) &#123;
    struct skynet_context * context = lua_touserdata(L, lua_upvalueindex(1));
    const char * cmd = luaL_checkstring(L,1);
    const char * result;
    const char * parm = NULL;
    if (lua_gettop(L) == 2) &#123;
        parm = luaL_checkstring(L,2);
    &#125;

        // 这里就是调用skynet_server.c
    result = skynet_command(context, cmd, parm);
    if (result) &#123;
        lua_pushstring(L, result);
        return 1;
    &#125;
    return 0;
&#125;</code></pre>

<p>也就最后调用到skynet_server.c中skynet_command</p>

<pre>
<code class="language-cpp">static struct command_func cmd_funcs[] = &#123;
    &#123; "TIMEOUT", cmd_timeout &#125;,
    &#123; "REG", cmd_reg &#125;,
    &#123; "QUERY", cmd_query &#125;,
    &#123; "NAME", cmd_name &#125;,
    &#123; "EXIT", cmd_exit &#125;,
    &#123; "KILL", cmd_kill &#125;,
    &#123; "LAUNCH", cmd_launch &#125;, //LAUNCH对应这个
    &#123; "GETENV", cmd_getenv &#125;,
    &#123; "SETENV", cmd_setenv &#125;,
    &#123; "STARTTIME", cmd_starttime &#125;,
    &#123; "ABORT", cmd_abort &#125;,
    &#123; "MONITOR", cmd_monitor &#125;,
    &#123; "STAT", cmd_stat &#125;,
    &#123; "LOGON", cmd_logon &#125;,
    &#123; "LOGOFF", cmd_logoff &#125;,
    &#123; "SIGNAL", cmd_signal &#125;,
    &#123; NULL, NULL &#125;,
&#125;;

const char * 
skynet_command(struct skynet_context * context, const char * cmd , const char * param) &#123;
    struct command_func * method = &amp;cmd_funcs[0];
    while(method-&gt;name) &#123;
        if (strcmp(cmd, method-&gt;name) == 0) &#123;
            return method-&gt;func(context, param);
        &#125;
        ++method;
    &#125;

    return NULL;
&#125;</code></pre>

<p>再看到cmd_launch，这里就十分熟悉了，接入回上面的bootstrap的分析</p>

<pre>
<code class="language-cpp">static const char *
cmd_launch(struct skynet_context * context, const char * param) &#123;
    size_t sz = strlen(param);
    char tmp[sz+1];
    strcpy(tmp,param);
    char * args = tmp;
    char * mod = strsep(&amp;args, " \t\r\n");
    args = strsep(&amp;args, "\r\n");

        // 这里这几行是不是特别熟悉
        // 没错，就是和上面的bootstrap的启动一模一样
        // 就是使用snlua去启动另外的服务
    struct skynet_context * inst = skynet_context_new(mod,args);
    if (inst == NULL) &#123;
        return NULL;
    &#125; else &#123;
        id_to_hex(context-&gt;result, inst-&gt;handle);
        return context-&gt;result;
    &#125;
&#125;</code></pre>

<p> </p>

<p>可以看到，之后我们在lua层使用的skynet.newservice都是通过launcher.lua去启动新服务器的了。</p>

<p>最后bootstrap做的事情中一个重要就是，启动了launcher.lua服务，之后框架中skynet.newservice就是调用launcher去启动lua服务。</p>

<p>所以叫他服务器的前置任务。之后的启动新服务之后，回调函数怎么挂钩之类的，之后在分析。</p>

<p>下一篇分享bootstrap后skynet_start做了什么</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（3）skynet.start服务器启动之后做了什么</title>
    <url>/2021/03/21/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89skynet.start%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<span id="more"></span>
<p>俗事缠身，加上自己有点懒，skynet分析的事情拖了很久，之后尽快分析完。其实skynet是一个很优秀的框架，值得细读，多读（上加公司的老大这么对我说的，现在我也觉得是这样的）。skynet.star东西比较多，分四篇分析。下面直接进入正题。</p>
<h2 id="启动服务器skynet-start"><a href="#启动服务器skynet-start" class="headerlink" title="启动服务器skynet_start()"></a>启动服务器skynet_start()</h2><p>start传入配置的线程数量，启动服务器。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_start</span><span class="params">(<span class="keyword">struct</span> skynet_config * config)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 调用start传入配置线程数量</span></span><br><span class="line">	<span class="comment">// 这个线程数量就是工作线程数量</span></span><br><span class="line">	start(config-&gt;thread);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// harbor_exit may call socket send, so it should exit before socket_free</span></span><br><span class="line">	skynet_harbor_exit();</span><br><span class="line">	skynet_socket_free();</span><br><span class="line">	<span class="keyword">if</span> (config-&gt;daemon) &#123;</span><br><span class="line">		daemon_exit(config-&gt;daemon);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面进入到start的逻辑，在同一个文件，先看注释，了解大概流程。之后我们一个结构一个结构分析<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">(<span class="type">int</span> thread)</span> &#123;</span><br><span class="line">    <span class="comment">// 声明传入的线程数量thread+3，之后会看到为什么+3</span></span><br><span class="line">	<span class="type">pthread_t</span> pid[thread+<span class="number">3</span>];  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建服务器monitor</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*m));</span><br><span class="line">	<span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">	m-&gt;count = thread;  <span class="comment">// 记录线程数量</span></span><br><span class="line">	m-&gt;sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建对应数量的skynet_monitor 并初始化</span></span><br><span class="line">	m-&gt;m = skynet_malloc(thread * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_monitor *));</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">		m-&gt;m[i] = skynet_monitor_new();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化互斥锁</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;m-&gt;mutex, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Init mutex error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化条件变量</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_cond_init(&amp;m-&gt;cond, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Init cond error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里就是额外+的三个线程</span></span><br><span class="line">	<span class="comment">// 一条监视者线程，一条定时器线程，一条网络线程</span></span><br><span class="line">	create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">	create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">	create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里是设程的比重，关于消息队列的调度</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> weight[] = &#123; </span><br><span class="line">		<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, </span><br><span class="line">		<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, </span><br><span class="line">		<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line">	<span class="comment">// 声明对应数量的工作线程环境</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化工作线程</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">		wp[i].m = m;	<span class="comment">// 关联服务器monitor</span></span><br><span class="line">		wp[i].id = i;   <span class="comment">// 关联线程id</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 配置线程比重，这个比重有什么用之后分析</span></span><br><span class="line">		<span class="comment">// 如果配置了超过8条工作线程，会走else逻辑，比重都是0</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">			wp[i].weight= weight[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wp[i].weight = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建工作线程，这里pid[i+3]，与上面对应</span></span><br><span class="line">		create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待监视者线程，定时器线程，网络线程结束</span></span><br><span class="line">	<span class="comment">// 服务器正常运行，是不会结束的</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread+<span class="number">3</span>;i++) &#123;</span><br><span class="line">		pthread_join(pid[i], <span class="literal">NULL</span>); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果结束了，做清理工作</span></span><br><span class="line">	free_monitor(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过上面可以知道，其实服务器模型就是线程池模型，启动了一条监视者线程，一条定时器线程，一条网络线程和配置的工作线程。要想知道线程是怎么工作的，要对上面各个线程的工作函数进行逐一分析即可。下篇分析monitor。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（4）skynet.start服务器启动之后做了什么之monitor(监视者)</title>
    <url>/2021/03/21/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89skynet.start%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%B9%8Bmonitor(%E7%9B%91%E8%A7%86%E8%80%85)/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>monitor分为服务器的monitor 和 skynet_monitor，整个服务器只有一个服务器monitor，每条工作线程绑定一个skynet_monitor，上面在声明了若干条线程数量后，先做的就是创建服务器monitor。</p>
<h3 id="服务器-monitor"><a href="#服务器-monitor" class="headerlink" title="服务器 monitor"></a>服务器 monitor</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以把服务退出的消息从框架层抛出来，让上层逻辑可以感知到</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> count;					<span class="comment">// 多少条工作线程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> ** <span class="title">m</span>;</span> <span class="comment">// skynet_monitor</span></span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;		<span class="comment">// 条件变量</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span> mutex;		<span class="comment">// 互斥锁</span></span><br><span class="line">	<span class="type">int</span> sleep;					</span><br><span class="line">	<span class="type">int</span> quit;					<span class="comment">// 服务器是否退出的标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start(<span class="type">int</span> thread) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*m));</span><br><span class="line">	<span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">	m-&gt;count = thread;</span><br><span class="line">	m-&gt;sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	m-&gt;m = skynet_malloc(thread * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_monitor *));</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">		m-&gt;m[i] = skynet_monitor_new();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;m-&gt;mutex, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Init mutex error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pthread_cond_init(&amp;m-&gt;cond, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Init cond error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作线程监视-skynet-monitor"><a href="#工作线程监视-skynet-monitor" class="headerlink" title="工作线程监视 skynet_monitor"></a>工作线程监视 skynet_monitor</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_monitor.h</span></span><br><span class="line"><span class="keyword">struct</span> skynet_monitor * <span class="title function_">skynet_monitor_new</span><span class="params">()</span>;<span class="comment">//新建一个监视器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skynet_monitor_delete</span><span class="params">(<span class="keyword">struct</span> skynet_monitor *)</span>;<span class="comment">//删除一个监视器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skynet_monitor_trigger</span><span class="params">(<span class="keyword">struct</span> skynet_monitor *, <span class="type">uint32_t</span> source, <span class="type">uint32_t</span> destination)</span>;<span class="comment">//通知监视器开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skynet_monitor_check</span><span class="params">(<span class="keyword">struct</span> skynet_monitor *)</span>;<span class="comment">//检查监视器是否陷入死循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_monitor.c</span></span><br><span class="line"><span class="comment">// 主要用于监测skynet服务在处理消息时是否陷入死循环</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> version;                <span class="comment">// 当前版本</span></span><br><span class="line">    <span class="type">int</span> check_version;          <span class="comment">// 检查版本</span></span><br><span class="line">    <span class="type">uint32_t</span> source;            <span class="comment">// 消息源服务</span></span><br><span class="line">    <span class="type">uint32_t</span> destination;       <span class="comment">// 消息目标服务</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">truct skynet_monitor * </span><br><span class="line"><span class="title function_">skynet_monitor_new</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> * <span class="title">ret</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*ret));</span><br><span class="line">	<span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ret));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="thread-monitor-线程"><a href="#thread-monitor-线程" class="headerlink" title="thread_monitor 线程"></a>thread_monitor 线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有正在运行的skynet_context(skynet服务)则break</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ABORT <span class="keyword">if</span> (skynet_context_total()==0) break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="comment">// 设置统一线程内的共享数据</span></span><br><span class="line"><span class="comment">// 线程内部的各个函数调用都能访问、但其它线程不能访问的变量</span></span><br><span class="line"><span class="comment">// 处理了进程内静态变量全部线程共享的问题</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">skynet_initthread</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">	<span class="type">uintptr_t</span> v = (<span class="type">uint32_t</span>)(-m);</span><br><span class="line">	pthread_setspecific(G_NODE.handle_key, (<span class="type">void</span> *)v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_monitor.c</span></span><br><span class="line"><span class="comment">// 检查服务是否陷入死循环</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_monitor_check</span><span class="params">(<span class="keyword">struct</span> skynet_monitor *sm)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (sm-&gt;version == sm-&gt;check_version) &#123;</span><br><span class="line">		<span class="comment">// 这说明一个消息处理了5到10秒还没有返回，</span></span><br><span class="line">		<span class="comment">// 导致sm-&gt;version一直没有增长。下一次check发现没有增长，</span></span><br><span class="line">		<span class="comment">// 就认为它可能发生死循环了。</span></span><br><span class="line">		<span class="comment">// 处理也只是加一个标记，并打印一条错误日志，没有再做其他处理。</span></span><br><span class="line">		<span class="keyword">if</span> (sm-&gt;destination) &#123;</span><br><span class="line">			skynet_context_endless(sm-&gt;destination);</span><br><span class="line">			skynet_error(<span class="literal">NULL</span>, <span class="string">&quot;A message from [ :%08x ] to [ :%08x ] maybe in an endless loop (version = %d)&quot;</span>, sm-&gt;source , sm-&gt;destination, sm-&gt;version);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果版本不一致，更新检查版本</span></span><br><span class="line">		sm-&gt;check_version = sm-&gt;version;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread_monitor</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> =</span> p;				<span class="comment">//拿到服务器monitor</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> n = m-&gt;count;					<span class="comment">// 拿到工作线程数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置统一线程内的共享数据THREAD_MONITOR，标记为monitor线程</span></span><br><span class="line">	skynet_initthread(THREAD_MONITOR); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 线程死循环</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 定义在上面，检查是否还有skynet服务运行</span></span><br><span class="line">		CHECK_ABORT	</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查每一个工作线程是否陷入死循环</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			skynet_monitor_check(m-&gt;m[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每秒检查一次是否还有服务在运行</span></span><br><span class="line">		<span class="comment">// 延迟5s后再进入上面的检查工作线程</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">			CHECK_ABORT	</span><br><span class="line">			<span class="title function_">sleep</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，skynet.star大概做了什么，monitor部分功能都做了大概分析。下篇顺着skynet.star分析，thread_timer(skynet定时器)</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端 c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（5）skynet.start服务器启动之后做了什么之thread_timer(skynet定时器)</title>
    <url>/2021/03/21/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%885%EF%BC%89skynet.start%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%B9%8Bthread_timer(skynet%E5%AE%9A%E6%97%B6%E5%99%A8)/</url>
    <content><![CDATA[<span id="more"></span>
<p>继续按照skynet.start中的顺序分析。分析skynet定时器。启动各个线程都会做类似的初始化。</p>
<h2 id="定时器分析"><a href="#定时器分析" class="headerlink" title="定时器分析"></a>定时器分析</h2><p>这里要做一个前置理解，定时器，是只需要关心最近即将到来的任务，而不用关心距离现在比较远的任务，例如<br>1.你注册了100个定时任务，定时任务按照时间排序后<br>2.A任务2s后触发，B任务3h后触发，C任务h后触发……<br>3.当刷新时间的时候，需要去拿到即将到来的任务而需要关心之后的任务，这里就是只需要关心A任务，也就是你不需要去遍历所有任务列表拿到即将发生的任务，因为B之后的任务包括B，时间间隔太远了都不需要去关心。</p>
<p>所以定时器的设计需要：<br>1.查询快<br>2.做好排序<br>3.删除做完的任务之后不影响之前结构</p>
<p>常见的设计例如使用最小堆，时间轮，红黑树，而skynet使用的是时间轮。</p>
<p>时间轮的设计就类似于我们生活中的钟表，大概说就是，秒针走一圈，分针走一格，分针走一圈，时针走一格。<br>运用到程序中，大概就是，<br>1.我们只关心秒针的任务。<br>2.秒针的一圈任务执行完了之后，拿分针一格的任务分配到秒针各秒中。这样就我们每次都只会从秒针的任务中拿到需要执行的任务，和第1点一致。<br>3.分针的一圈任务执行完了之后，拿时针一格的任务分配到分针各分中。</p>
<h3 id="先看定时器结构"><a href="#先看定时器结构" class="headerlink" title="先看定时器结构"></a>先看定时器结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_NEAR_SHIFT 8					<span class="comment">// 临近时间转移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_NEAR (1 &lt;&lt; TIME_NEAR_SHIFT)	<span class="comment">// 临近时间量 0x10000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_LEVEL_SHIFT 6					<span class="comment">// 别的时间等级转移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_LEVEL (1 &lt;&lt; TIME_LEVEL_SHIFT)	<span class="comment">// 时间等级 0x1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_NEAR_MASK (TIME_NEAR-1)		<span class="comment">// 临近时间掩码 0x1111</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_LEVEL_MASK (TIME_LEVEL-1)		<span class="comment">// 别的时间等级掩码 0x1011</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> handle; <span class="comment">//即是设置定时器的来源，又是超时消息发送的目标</span></span><br><span class="line">    <span class="type">int</span> session; <span class="comment">//session，一个增ID，溢出了从1开始，所以不要设时间很长的timer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间节点链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> *<span class="title">next</span>;</span>	<span class="comment">// 下一个节点地址</span></span><br><span class="line">	<span class="type">uint32_t</span> expire;			<span class="comment">// 到期时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器任务链表，</span></span><br><span class="line"><span class="comment">// 链表每个节点是一个时间节点链表</span></span><br><span class="line"><span class="comment">// 这里一定要清楚，定时器任务链表上每个节点是一个时间节点链表</span></span><br><span class="line"><span class="comment">// 即同一时间的任务链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> <span class="title">head</span>;</span>		<span class="comment">// 头节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> *<span class="title">tail</span>;</span>	<span class="comment">// 尾节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span> &#123;</span></span><br><span class="line">	<span class="comment">// (临近时间)8 + 4*(另外等级)6 = 32，刚好32位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link_list</span> <span class="title">near</span>[<span class="title">TIME_NEAR</span>];</span>	<span class="comment">// 临近时间的定时器任务链表，也就是我上面说的秒针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link_list</span> <span class="title">t</span>[4][<span class="title">TIME_LEVEL</span>];</span>	<span class="comment">// 剩下的四个等级的任务链表</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>				<span class="comment">// 自旋锁</span></span><br><span class="line">	<span class="type">uint32_t</span> time;						<span class="comment">// 服务器经过的的tick数，每10毫秒tick一次</span></span><br><span class="line">	<span class="type">uint32_t</span> starttime;					<span class="comment">// 程序启动时间戳</span></span><br><span class="line">	<span class="type">uint64_t</span> current;					<span class="comment">// 启动到现在的耗时，精度10毫秒级</span></span><br><span class="line">	<span class="type">uint64_t</span> current_point;				<span class="comment">// 当前时间，精度10毫秒级</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h3><p>skynet_start中调用 skynet_timer_init初始化，在我的《从头开始读skynet源码（1）》中有写。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start中调用 skynet_timer_init初始化</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	TI = timer_create_timer();</span><br><span class="line">	<span class="type">uint32_t</span> current = <span class="number">0</span>;</span><br><span class="line">	systime(&amp;TI-&gt;starttime, &amp;current);</span><br><span class="line">	TI-&gt;current = current;</span><br><span class="line">	TI-&gt;current_point = gettime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> timer *</span><br><span class="line"><span class="title function_">timer_create_timer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer</span> *<span class="title">r</span>=</span>(<span class="keyword">struct</span> timer *)skynet_malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> timer));</span><br><span class="line">	<span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(*r));</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置临近时间定时器任务链表</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;TIME_NEAR;i++) &#123;</span><br><span class="line">		link_clear(&amp;r-&gt;near[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置别的等级定时器任务链表</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;TIME_LEVEL;j++) &#123;</span><br><span class="line">			link_clear(&amp;r-&gt;t[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化按互斥锁</span></span><br><span class="line">	SPIN_INIT(r)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置启动到现在的耗时</span></span><br><span class="line">	r-&gt;current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空该任务节点</span></span><br><span class="line"><span class="comment">// 一次取出该任务节点的所有任务</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> timer_node *</span><br><span class="line"><span class="title function_">link_clear</span><span class="params">(<span class="keyword">struct</span> link_list *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> * <span class="title">ret</span> =</span> <span class="built_in">list</span>-&gt;head.next;</span><br><span class="line">	<span class="built_in">list</span>-&gt;head.next = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>-&gt;tail = &amp;(<span class="built_in">list</span>-&gt;head);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="启动定时器线程"><a href="#启动定时器线程" class="headerlink" title="启动定时器线程"></a>启动定时器线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">(<span class="type">int</span> thread)</span> &#123;</span><br><span class="line"> 	...</span><br><span class="line">	create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器线程</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread_timer</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> =</span> p;				<span class="comment">// 拿到服务器 monitor</span></span><br><span class="line">	skynet_initthread(THREAD_TIMER);    <span class="comment">// 设置线程共享变量，标记为定时器线程</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 线程死循环</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		skynet_updatetime();			<span class="comment">// 刷新skynet时间</span></span><br><span class="line">		skynet_socket_updatetime();		<span class="comment">// 更新socket的时间</span></span><br><span class="line">		CHECK_ABORT						<span class="comment">// 检查是否还有skynet服务</span></span><br><span class="line">		wakeup(m,m-&gt;count<span class="number">-1</span>);			<span class="comment">// 尝试唤醒</span></span><br><span class="line">		usleep(<span class="number">2500</span>);	               	<span class="comment">// 休息2.5毫秒</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果收到退出信号，则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (SIG) &#123;</span><br><span class="line">			signal_hup();</span><br><span class="line">			SIG = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// wakeup socket thread</span></span><br><span class="line">	skynet_socket_exit();</span><br><span class="line">	<span class="comment">// wakeup all worker thread</span></span><br><span class="line">	pthread_mutex_lock(&amp;m-&gt;mutex);</span><br><span class="line">	m-&gt;quit = <span class="number">1</span>;</span><br><span class="line">	pthread_cond_broadcast(&amp;m-&gt;cond);</span><br><span class="line">	pthread_mutex_unlock(&amp;m-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有未工作的线程，将其唤醒（虚假唤醒）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="keyword">struct</span> monitor *m, <span class="type">int</span> busy)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;sleep &gt;= m-&gt;count - busy) &#123;</span><br><span class="line">		<span class="comment">// signal sleep worker, &quot;spurious wakeup&quot; is harmless</span></span><br><span class="line">		pthread_cond_signal(&amp;m-&gt;cond);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，定时器就是每2.5毫秒刷新一次，至于定时任务的处理，<strong>看到skynet_updatetime。这里就是skynet定时器的精华。</strong></p>
<h3 id="skynet-updatetime，定时器刷新"><a href="#skynet-updatetime，定时器刷新" class="headerlink" title="skynet_updatetime，定时器刷新"></a>skynet_updatetime，定时器刷新</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">skynet_updatetime</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">uint64_t</span> cp = gettime();		<span class="comment">// 获取当前时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(cp &lt; TI-&gt;current_point) &#123;	</span><br><span class="line">		<span class="comment">// 如果当前时间小于服务器时间则重置时间</span></span><br><span class="line">		skynet_error(<span class="literal">NULL</span>, <span class="string">&quot;time diff error: change from %lld to %lld&quot;</span>, cp, TI-&gt;current_point);</span><br><span class="line">		TI-&gt;current_point = cp;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp != TI-&gt;current_point) &#123;</span><br><span class="line">		<span class="comment">// 如果当前时间大于等于服务器时间</span></span><br><span class="line">		<span class="comment">// 获取相差时间</span></span><br><span class="line">		<span class="type">uint32_t</span> diff = (<span class="type">uint32_t</span>)(cp - TI-&gt;current_point);</span><br><span class="line"></span><br><span class="line">		TI-&gt;current_point = cp;	<span class="comment">// 更新服务器时间</span></span><br><span class="line">		TI-&gt;current += diff;	<span class="comment">// 更新启动到现在的耗时</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 处理相差时间的定时任务</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;diff;i++) &#123;</span><br><span class="line">			timer_update(TI);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给一个时间差，处理相差时间的定时器任务</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">timer_update</span><span class="params">(<span class="keyword">struct</span> timer *T)</span> &#123;</span><br><span class="line">	SPIN_LOCK(T);		<span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// try to dispatch timeout 0 (rare condition)</span></span><br><span class="line">	timer_execute(T);	<span class="comment">// 处理任务</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// shift time first, and then dispatch timer message</span></span><br><span class="line">	<span class="comment">// 重新分配任务，也就是我说的秒针走了一圈，</span></span><br><span class="line">	<span class="comment">// 把分针任务分配到秒针的概念</span></span><br><span class="line">	timer_shift(T);		</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次尝试处理任务，类似分针走一格，重新分配秒针</span></span><br><span class="line">	<span class="comment">// 重新分配后，第一秒的任务也触发了</span></span><br><span class="line">	timer_execute(T); 	</span><br><span class="line"></span><br><span class="line">	SPIN_UNLOCK(T);	<span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理任务</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">timer_execute</span><span class="params">(<span class="keyword">struct</span> timer *T)</span> &#123;</span><br><span class="line">	<span class="comment">// 当前时间与时间掩码做&amp;运算</span></span><br><span class="line">	<span class="comment">// 时间掩码 0x1111，&amp;运算之后</span></span><br><span class="line">	<span class="comment">// 获得当前时间需要处理的所有任务链表</span></span><br><span class="line">	<span class="comment">// 我们只关心即将到来的所有任务</span></span><br><span class="line">	<span class="type">int</span> idx = T-&gt;time &amp; TIME_NEAR_MASK; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (T-&gt;near[idx].head.next) &#123;</span><br><span class="line">		<span class="comment">// 如果该任务节点有任务，取出所有任务</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> *<span class="title">current</span> =</span> link_clear(&amp;T-&gt;near[idx]);</span><br><span class="line">		SPIN_UNLOCK(T);</span><br><span class="line">		<span class="comment">// dispatch_list don&#x27;t need lock T</span></span><br><span class="line">		dispatch_list(current);</span><br><span class="line">		SPIN_LOCK(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发时间任务</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_list</span><span class="params">(<span class="keyword">struct</span> timer_node *current)</span> &#123;</span><br><span class="line">	<span class="comment">// 循环处理这个任务节点的所有任务</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 获取任务结构，这个是注册定时器任务的时候加入的</span></span><br><span class="line">		<span class="comment">// 下面会有分析</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timer_event</span> * <span class="title">event</span> =</span> (<span class="keyword">struct</span> timer_event *)(current+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给任务加上信息</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">message</span>;</span></span><br><span class="line">		message.source = <span class="number">0</span>;</span><br><span class="line">		message.session = event-&gt;session; <span class="comment">//这个很重要，接收侧靠它来识别是哪个timer</span></span><br><span class="line">		message.data = <span class="literal">NULL</span>;</span><br><span class="line">		message.sz = (<span class="type">size_t</span>)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将任务放入消息队列</span></span><br><span class="line">		skynet_context_push(event-&gt;handle, &amp;message);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取下一个任务</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> * <span class="title">temp</span> =</span> current;</span><br><span class="line">		current=current-&gt;next;</span><br><span class="line">		skynet_free(temp);	</span><br><span class="line">	&#125; <span class="keyword">while</span> (current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet服务注册定时器任务</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">skynet_timeout</span><span class="params">(<span class="type">uint32_t</span> handle, <span class="type">int</span> time, <span class="type">int</span> session)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 立刻触发</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">message</span>;</span></span><br><span class="line">		message.source = <span class="number">0</span>;</span><br><span class="line">		message.session = session;</span><br><span class="line">		message.data = <span class="literal">NULL</span>;</span><br><span class="line">		message.sz = (<span class="type">size_t</span>)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skynet_context_push(handle, &amp;message)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 稍后触发</span></span><br><span class="line">		<span class="keyword">struct</span> timer_event event;</span><br><span class="line">		event.handle = handle;	<span class="comment">//记录是哪个skynet服务</span></span><br><span class="line">		event.session = session;</span><br><span class="line">		timer_add(TI, &amp;event, <span class="keyword">sizeof</span>(event), time);	<span class="comment">//加入定时器任务链表</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入定时器任务链表</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">timer_add</span><span class="params">(<span class="keyword">struct</span> timer *T,<span class="type">void</span> *arg,<span class="type">size_t</span> sz,<span class="type">int</span> time)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> timer_node *)skynet_malloc(<span class="keyword">sizeof</span>(*node)+sz);</span><br><span class="line">	<span class="built_in">memcpy</span>(node+<span class="number">1</span>,arg,sz);</span><br><span class="line"></span><br><span class="line">	SPIN_LOCK(T);</span><br><span class="line">		</span><br><span class="line">	node-&gt;expire=time+T-&gt;time;	<span class="comment">// 记录触发时间</span></span><br><span class="line">	add_node(T,node);			<span class="comment">// 加入到合适的节点</span></span><br><span class="line"></span><br><span class="line">	SPIN_UNLOCK(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入到合适的节点</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">add_node</span><span class="params">(<span class="keyword">struct</span> timer *T,<span class="keyword">struct</span> timer_node *node)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> time=node-&gt;expire;		<span class="comment">// 触发时间</span></span><br><span class="line">	<span class="type">uint32_t</span> current_time=T-&gt;time;	<span class="comment">// 启动到现在经过的tick</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) &#123;</span><br><span class="line">		<span class="comment">// 如果是临近发生的，则丢入临近发生链表的对应节点</span></span><br><span class="line">		<span class="comment">// 触发时间 &amp; 0x1111，获得触发时间对应的节点</span></span><br><span class="line">		link(&amp;T-&gt;near[time&amp;TIME_NEAR_MASK],node);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果不是临近发生的，则丢入对应的链表</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">uint32_t</span> mask=TIME_NEAR &lt;&lt; TIME_LEVEL_SHIFT;</span><br><span class="line">		<span class="comment">// 在接下来的三等级中寻找</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((time|(mask<span class="number">-1</span>))==(current_time|(mask<span class="number">-1</span>))) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不是前面三个等级，则是第四个等级</span></span><br><span class="line">		link(&amp;T-&gt;t[i][((time&gt;&gt;(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) &amp; TIME_LEVEL_MASK)],node);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间节点加入</span></span><br><span class="line">tatic <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">link</span><span class="params">(<span class="keyword">struct</span> link_list *<span class="built_in">list</span>,<span class="keyword">struct</span> timer_node *node)</span> &#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">	<span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">	node-&gt;next=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skynet-socket-updatetime-网络线程刷新时间"><a href="#skynet-socket-updatetime-网络线程刷新时间" class="headerlink" title="skynet_socket_updatetime 网络线程刷新时间"></a>skynet_socket_updatetime 网络线程刷新时间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">skynet_socket_updatetime</span><span class="params">()</span> &#123;</span><br><span class="line">	socket_server_updatetime(SOCKET_SERVER, skynet_now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">socket_server_updatetime</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="type">uint64_t</span> time)</span> &#123;</span><br><span class="line">	ss-&gt;time = time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，定时器方面的分析，大概完毕，下篇分享thread_socket，skynet网络线程。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>后端 c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始读skynet源码（6）skynet.start服务器启动之后做了什么之thread_socket(skynet网络线程（一）)</title>
    <url>/2021/04/04/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E8%AF%BBskynet%E6%BA%90%E7%A0%81%EF%BC%886%EF%BC%89skynet.start%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%B9%8Bthread_socket(skynet%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89)/</url>
    <content><![CDATA[<span id="more"></span>
<p>接上回，继续分析skynet网络线程。主要分析的是tcp，<br>网络很长很长，需要分两篇分析：<br>1分析别的线程向socket线程发送消息。<br>2分析客户端向socket线程发送消息。<br>网络线程执行代码如下。</p>
<h2 id="socket-server的创建"><a href="#socket-server的创建" class="headerlink" title="socket_server的创建"></a>socket_server的创建</h2><p>skynet_state.c中调用的时候调用skynet_socket_init初始化，这里有一个需要需要的地方，<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_socket_init</span><span class="params">()</span> &#123;</span><br><span class="line">	SOCKET_SERVER = socket_server_create(skynet_now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> socket_server * </span><br><span class="line"><span class="title function_">socket_server_create</span><span class="params">(<span class="type">uint64_t</span> time)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];					<span class="comment">// 声明两个管道，读和写</span></span><br><span class="line">	poll_fd efd = sp_create();	<span class="comment">// 创建epoll</span></span><br><span class="line">	<span class="comment">// 检查epoll是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> (sp_invalid(efd)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: create event pool failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建读、写管道</span></span><br><span class="line">	<span class="keyword">if</span> (pipe(fd)) &#123;</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: create socket pair failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将读管道加入epoll，并监听可读</span></span><br><span class="line">	<span class="keyword">if</span> (sp_add(efd, fd[<span class="number">0</span>], <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">// add recvctrl_fd to event poll</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: can&#x27;t add server fd to event pool.\n&quot;</span>);</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		sp_release(efd);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建socket_server</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> =</span> MALLOC(<span class="keyword">sizeof</span>(*ss));	</span><br><span class="line">	ss-&gt;time = time;			<span class="comment">// 关联创建时间</span></span><br><span class="line">	ss-&gt;event_fd = efd;			<span class="comment">// 关联epoll</span></span><br><span class="line">	ss-&gt;recvctrl_fd = fd[<span class="number">0</span>];	<span class="comment">// 关联读管道</span></span><br><span class="line">	ss-&gt;sendctrl_fd = fd[<span class="number">1</span>];	<span class="comment">// 关联写管道</span></span><br><span class="line">	ss-&gt;checkctrl = <span class="number">1</span>;			<span class="comment">// 将其他线程通知初始化为1，即啊有通知</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个socket_server创建32个socket结构</span></span><br><span class="line">	<span class="comment">// 每个socket都是用于向外部发送消息的</span></span><br><span class="line">	<span class="comment">// 也就是说，别的线程发过来的消息会通过这32个socket结构发出去</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAX_SOCKET;i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> =</span> &amp;ss-&gt;slot[i];</span><br><span class="line">		s-&gt;type = SOCKET_TYPE_INVALID;		<span class="comment">// type 初始化为SOCKET_TYPE_INVALID</span></span><br><span class="line">		clear_wb_list(&amp;s-&gt;high);			<span class="comment">// 清空高优先级列表</span></span><br><span class="line">		clear_wb_list(&amp;s-&gt;low);				<span class="comment">// 清空低优先级列表</span></span><br><span class="line">		spinlock_init(&amp;s-&gt;dw_lock);			<span class="comment">// 自旋锁初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	ss-&gt;alloc_id = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">	ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ss-&gt;soi, <span class="number">0</span>, <span class="keyword">sizeof</span>(ss-&gt;soi));</span><br><span class="line">	FD_ZERO(&amp;ss-&gt;rfds);</span><br><span class="line">	assert(ss-&gt;recvctrl_fd &lt; FD_SETSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="socket线程工作流程"><a href="#socket线程工作流程" class="headerlink" title="socket线程工作流程"></a>socket线程工作流程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ABORT <span class="keyword">if</span> (skynet_context_total()==0) break;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread_socket</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> * <span class="title">m</span> =</span> p;				<span class="comment">// 拿到服务器 monitor</span></span><br><span class="line">	skynet_initthread(THREAD_SOCKET);	<span class="comment">// 设置线程共享变量，标记为网络线程</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">int</span> r = skynet_socket_poll();	<span class="comment">// socket处理</span></span><br><span class="line">		<span class="keyword">if</span> (r==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			CHECK_ABORT					<span class="comment">// 如果socket返回值小于0，判断服务器时候还存在skynet服务</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wakeup(m,<span class="number">0</span>);					<span class="comment">// 如果没有工作线程，则通过条件变量唤醒线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要的socket处理就是skynet_socket_poll，看到skynet_socket_poll。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">skynet_socket_poll</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> *<span class="title">ss</span> =</span> SOCKET_SERVER;			<span class="comment">// 获得socket_server</span></span><br><span class="line">	assert(ss);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_message</span> <span class="title">result</span>;</span>						<span class="comment">// 声明socket消息</span></span><br><span class="line">	<span class="type">int</span> more = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> type = socket_server_poll(ss, &amp;result, &amp;more);	<span class="comment">// 获取消息类型</span></span><br><span class="line">	<span class="comment">// 按照不同的类型处理消息</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_EXIT:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_DATA:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_DATA, <span class="literal">false</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_CLOSE:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_CLOSE, <span class="literal">false</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_OPEN:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_CONNECT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_ERR:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_ERROR, <span class="literal">true</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_ACCEPT:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_ACCEPT, <span class="literal">true</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_UDP:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_UDP, <span class="literal">false</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCKET_WARNING:</span><br><span class="line">		forward_message(SKYNET_SOCKET_TYPE_WARNING, <span class="literal">false</span>, &amp;result);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		skynet_error(<span class="literal">NULL</span>, <span class="string">&quot;Unknown socket message type %d.&quot;</span>,type);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (more) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，就是获取socket消息类型并处理的过程。按照以下顺序分析：<br>1.socket_server的结构、socket的结构，socket消息结构。<br>2.socket_server_poll获取消息类型。<br>3.别的服务发来socket各个消息怎么处理的。</p>
<h2 id="socket相关结构"><a href="#socket相关结构" class="headerlink" title="socket相关结构"></a>socket相关结构</h2><p>先简单看一下相关结构<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket_server.c</span></span><br><span class="line"><span class="comment">// socket write 链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> * <span class="title">next</span>;</span>	</span><br><span class="line">	<span class="type">void</span> *buffer;</span><br><span class="line">	<span class="type">char</span> *ptr;</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="type">bool</span> userobject;</span><br><span class="line">	<span class="type">uint8_t</span> udp_address[UDP_ADDRESS_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZEOF_TCPBUFFER (offsetof(struct write_buffer, udp_address[0]))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZEOF_UDPBUFFER (sizeof(struct write_buffer))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// socket write 链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wb_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> * <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> * <span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_stat</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> rtime;</span><br><span class="line">	<span class="type">uint64_t</span> wtime;</span><br><span class="line">	<span class="type">uint64_t</span> read;</span><br><span class="line">	<span class="type">uint64_t</span> write;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">	<span class="type">uintptr_t</span> opaque;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wb_list</span> <span class="title">high</span>;</span>		<span class="comment">// 高优先级发送队列，wb是write buff</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wb_list</span> <span class="title">low</span>;</span>			<span class="comment">// 低优先级发送队列</span></span><br><span class="line">	<span class="type">int64_t</span> wb_size;			<span class="comment">// 发送字节大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_stat</span> <span class="title">stat</span>;</span>	<span class="comment">// socket 的发送记录</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint32_t</span> sending;	<span class="comment">// </span></span><br><span class="line">	<span class="type">int</span> fd;						<span class="comment">// socket文件描述符</span></span><br><span class="line">	<span class="type">int</span> id;						<span class="comment">// 位于socket_server的slot列表中的位置</span></span><br><span class="line">	<span class="type">uint8_t</span> protocol;			<span class="comment">// tcp or udp</span></span><br><span class="line">	<span class="type">uint8_t</span> type;				<span class="comment">// epoll事件触发时，会根据type来选择处理事件的逻辑</span></span><br><span class="line">	<span class="type">uint16_t</span> udpconnecting;</span><br><span class="line">	<span class="type">int64_t</span> warn_size;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> size;</span><br><span class="line">		<span class="type">uint8_t</span> udp_address[UDP_ADDRESS_SIZE];</span><br><span class="line">	&#125; p;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dw_lock</span>;</span>	<span class="comment">// 自旋锁</span></span><br><span class="line">	<span class="type">int</span> dw_offset;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * dw_buffer;</span><br><span class="line">	<span class="type">size_t</span> dw_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_server</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint64_t</span> time;</span><br><span class="line">	<span class="type">int</span> recvctrl_fd;			<span class="comment">// 接收管道消息的文件描述</span></span><br><span class="line">	<span class="type">int</span> sendctrl_fd;			<span class="comment">// 发送管道消息的文件描述</span></span><br><span class="line">	<span class="type">int</span> checkctrl;				<span class="comment">// 判断是否有其他线程通过管道，向socket线程发送消息的标记变量</span></span><br><span class="line">	poll_fd event_fd;			<span class="comment">// epoll实例id</span></span><br><span class="line">	<span class="type">int</span> alloc_id;				<span class="comment">// 已经分配的socket slot列表id</span></span><br><span class="line">	<span class="type">int</span> event_n;				<span class="comment">// 标记本次epoll事件的数量</span></span><br><span class="line">	<span class="type">int</span> event_index;			<span class="comment">// 下一个未处理的epoll事件索引</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_object_interface</span> <span class="title">soi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev</span>[<span class="title">MAX_EVENT</span>];</span>	<span class="comment">// epoll事件列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">slot</span>[<span class="title">MAX_SOCKET</span>];</span>	<span class="comment">// socket 列表</span></span><br><span class="line">	<span class="type">char</span> buffer[MAX_INFO];			<span class="comment">// 地址信息转成字符串以后，存在这里</span></span><br><span class="line">	<span class="type">uint8_t</span> udpbuffer[MAX_UDP_PACKAGE];</span><br><span class="line">	fd_set rfds;					<span class="comment">// 文件描述符集合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket_server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_message</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;				<span class="comment">// skynet socket_server中32个socket结构中的哪个socket发出的消息</span></span><br><span class="line">	<span class="type">uintptr_t</span> opaque;	<span class="comment">// 哪个skynet服务</span></span><br><span class="line">	<span class="type">int</span> ud;	<span class="comment">// for accept, ud is new connection id ; for data, ud is size of data 如果是accept，ud是连接文件描述符，如果是data，ud是数据大小</span></span><br><span class="line">	<span class="type">char</span> * data;	<span class="comment">// 数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="socket-server-poll获取消息类型"><a href="#socket-server-poll获取消息类型" class="headerlink" title="socket_server_poll获取消息类型"></a>socket_server_poll获取消息类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return type</span></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">socket_server_poll</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket_message * result, <span class="type">int</span> * more)</span> &#123;</span><br><span class="line">	<span class="comment">// 进来就是个死循环</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 是否有其他线程通过管道，向socket线程发送消息</span></span><br><span class="line">		<span class="comment">// 这里是本篇分析</span></span><br><span class="line">		<span class="keyword">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class="line">			<span class="comment">// 判断是否有可读事件，函数之后有分析</span></span><br><span class="line">			<span class="keyword">if</span> (has_cmd(ss)) &#123;</span><br><span class="line">				<span class="type">int</span> type = ctrl_cmd(ss, result);			<span class="comment">// 判断消息类型并返回，函数之后有分析</span></span><br><span class="line">				<span class="keyword">if</span> (type != <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="comment">// 如果获得消息类型，清零标记并返回</span></span><br><span class="line">					clear_closed_event(ss, result, type);</span><br><span class="line">					<span class="keyword">return</span> type;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="comment">// 无法获取类型则继续</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ss-&gt;checkctrl = <span class="number">0</span>;	<span class="comment">// 没有可读事件就重置标志</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 下一个处理的epool事件索引 与 本次epoll事件的数量 是否相等</span></span><br><span class="line">		<span class="comment">// 这里下一篇分析</span></span><br><span class="line">		<span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class="line">			ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class="line">			ss-&gt;checkctrl = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (more) &#123;</span><br><span class="line">				*more = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ss-&gt;event_index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				ss-&gt;event_n = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> =</span> &amp;ss-&gt;ev[ss-&gt;event_index++];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> =</span> e-&gt;s;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// dispatch pipe message at beginning</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">		socket_lock_init(s, &amp;l);</span><br><span class="line">		<span class="keyword">switch</span> (s-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class="line">			<span class="keyword">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class="line">		<span class="keyword">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class="line">			<span class="type">int</span> ok = report_accept(ss, s, result);</span><br><span class="line">			<span class="keyword">if</span> (ok &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> SOCKET_ACCEPT;</span><br><span class="line">			&#125; <span class="keyword">if</span> (ok &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// when ok == 0, retry</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> SOCKET_TYPE_INVALID:</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: invalid socket\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;read) &#123;</span><br><span class="line">				<span class="type">int</span> type;</span><br><span class="line">				<span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">					type = forward_message_tcp(ss, s, &amp;l, result);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					type = forward_message_udp(ss, s, &amp;l, result);</span><br><span class="line">					<span class="keyword">if</span> (type == SOCKET_UDP) &#123;</span><br><span class="line">						<span class="comment">// try read again</span></span><br><span class="line">						--ss-&gt;event_index;</span><br><span class="line">						<span class="keyword">return</span> SOCKET_UDP;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (e-&gt;write &amp;&amp; type != SOCKET_CLOSE &amp;&amp; type != SOCKET_ERR) &#123;</span><br><span class="line">					<span class="comment">// Try to dispatch write message next step if write flag set.</span></span><br><span class="line">					e-&gt;read = <span class="literal">false</span>;</span><br><span class="line">					--ss-&gt;event_index;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">					<span class="keyword">break</span>;				</span><br><span class="line">				<span class="keyword">return</span> type;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;write) &#123;</span><br><span class="line">				<span class="type">int</span> type = send_buffer(ss, s, &amp;l, result);</span><br><span class="line">				<span class="keyword">if</span> (type == <span class="number">-1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">return</span> type;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;error) &#123;</span><br><span class="line">				<span class="comment">// close when error</span></span><br><span class="line">				<span class="type">int</span> error;</span><br><span class="line">				<span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(error);  </span><br><span class="line">				<span class="type">int</span> code = getsockopt(s-&gt;fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len);  </span><br><span class="line">				<span class="type">const</span> <span class="type">char</span> * err = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">if</span> (code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					err = strerror(errno);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">					err = strerror(error);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					err = <span class="string">&quot;Unknown error&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				force_close(ss, s, &amp;l, result);</span><br><span class="line">				result-&gt;data = (<span class="type">char</span> *)err;</span><br><span class="line">				<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(e-&gt;eof) &#123;</span><br><span class="line">				force_close(ss, s, &amp;l, result);</span><br><span class="line">				<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不阻塞判断是否有可读事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">has_cmd</span><span class="params">(<span class="keyword">struct</span> socket_server *ss)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span> =</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;	<span class="comment">// 声明超时时间</span></span><br><span class="line">	<span class="type">int</span> retval;					<span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">	FD_SET(ss-&gt;recvctrl_fd, &amp;ss-&gt;rfds);	<span class="comment">//将读管道描述符加入文件描述符集合</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用select判断是否有可读事件</span></span><br><span class="line">	retval = select(ss-&gt;recvctrl_fd+<span class="number">1</span>, &amp;ss-&gt;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return type</span></span><br><span class="line"><span class="comment">// 获取事件类型</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ctrl_cmd</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd = ss-&gt;recvctrl_fd;	<span class="comment">//拿到读管道描述符</span></span><br><span class="line">	<span class="comment">// the length of message is one byte, so 256+8 buffer size is enough.</span></span><br><span class="line">	<span class="type">uint8_t</span> buffer[<span class="number">256</span>];</span><br><span class="line">	<span class="type">uint8_t</span> header[<span class="number">2</span>];</span><br><span class="line">	block_readpipe(fd, header, <span class="keyword">sizeof</span>(header));	<span class="comment">// 阻塞的读取消息头信息</span></span><br><span class="line">	<span class="type">int</span> type = header[<span class="number">0</span>];						<span class="comment">// 从头信息获取消息类型</span></span><br><span class="line">	<span class="type">int</span> len = header[<span class="number">1</span>];						<span class="comment">// 从头信息获取消息长度</span></span><br><span class="line">	block_readpipe(fd, buffer, len);			<span class="comment">// 阻塞读取消息内容 </span></span><br><span class="line">	<span class="comment">// ctrl command only exist in local fd, so don&#x27;t worry about endian.</span></span><br><span class="line">	<span class="comment">// 按照类型处理消息，下面会逐一分析各个函数</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> start_socket(ss,(<span class="keyword">struct</span> request_start *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> bind_socket(ss,(<span class="keyword">struct</span> request_bind *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> listen_socket(ss,(<span class="keyword">struct</span> request_listen *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> close_socket(ss,(<span class="keyword">struct</span> request_close *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> open_socket(ss, (<span class="keyword">struct</span> request_open *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">		result-&gt;opaque = <span class="number">0</span>;</span><br><span class="line">		result-&gt;id = <span class="number">0</span>;</span><br><span class="line">		result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">		result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_EXIT;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">int</span> priority = (type == <span class="string">&#x27;D&#x27;</span>) ? PRIORITY_HIGH : PRIORITY_LOW;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_send</span> * <span class="title">request</span> =</span> (<span class="keyword">struct</span> request_send *) buffer;</span><br><span class="line">		<span class="type">int</span> ret = send_socket(ss, request, result, priority, <span class="literal">NULL</span>);</span><br><span class="line">		dec_sending_ref(ss, request-&gt;id);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_send_udp</span> * <span class="title">rsu</span> =</span> (<span class="keyword">struct</span> request_send_udp *)buffer;</span><br><span class="line">		<span class="keyword">return</span> send_socket(ss, &amp;rsu-&gt;send, result, PRIORITY_HIGH, rsu-&gt;address);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> set_udp_address(ss, (<span class="keyword">struct</span> request_setudp *)buffer, result);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">		setopt_socket(ss, (<span class="keyword">struct</span> request_setopt *)buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">		add_udp_socket(ss, (<span class="keyword">struct</span> request_udp *)buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: Unknown ctrl %c.\n&quot;</span>,type);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="别的服务发过来-socket-各个消息类型的处理"><a href="#别的服务发过来-socket-各个消息类型的处理" class="headerlink" title="别的服务发过来 socket 各个消息类型的处理"></a>别的服务发过来 socket 各个消息类型的处理</h2><p>这里按照open—-&gt;listen—-&gt;bind—-&gt;start—-&gt;再往后分析</p>
<h3 id="open-socket"><a href="#open-socket" class="headerlink" title="open_socket"></a>open_socket</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求opensocket的消息类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_open</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> port;</span><br><span class="line">	<span class="type">uintptr_t</span> opaque;</span><br><span class="line">	<span class="type">char</span> host[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return -1 when connecting</span></span><br><span class="line"><span class="comment">// 一个新的连接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_open * request, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;					<span class="comment">// 获取id</span></span><br><span class="line">	result-&gt;opaque = request-&gt;opaque;		<span class="comment">// 绑定这个socket对应的skynet服务</span></span><br><span class="line">	result-&gt;id = id;						<span class="comment">// 绑定定位于socket_server的slot列表中的位置</span></span><br><span class="line">	result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">	result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">ns</span>;</span>						<span class="comment">// 声明一个socket结构</span></span><br><span class="line">	<span class="type">int</span> status;								<span class="comment">// 声明一个变量待会用来接收返回值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">ai_hints</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> port[<span class="number">16</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(port, <span class="string">&quot;%d&quot;</span>, request-&gt;port);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ai_hints, <span class="number">0</span>, <span class="keyword">sizeof</span>( ai_hints ) );</span><br><span class="line">	ai_hints.ai_family = AF_UNSPEC;</span><br><span class="line">	ai_hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	ai_hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针</span></span><br><span class="line">	status = getaddrinfo( request-&gt;host, port, &amp;ai_hints, &amp;ai_list );</span><br><span class="line">	<span class="keyword">if</span> ( status != <span class="number">0</span> ) &#123;</span><br><span class="line">		result-&gt;data = (<span class="type">void</span> *)gai_strerror(status);	<span class="comment">//如果失败收集错误信息</span></span><br><span class="line">		<span class="keyword">goto</span> _failed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sock= <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// 遍历addrinfo链表</span></span><br><span class="line">	<span class="keyword">for</span> (ai_ptr = ai_list; ai_ptr != <span class="literal">NULL</span>; ai_ptr = ai_ptr-&gt;ai_next ) &#123;</span><br><span class="line">		<span class="comment">// 根据信息，创建socket文件描述符</span></span><br><span class="line">		sock = socket( ai_ptr-&gt;ai_family, ai_ptr-&gt;ai_socktype, ai_ptr-&gt;ai_protocol );</span><br><span class="line">		<span class="keyword">if</span> ( sock &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		socket_keepalive(sock);	<span class="comment">// 设置为keepalive会自动发送心跳包检测</span></span><br><span class="line">		sp_nonblocking(sock);	<span class="comment">// 设置非阻塞</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 建立socket连接</span></span><br><span class="line">		status = connect( sock, ai_ptr-&gt;ai_addr, ai_ptr-&gt;ai_addrlen);</span><br><span class="line">		<span class="keyword">if</span> ( status != <span class="number">0</span> &amp;&amp; errno != EINPROGRESS) &#123;</span><br><span class="line">			close(sock);</span><br><span class="line">			sock = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		result-&gt;data = strerror(errno);</span><br><span class="line">		<span class="keyword">goto</span> _failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个socket结构，关联到epoll</span></span><br><span class="line">	ns = new_fd(ss, id, sock, PROTOCOL_TCP, request-&gt;opaque, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		close(sock);</span><br><span class="line">		result-&gt;data = <span class="string">&quot;reach skynet socket number limit&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> _failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(status == <span class="number">0</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		ns-&gt;type = SOCKET_TYPE_CONNECTED;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> * <span class="title">addr</span> =</span> ai_ptr-&gt;ai_addr;</span><br><span class="line">		<span class="type">void</span> * sin_addr = (ai_ptr-&gt;ai_family == AF_INET) ? (<span class="type">void</span>*)&amp;((<span class="keyword">struct</span> sockaddr_in *)addr)-&gt;sin_addr : (<span class="type">void</span>*)&amp;((<span class="keyword">struct</span> sockaddr_in6 *)addr)-&gt;sin6_addr;</span><br><span class="line">		<span class="keyword">if</span> (inet_ntop(ai_ptr-&gt;ai_family, sin_addr, ss-&gt;buffer, <span class="keyword">sizeof</span>(ss-&gt;buffer))) &#123;</span><br><span class="line">			result-&gt;data = ss-&gt;buffer;</span><br><span class="line">		&#125;</span><br><span class="line">		freeaddrinfo( ai_list );</span><br><span class="line">		<span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ns-&gt;type = SOCKET_TYPE_CONNECTING;</span><br><span class="line">		sp_write(ss-&gt;event_fd, ns-&gt;fd, ns, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freeaddrinfo( ai_list );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">_failed:</span><br><span class="line">	freeaddrinfo( ai_list );</span><br><span class="line">	ss-&gt;slot[HASH_ID(id)].type = SOCKET_TYPE_INVALID;</span><br><span class="line">	<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为一个新的连接创建一个epool</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *</span><br><span class="line"><span class="title function_">new_fd</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="type">int</span> id, <span class="type">int</span> fd, <span class="type">int</span> protocol, <span class="type">uintptr_t</span> opaque, <span class="type">bool</span> add)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">s</span> =</span> &amp;ss-&gt;slot[HASH_ID(id)];</span><br><span class="line">	assert(s-&gt;type == SOCKET_TYPE_RESERVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是add，则添加对fd监听读事件</span></span><br><span class="line">	<span class="keyword">if</span> (add) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp_add(ss-&gt;event_fd, fd, s)) &#123;</span><br><span class="line">			<span class="comment">// 监听失败处理</span></span><br><span class="line">			s-&gt;type = SOCKET_TYPE_INVALID;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s-&gt;id = id;								<span class="comment">// 绑定solt中的位置</span></span><br><span class="line">	s-&gt;fd = fd;								<span class="comment">// 绑定fd</span></span><br><span class="line">	s-&gt;sending = ID_TAG16(id) &lt;&lt; <span class="number">16</span> | <span class="number">0</span>;	</span><br><span class="line">	s-&gt;protocol = protocol;					<span class="comment">// 协议</span></span><br><span class="line">	s-&gt;p.size = MIN_READ_BUFFER;		</span><br><span class="line">	s-&gt;opaque = opaque;						<span class="comment">// 绑定skynet服务</span></span><br><span class="line">	s-&gt;wb_size = <span class="number">0</span>;</span><br><span class="line">	s-&gt;warn_size = <span class="number">0</span>;</span><br><span class="line">	check_wb_list(&amp;s-&gt;high);				<span class="comment">// 清空高优先级队列</span></span><br><span class="line">	check_wb_list(&amp;s-&gt;low);					<span class="comment">// 清空低优先级队列</span></span><br><span class="line">	s-&gt;dw_buffer = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;dw_size = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;s-&gt;stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(s-&gt;stat));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="listen-socket"><a href="#listen-socket" class="headerlink" title="listen_socket"></a>listen_socket</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_listen</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uintptr_t</span> opaque;</span><br><span class="line">	<span class="type">char</span> host[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">listen_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_listen * request, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;				<span class="comment">// 获取id</span></span><br><span class="line">	<span class="type">int</span> listen_fd = request-&gt;fd;		<span class="comment">// 获取fd</span></span><br><span class="line">	<span class="comment">// 这个上面已分析</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> =</span> new_fd(ss, id, listen_fd, PROTOCOL_TCP, request-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> _failed;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;type = SOCKET_TYPE_PLISTEN;		<span class="comment">// 记录类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">_failed:</span><br><span class="line">	close(listen_fd);</span><br><span class="line">	result-&gt;opaque = request-&gt;opaque;</span><br><span class="line">	result-&gt;id = id;</span><br><span class="line">	result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">	result-&gt;data = <span class="string">&quot;reach skynet socket number limit&quot;</span>;</span><br><span class="line">	ss-&gt;slot[HASH_ID(id)].type = SOCKET_TYPE_INVALID;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind-socket"><a href="#bind-socket" class="headerlink" title="bind_socket"></a>bind_socket</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_bind</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uintptr_t</span> opaque;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">bind_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_bind *request, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;				<span class="comment">// 获取请求的id</span></span><br><span class="line">	result-&gt;id = id;					<span class="comment">// 绑定id</span></span><br><span class="line">	result-&gt;opaque = request-&gt;opaque;	<span class="comment">// 绑定服务</span></span><br><span class="line">	result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个函数上面分析过了</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> =</span> new_fd(ss, id, request-&gt;fd, PROTOCOL_TCP, request-&gt;opaque, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		result-&gt;data = <span class="string">&quot;reach skynet socket number limit&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">	&#125;</span><br><span class="line">	sp_nonblocking(request-&gt;fd);	<span class="comment">// 设置非阻塞</span></span><br><span class="line">	s-&gt;type = SOCKET_TYPE_BIND;		<span class="comment">// 设置类型</span></span><br><span class="line">	result-&gt;data = <span class="string">&quot;binding&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="start-socket"><a href="#start-socket" class="headerlink" title="start_socket"></a>start_socket</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket 开始工作</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">start_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_start *request, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;						<span class="comment">// 从接受到的消息获取id</span></span><br><span class="line">	result-&gt;id = id;							<span class="comment">// 绑定位于socket_server的slot列表中的位置</span></span><br><span class="line">	result-&gt;opaque = request-&gt;opaque;			<span class="comment">// 绑定与本socket关联的服务地址</span></span><br><span class="line">	result-&gt;ud = <span class="number">0</span>;								<span class="comment">// ud设置为0</span></span><br><span class="line">	result-&gt;data = <span class="literal">NULL</span>;						<span class="comment">// data为 null</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">s</span> =</span> &amp;ss-&gt;slot[HASH_ID(id)];	<span class="comment">// 将id进行hash并存贮</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否为无效的socket</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID || s-&gt;id !=id) &#123;</span><br><span class="line">		result-&gt;data = <span class="string">&quot;invalid socket&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">	socket_lock_init(s, &amp;l);</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_PACCEPT || s-&gt;type == SOCKET_TYPE_PLISTEN) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp_add(ss-&gt;event_fd, s-&gt;fd, s)) &#123;</span><br><span class="line">			force_close(ss, s, &amp;l, result);</span><br><span class="line">			result-&gt;data = strerror(errno);</span><br><span class="line">			<span class="keyword">return</span> SOCKET_ERR;</span><br><span class="line">		&#125;</span><br><span class="line">		s-&gt;type = (s-&gt;type == SOCKET_TYPE_PACCEPT) ? SOCKET_TYPE_CONNECTED : SOCKET_TYPE_LISTEN;</span><br><span class="line">		s-&gt;opaque = request-&gt;opaque;</span><br><span class="line">		result-&gt;data = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_CONNECTED) &#123;</span><br><span class="line">		<span class="comment">// todo: maybe we should send a message SOCKET_TRANSFER to s-&gt;opaque</span></span><br><span class="line">		s-&gt;opaque = request-&gt;opaque;</span><br><span class="line">		result-&gt;data = <span class="string">&quot;transfer&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_OPEN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if s-&gt;type == SOCKET_TYPE_HALFCLOSE , SOCKET_CLOSE message will send later</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="close-socket"><a href="#close-socket" class="headerlink" title="close_socket"></a>close_socket</h3><p>这里我们还需要额外看一看两个方法sp_write，force_close<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_close</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> shutdown;</span><br><span class="line">	<span class="type">uintptr_t</span> opaque;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断发送队列是否为空</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_buffer_empty</span><span class="params">(<span class="keyword">struct</span> socket *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (s-&gt;high.head == <span class="literal">NULL</span> &amp;&amp; s-&gt;low.head == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否还有消息</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nomore_sending_data</span><span class="params">(<span class="keyword">struct</span> socket *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> send_buffer_empty(s) &amp;&amp; s-&gt;dw_buffer == <span class="literal">NULL</span> &amp;&amp; (s-&gt;sending &amp; <span class="number">0xffff</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">close_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_close *request, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;							<span class="comment">// 获取id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">s</span> =</span> &amp;ss-&gt;slot[HASH_ID(id)];		<span class="comment">// 获取socket结构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已经是无效的socket</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID || s-&gt;id != id) &#123;</span><br><span class="line">		result-&gt;id = id;</span><br><span class="line">		result-&gt;opaque = request-&gt;opaque;</span><br><span class="line">		result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">		result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_lock</span> <span class="title">l</span>;</span></span><br><span class="line">	socket_lock_init(s, &amp;l);	<span class="comment">// 读写锁</span></span><br><span class="line">	<span class="keyword">if</span> (!nomore_sending_data(s)) &#123;</span><br><span class="line">		<span class="comment">// 如果还有消息没发送则发送完</span></span><br><span class="line">		<span class="type">int</span> type = send_buffer(ss,s,&amp;l,result);</span><br><span class="line">		<span class="comment">// type : -1 or SOCKET_WARNING or SOCKET_CLOSE, SOCKET_WARNING means nomore_sending_data</span></span><br><span class="line">		<span class="keyword">if</span> (type != <span class="number">-1</span> &amp;&amp; type != SOCKET_WARNING)</span><br><span class="line">			<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (request-&gt;shutdown || nomore_sending_data(s)) &#123;</span><br><span class="line">		<span class="comment">// 没有消息了，可以关闭</span></span><br><span class="line">		force_close(ss,s,&amp;l,result);</span><br><span class="line">		result-&gt;id = id;</span><br><span class="line">		result-&gt;opaque = request-&gt;opaque;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;type = SOCKET_TYPE_HALFCLOSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Each socket has two write buffer list, high priority and low priority.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	1. send high list as far as possible.</span></span><br><span class="line"><span class="comment">	2. If high list is empty, try to send low list.</span></span><br><span class="line"><span class="comment">	3. If low list head is uncomplete (send a part before), move the head of low list to empty high list (call raise_uncomplete) .</span></span><br><span class="line"><span class="comment">	4. If two lists are both empty, turn off the event. (call check_close)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_buffer_</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket *s, <span class="keyword">struct</span> socket_lock *l, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	assert(!list_uncomplete(&amp;s-&gt;low));</span><br><span class="line">	<span class="comment">// step 1</span></span><br><span class="line">	<span class="keyword">if</span> (send_list(ss,s,&amp;s-&gt;high,l,result) == SOCKET_CLOSE) &#123;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;high.head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// step 2</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;low.head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (send_list(ss,s,&amp;s-&gt;low,l,result) == SOCKET_CLOSE) &#123;</span><br><span class="line">				<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// step 3</span></span><br><span class="line">			<span class="keyword">if</span> (list_uncomplete(&amp;s-&gt;low)) &#123;</span><br><span class="line">				raise_uncomplete(s);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;low.head)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// step 4</span></span><br><span class="line">		assert(send_buffer_empty(s) &amp;&amp; s-&gt;wb_size == <span class="number">0</span>);</span><br><span class="line">		sp_write(ss-&gt;event_fd, s-&gt;fd, s, <span class="literal">false</span>);			</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_HALFCLOSE) &#123;</span><br><span class="line">				force_close(ss, s, l, result);</span><br><span class="line">				<span class="keyword">return</span> SOCKET_CLOSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;warn_size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				s-&gt;warn_size = <span class="number">0</span>;</span><br><span class="line">				result-&gt;opaque = s-&gt;opaque;</span><br><span class="line">				result-&gt;id = s-&gt;id;</span><br><span class="line">				result-&gt;ud = <span class="number">0</span>;</span><br><span class="line">				result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">return</span> SOCKET_WARNING;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">sp_write</span><span class="params">(<span class="type">int</span> efd, <span class="type">int</span> sock, <span class="type">void</span> *ud, <span class="type">bool</span> enable)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">	ev.events = EPOLLIN | (enable ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line">	ev.data.ptr = ud;</span><br><span class="line">	epoll_ctl(efd, EPOLL_CTL_MOD, sock, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">force_close</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket *s, <span class="keyword">struct</span> socket_lock *l, <span class="keyword">struct</span> socket_message *result)</span> &#123;</span><br><span class="line">	result-&gt;id = s-&gt;id;				<span class="comment">// 关联id</span></span><br><span class="line">	result-&gt;ud = <span class="number">0</span>;					</span><br><span class="line">	result-&gt;data = <span class="literal">NULL</span>;	</span><br><span class="line">	result-&gt;opaque = s-&gt;opaque;		<span class="comment">// 关联服务</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(s-&gt;type != SOCKET_TYPE_RESERVE);</span><br><span class="line">	free_wb_list(ss,&amp;s-&gt;high);		<span class="comment">// 清空高优先级队列</span></span><br><span class="line">	free_wb_list(ss,&amp;s-&gt;low);		<span class="comment">// 清空低优先级队列</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type != SOCKET_TYPE_PACCEPT &amp;&amp; s-&gt;type != SOCKET_TYPE_PLISTEN) &#123;</span><br><span class="line">		sp_del(ss-&gt;event_fd, s-&gt;fd);	<span class="comment">//删除对fd的监听</span></span><br><span class="line">	&#125;</span><br><span class="line">	socket_lock(l);						<span class="comment">// 上锁</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type != SOCKET_TYPE_BIND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (close(s-&gt;fd) &lt; <span class="number">0</span>) &#123;			<span class="comment">// 关闭fd</span></span><br><span class="line">			perror(<span class="string">&quot;close socket:&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;type = SOCKET_TYPE_INVALID;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;dw_buffer) &#123;</span><br><span class="line">		free_buffer(ss, s-&gt;dw_buffer, s-&gt;dw_size);	<span class="comment">//释放buff</span></span><br><span class="line">		s-&gt;dw_buffer = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	socket_unlock(l);					<span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="send-socket"><a href="#send-socket" class="headerlink" title="send_socket"></a>send_socket</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	When send a package , we can assign the priority : PRIORITY_HIGH or PRIORITY_LOW</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	If socket buffer is empty, write to fd directly.</span></span><br><span class="line"><span class="comment">		If write a part, append the rest part to high list. (Even priority is PRIORITY_LOW)</span></span><br><span class="line"><span class="comment">	Else append package to high (PRIORITY_HIGH) or low (PRIORITY_LOW) list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_send</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="type">char</span> * buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">send_object</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * buffer;</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="type">void</span> (*free_func)(<span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_socket</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> request_send * request, <span class="keyword">struct</span> socket_message *result, <span class="type">int</span> priority, <span class="type">const</span> <span class="type">uint8_t</span> *udp_address)</span> &#123;</span><br><span class="line">	<span class="type">int</span> id = request-&gt;id;						<span class="comment">// 获取id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">s</span> =</span> &amp;ss-&gt;slot[HASH_ID(id)];	<span class="comment">// 获取socket 结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">send_object</span> <span class="title">so</span>;</span>						<span class="comment">// 声明发送对象</span></span><br><span class="line">	send_object_init(ss, &amp;so, request-&gt;buffer, request-&gt;sz);</span><br><span class="line">	<span class="comment">// 判断socket是否是无效</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_INVALID || s-&gt;id != id </span><br><span class="line">		|| s-&gt;type == SOCKET_TYPE_HALFCLOSE</span><br><span class="line">		|| s-&gt;type == SOCKET_TYPE_PACCEPT) &#123;</span><br><span class="line">		so.free_func(request-&gt;buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否是listen类型socket</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;type == SOCKET_TYPE_PLISTEN || s-&gt;type == SOCKET_TYPE_LISTEN) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: write to listen fd %d.\n&quot;</span>, id);</span><br><span class="line">		so.free_func(request-&gt;buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没有数据，或者是连接中的socket</span></span><br><span class="line">	<span class="keyword">if</span> (send_buffer_empty(s) &amp;&amp; s-&gt;type == SOCKET_TYPE_CONNECTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">			append_sendbuffer(ss, s, request);	<span class="comment">// add to high priority list, even priority == PRIORITY_LOW</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// udp</span></span><br><span class="line">			<span class="keyword">if</span> (udp_address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				udp_address = s-&gt;p.udp_address;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="class"><span class="keyword">union</span> <span class="title">sockaddr_all</span> <span class="title">sa</span>;</span></span><br><span class="line">			<span class="type">socklen_t</span> sasz = udp_socket_address(s, udp_address, &amp;sa);</span><br><span class="line">			<span class="keyword">if</span> (sasz == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// udp type mismatch, just drop it.</span></span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket-server: udp socket (%d) type mistach.\n&quot;</span>, id);</span><br><span class="line">				so.free_func(request-&gt;buffer);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> n = sendto(s-&gt;fd, so.buffer, so.sz, <span class="number">0</span>, &amp;sa.s, sasz);</span><br><span class="line">			<span class="keyword">if</span> (n != so.sz) &#123;</span><br><span class="line">				append_sendbuffer_udp(ss,s,priority,request,udp_address);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				stat_write(ss,s,n);</span><br><span class="line">				so.free_func(request-&gt;buffer);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sp_write(ss-&gt;event_fd, s-&gt;fd, s, <span class="literal">true</span>);	<span class="comment">// 监听写就绪事件</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 正常的可以直接发送的socket</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;protocol == PROTOCOL_TCP) &#123;</span><br><span class="line">			<span class="comment">// 如果是tcp，按照队列优先级添加</span></span><br><span class="line">			<span class="keyword">if</span> (priority == PRIORITY_LOW) &#123;</span><br><span class="line">				append_sendbuffer_low(ss, s, request);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				append_sendbuffer(ss, s, request);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (udp_address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				udp_address = s-&gt;p.udp_address;</span><br><span class="line">			&#125;</span><br><span class="line">			append_sendbuffer_udp(ss,s,priority,request,udp_address);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果发送的包太大，则报一个警告</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;wb_size &gt;= WARNING_SIZE &amp;&amp; s-&gt;wb_size &gt;= s-&gt;warn_size) &#123;</span><br><span class="line">		s-&gt;warn_size = s-&gt;warn_size == <span class="number">0</span> ? WARNING_SIZE *<span class="number">2</span> : s-&gt;warn_size*<span class="number">2</span>;</span><br><span class="line">		result-&gt;opaque = s-&gt;opaque;</span><br><span class="line">		result-&gt;id = s-&gt;id;</span><br><span class="line">		result-&gt;ud = s-&gt;wb_size%<span class="number">1024</span> == <span class="number">0</span> ? s-&gt;wb_size/<span class="number">1024</span> : s-&gt;wb_size/<span class="number">1024</span> + <span class="number">1</span>;</span><br><span class="line">		result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> SOCKET_WARNING;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送对象初始化</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">send_object_init</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> send_object *so, <span class="type">void</span> *object, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (sz &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		so-&gt;buffer = ss-&gt;soi.buffer(object);</span><br><span class="line">		so-&gt;sz = ss-&gt;soi.size(object);</span><br><span class="line">		so-&gt;free_func = ss-&gt;soi.<span class="built_in">free</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		so-&gt;buffer = object;</span><br><span class="line">		so-&gt;sz = sz;</span><br><span class="line">		so-&gt;free_func = FREE;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到发送队列</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">append_sendbuffer</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket *s, <span class="keyword">struct</span> request_send * request)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> *<span class="title">buf</span> =</span> append_sendbuffer_(ss, &amp;s-&gt;high, request, SIZEOF_TCPBUFFER);</span><br><span class="line">	s-&gt;wb_size += buf-&gt;sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> write_buffer *</span><br><span class="line"><span class="title function_">append_sendbuffer_</span><span class="params">(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> wb_list *s, <span class="keyword">struct</span> request_send * request, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">write_buffer</span> * <span class="title">buf</span> =</span> MALLOC(size);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">send_object</span> <span class="title">so</span>;</span></span><br><span class="line">	buf-&gt;userobject = send_object_init(ss, &amp;so, request-&gt;buffer, request-&gt;sz);</span><br><span class="line">	buf-&gt;ptr = (<span class="type">char</span>*)so.buffer;</span><br><span class="line">	buf-&gt;sz = so.sz;</span><br><span class="line">	buf-&gt;buffer = request-&gt;buffer;</span><br><span class="line">	buf-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		s-&gt;head = s-&gt;tail = buf;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(s-&gt;tail != <span class="literal">NULL</span>);</span><br><span class="line">		assert(s-&gt;tail-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">		s-&gt;tail-&gt;next = buf;</span><br><span class="line">		s-&gt;tail = buf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，别的线程发送到网络线程的消息已经大概分析完毕，下篇分析客户端发过来数据，网络线程怎么处理。</p>
]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>使用redis做排行榜相同积分情况下，如何使用到达时间来排序</title>
    <url>/2020/07/07/%E4%BD%BF%E7%94%A8redis%E5%81%9A%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9B%B8%E5%90%8C%E7%A7%AF%E5%88%86%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%B0%E8%BE%BE%E6%97%B6%E9%97%B4%E6%9D%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<span id="more"></span>
<p>       好久没更新博客了，杂事多，其实还是就是自己懒惰了吧。哈哈哈哈。言归正传。</p>

<p>       最近需求撸了个排行榜，是用redis实现的，依稀记得，前几个月去面试的时候，面试官老喜欢问我做过排行榜么，做过排行榜么，那时候还没做过，也知道是redis做的，以为会有点难度，但是其实并不难。技术就是这样的，不知道就难，知道了就简单，消除恐惧的最好方法就是面对恐惧，奥里给！</p>

<p>      <strong> redis的有序集合(sorted set)，会元素都会关联一个double类型的分数。然后通过分数来为集合中的成员进行从小到大的排序。</strong>简直就是天生为排行榜设计的，但是有序集合(sorted set)在元素积分相同的情况下居然是<strong>字典排序</strong>(就是同分数的情况下，使用我们存贮的元素进行排序)，这就不符合我们理想中的排行榜了。</p>

<p>       <strong>改进如下：</strong></p>

<p>       <strong>我们只需要在玩家的积分上关联上时间即可，例如：存入的数据为{uid，score}</strong></p>

<p>       1.我们需要拿到一个时间来做标准，可以是排行榜的结束时间或者是任何别的时间。我使用的是结束时间的时间戳(end_time)。</p>

<p>       2.对score进行处理，<strong>new_score = score &lt;&lt; 26 + (end_time - now)</strong>。进行位操作之后再加上时间戳。这样相同积分的情况下，越后面到达的存入的，处理之后的new_score越小。</p>

<p>       3.存入redis的数据为{uid, new_socre}。</p>

<p>       4.因为是使用了位操作，当需要显示积分的时候，<strong>new_score &gt;&gt;26即会剔除掉时间戳，显示积分。</strong></p>

<p>       因为是使用了位操作并且关联了时间戳，在分数上相同的概率就会很小很小了。但是这样做也是有缺陷的，<strong>即相同时间到达相同积分的，还是会按照元素进行字典排序，不过无关紧要，这种概率很低。</strong>我的需求在这种情况下相同的话，是可以按照uid排序的，所以也没有再进一步优化。如果哪位同行看到了，有更好的方法也欢迎分享。</p>

<p> </p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 面试</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql存贮json与json中数据的检索</title>
    <url>/2019/10/24/%E5%85%B3%E4%BA%8Emysql%E5%AD%98%E8%B4%AEjson%E4%B8%8Ejson%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<span id="more"></span>
<p>      这两天工作，碰到一个实用的mysql存贮json问题，需要查找mysql中存贮的json中的json作此记录。</p>

<p>      因为mysql是关系型数据库，所以如果想在一个key中存贮更多的数据，存贮一个json是不错的选择(支持存贮多层的json)。</p>

<p>     </p>

<p>       我用到的activity_conf表格中activity_config中存贮的就是json。</p>

<pre class="has">
<code class="language-sql">DROP TABLE IF EXISTS `activity_conf`;
CREATE TABLE `activity_conf` (
  `activity_id` char(64) COLLATE utf8mb4_general_ci NOT NULL COMMENT '活动ID',
  `activity_config` json DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</code></pre>

<p>      我需要获取 activity_config中存贮的end_time，而end_time是两层json如下</p>

<p><img alt class="has" height="461" src="https://img-blog.csdnimg.cn/20191024151315801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="780"></p>

<p>     可用以下语句</p>

<pre class="has">
<code class="language-sql">select activity_id, json_extract(activity_config, '$.end_time.conf_value') as end_time from activity_conf;</code></pre>

<p>     查找结果如下</p>

<p><img alt class="has" height="418" src="https://img-blog.csdnimg.cn/20191024154502932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="959"></p>

<h3>    <strong> 可以使用以下语句查找mysql中存贮的json数据：</strong></h3>

<pre class="has">
<code class="language-sql">select json_extract( key, '$.fir_json_key.sec_json_key') from table;</code></pre>

<p>       打完收工</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql存json</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql存贮json与json中数据的求和计算</title>
    <url>/2019/09/16/%E5%85%B3%E4%BA%8Emysql%E5%AD%98%E8%B4%AEjson%E4%B8%8Ejson%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B1%82%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<span id="more"></span>
<p>      mysql是关系型数据库，为了方便的记录更多的数据，现在工作中用的mysql记录得value是以json的形式记录的。</p>

<p>      例如：</p>

<p>      player_data表格结构是这样的：       </p>

<pre class="has">
<code class="language-sql">DROP TABLE IF EXISTS `player_data`;
CREATE TABLE `player_data` (
  `uid` bigint(20) NOT NULL COMMENT '用户ID',
  `data` json NOT NULL COMMENT '游戏数据，以json形式包含',
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</code></pre>

<p>      player_data中玩家的数据是这样记录的：</p>

<p>      key:uid --- value:{"data": { "user_prize": 0}</p>

<p>      我需要计算所有玩家user_prize的总和，这样即可</p>

<pre class="has">
<code class="language-sql">select sum(data-&gt;"$.user_prize") from player_data where data-&gt;"$.user_prize" is not null</code></pre>

<p><img alt class="has" height="186" src="https://img-blog.csdnimg.cn/2019091620004713.png" width="1078"></p>

<p>       mysql中存贮json，应用十分的强大，不仅可以存贮单层的key(如上)，还可以可以存贮多层的key，关于多层key的应用之后在更新。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql json</tag>
      </tags>
  </entry>
  <entry>
    <title>关于游戏开发中玩家默认数据的一些记录</title>
    <url>/2019/12/08/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%8E%A9%E5%AE%B6%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<p>      博主最近的工作是开发游戏的任务系统。领导看了我的代码后，给我提出了一些意见。</p>

<p>      任务情况大概是这样的，一个玩家登陆后，客户端会显示任务按钮，玩家点击后即可查看自己的任务。按照策划的需求，玩家目前有十几个任务。每个玩家的任务数据，都要记录在DB（数据库）中。</p>

<p>      我最开始的做法是：</p>

<p>      1.如果游戏开启了任务系统，当玩家登陆的时候，我会给每个任务都分配默认值。</p>

<p>      2.将这些默认值都记录进db中。</p>

<p>      3.在玩家点开任务图标时，客户端请求玩家的任务数据，服务器返回。</p>

<p>      在偶然的情况下，虽然我得代码也能实现功能，但领导发现了我的代码会瞬间做很多的db操作，然后告诉我内容大概如下：“<strong>一般db操作就是我们服务器的瓶颈之一，可以不用一开始就给每个任务分配默认值，并记录进db。客户端请求的时候，直接返回一个默认值，当玩家参与了具体任务时，再对玩家的数据进行计算，并记录入数据库。</strong>”，</p>

<p>      我之后进行思考觉得太tm有道理了。</p>

<p>      <strong>1.可能有的玩家只登陆了一次，点开了任务图标，但是并且不做任务，我会在他点开图标时给他记录全部任务数据（默认值）。</strong></p>

<p><strong>      2.可能有的玩家登陆了，只做了一个任务，之后便不玩了，但是我会在他点开图标时给他记录全部任务数据（默认值）。</strong></p>

<p><strong>      3.一瞬间，很多玩家首次点开任务图标，会造成瞬间很多很多的db操作。</strong></p>

<p>      。。。。</p>

<p>      太多的理由表明这是一个很糟糕的设计。</p>

<p>      我在思考后，将程序改动整理后表达大概如下：</p>

<p>    <strong> 1.玩家点开任务图标，客户端请求任务数据时，如果数据库中没有记录玩家的数据，直接返回一个默认的值。例如：任务为杀1000只青蛙，直接则返回0只，并不用记录到db中</strong></p>

<p><strong>     2.当玩家参与到具体的任务时，再记录到db。例如：玩家现在杀了100只青蛙，则将100记录到db中。等到玩家下次点开任务图标时，返回存贮再db中的100。</strong></p>

<p><strong>     这样修改后，一开始那些默认的各种任务的默认值都不会写入db，即使有的玩家之登录一次，也点开了任务系统，也不会记录他的数据到db，一瞬间很多玩家首次点开任务系统，也不会有大量的数据瞬间要写入db。</strong></p>

<p> </p>

<p><strong>     </strong>做此纪录，我可能还是有一些地方设计得不够好，欢迎相互讨论。</p>
]]></content>
      <categories>
        <category>笔记 随笔</category>
      </categories>
      <tags>
        <tag>游戏开发 玩家数据</tag>
      </tags>
  </entry>
  <entry>
    <title>关于游戏开发数据更新的一些记录</title>
    <url>/2019/11/17/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<p>      博主入职做游戏到现在已经是7个月的时间，框架是skynet，这段时间内，我大多写的都是游戏的活动，任务。其中这些东西都是有有效期限制的。</p>

<p>      比如，活动是每日重新统计，每日任务是每天重新统计，每周任务是每周一的 00:00重新统计。那么就需要一个特定时间来reset用户的数据。</p>

<p> </p>

<p>      我刚开始的做法是，每天的 00:00，reset玩家的每日活动数据，每日任务数据。有一次我向我的经理请教问题的时候，他看了我的代码，对我的代码的评价大概是：<strong>你这么写也没什么错误，也没什么问题，但是可能会多出很多没必要的运算，比如一个玩家，他今天登陆了，之后三四天都没有登陆，但是你在这三四天也会去reset他的数据，如果有一个玩家，登陆了一次之后，再也不登陆了，你也会去reset他的数据。这样会多处很多没必要的db操作，玩家数量一上来，处理量就大了。</strong>我一听，觉得太tm的有道理了，经理果然不一样 = =！，牛逼，之后他对我进行了一下指点，做以下记录：</p>

<p>     <strong> 1.lazy update(好像是这么叫的)，需要reset数据时，再去reset，这样可以减少很多db操作。</strong></p>

<p><strong>      2.每日任务，每日活动则记录玩家的参加活动时间(任务时间)，当要更新活动或者任务时，再去判断当前时间与活动时间(任务时间)是否为同一天，如果是同一天，则不用reset，如果不是同一天，则reset玩家的活动与任务数据，并更新玩家的上次参加活动时间(任务时间)。</strong></p>

<p><strong>      3.同理别的也一样，当玩家触发事件的时间如果 大于或者等于 需要更新数据的时间，则reset玩家db中的数据。</strong></p>

<p><strong>     </strong></p>

<p>   </p>
]]></content>
      <categories>
        <category>笔记 随笔</category>
      </categories>
      <tags>
        <tag>游戏开发数据更新</tag>
      </tags>
  </entry>
  <entry>
    <title>大话什么是服务器的集群、负载均衡、分布式</title>
    <url>/2020/08/16/%E5%A4%A7%E8%AF%9D%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%9B%86%E7%BE%A4%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<p>        前几天，室友换工作了，之前的他是做客户端上位机的，换工作了之后接触到了<strong>集群、负载均衡、分布式</strong>等概念，但是不是很清楚，百度上的答案也是鸡同鸭讲，于是在群里和我讨论了这个问题。我想起我刚做服务器开发的时候，关于这些概念也不是很清晰，现在想想，应该可以用大白话描述出来。下面举个例子。</p>

<h3>      1.什么是集群</h3>

<p>        首先，我们假设这么个例子，你现在是一个刺激战场的服务器开发工程师，从0开始开发。你先开发了一个服务器A，你开发的服务器A<strong>性能峰值</strong>能容纳5000人在线玩游戏，然后部署使用。因为是新开发的游戏，玩的人不是很多。过了一段时间后，发现玩游戏的人越来越多了，现在已经有8000人要玩了，一台服务器已经撑不住了，你又开发了服务器B。让服务器A、服务器B一起运行，这样你的游戏最多就能容纳10000人游戏了。<strong>服务器A、服务器B就叫做你的游戏服务器集群。</strong>同理，你扩展到10台服务器，只要是你刺激战场游戏的服务器，都称作你的<strong>服务器集群</strong>。</p>

<h3>      2.什么是负载均衡</h3>

<p>        你现在有了2台服务器，你发现你的服务器运行是这样的，8000人进行游戏，服务器A人数达到5000人了，剩下的3000人才会进入的是服务器B。这样会造成一个问题，有软件常识的人都知道，数据量越大，处理数据的时间就越长、或者空间就越大。服务器A有5000人进行游戏，已经是达到了性能峰值，玩家偶尔会感觉到服务器卡顿，例如：点了开局，过一会儿才会跳入下一个界面。就像你电脑同时开启了很多东西，虽然都能处理，但是偶尔会卡顿。你觉得这样不合理，明明有两台服务器，只要每台服务器分别处理4000个玩家，这样两个服务器都没达到峰值，8000玩家都能有良好的体验。于是乎，你就写了一些处理方法，让服务器A和服务器B处理的玩家是相同的。例如，有6000玩家进行游戏的时候，服务器A、服务器B分别处理3000玩家。这就是<strong>负载均衡</strong>。</p>

<h3>      3.什么是分布式</h3>

<p>        经过一段时间的运营，你的刺激战场游戏已经有5W玩家进行游戏，峰值的时候有4W玩家同时在线。你按照上面的方法，你开发了10台服务器（服务器A、B、C....），游戏运营的都很正常。忽然有一天，有4W人同时在线时，忽然有有三台服务器挂了，连接这三台服务器的玩家全部被断开连接，然后重新连接，但是你7台服务器的性能巅峰只能容纳3.5W人。意味着有5000玩家直接玩不了，运气不好，5000玩家里刚好有几个大土豪，刚好再逛商城，准备消费，现在消费不聊了，经过一投诉，你被公司痛批了一顿，你被痛批后，开始觉得你的设计不合理。虽然4W人同时在线，但是只有3W人是再游戏的，1W人是不进入游戏的，只是再逛大厅（商城），而且你原来把所有的逻辑都写再一个服务器（登录、大厅、游戏）导致一个服务器性能巅峰只能容纳5000人。于是乎，你重新分析了需求：1.同时登陆的玩家最多有1W人，2同时在线的玩家一般有1/4是至逛大厅和商城的，剩下的3/4是进行游戏的。然后你重新设计了你的服务器，把服务器分成3类，<strong>每一类只处理一种业务</strong>，分成了<strong>登陆服务器、大厅服务器、游戏服务器</strong>。经过你这么一拆分，<strong>由于一台服务器只处理一种逻辑，服务器性能得到了提高</strong>，最高可以处理1W人的逻辑，这就是<strong>分布式</strong>。现在你重新分配服务器，10台服务器，分成2台登陆服务器，2台大厅服务器，6台游戏服务器，现在游戏在同时有4W人在线的时候，按照1/4在大厅（1W人），3/4在游戏（3W人）。这个时候，如果有3台服务器挂了，都不会出现像上次那样玩家无法连接的情况。</p>

<p>       以上的只是举个例子帮助理解这几个概念，实际情况会更复杂，但是原理都是这样的。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一个游戏AI（一）</title>
    <url>/2020/07/30/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8FAI%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<p>       由于目前游戏的ai最后两手牌打的不尽人意，而手头上的工作又暂时弄完了。就被安排去学习AI，最终目标是<strong>重新训练/优化现有的AI</strong>。<strong>而这只是我的记录，仅仅是偏向我的应用，并不偏向研究</strong>。虽然只是这样，但是其实听到这个任务的时候，内心是拒绝的。</p>

<p>       原因有以下几点：</p>

<p>       1.要写出一个斗地主AI，我觉得是很难的，技术和数学都要有一定水平。</p>

<p>       2.老夫就一个刚工作2年的程序员，而且还是非AI专业，让我萌生了就是觉得很难很难得想法。</p>

<p>       3.老夫就拿这点工资(说来惭愧，哎)。。。我如果真能写，我才值这点钱么，我写出来的敢用么。</p>

<p>       虽然内心不愿意，但是身体却很诚实，毕竟做的都是出卖自己的工作。就算叫我去38度的天下晒太阳，叫我去厕所吃快餐，我也没什么好拒绝的吧，毕竟花钱买我时间的。将自己的路程尽量全部记录，给自己看，也分享给和我相似情况下想学写游戏AI的人，如果有同僚看到我说的有什么不对，请指出。<strong>这里要感谢我的经理潇爷，我的天资比较愚钝，他带我了解并写下第一个关于0-9黑白图片的试别ai</strong>。下面开始进入正文。</p>

<p>       </p>

<h3>     1.我们游戏中指的AI是什么</h3>

<p>        其实AI没有想象的那么难，AI也是分369等的，比如游戏时的NPC，能和你进行对话，能给你任务，这样的就比较简单不需要用到机器学习；更进一步，mmo游戏中的怪物，boss，知道主动攻击你，知道放技能，知道躲技能（这个可能也不需要用到机器学习，或者用了我不知道，因为我目前只做过棋牌游戏）；再进一步，你以为你玩的棋牌游戏匹配到的都是真人么，或者进一步说，你以为你别的游戏匹配到的队友都是人么，也许它们只是AI而已（这个就需要机器学习了，这个东西已经拥有了类似人类的想法来陪你玩游戏）。</p>

<h3>      2.什么是训练一个AI</h3>

<p>        就是训练出一个模型，这个模型再你给它一个输入的时候，它能够预测出最大概率的输出是什么（类似一个函数，你给一个输入，它返回输出）。例如图像试别AI，给定的输入是一张图像，它用输出告诉你最大概率这个图像是什么。注意，这里是告诉你最大概率输出是什么，并不是告诉你输出是什么（关于这个之后会继续聊）。</p>

<h3>      3.如何训练一个AI</h3>

<p>        其实很多事情，前人已经做好了，就像我们要训练AI，并不是所有的东西都要自己写，现在有很多深度学习的框架，就我而已，我只是应用，我只要找到合适的框架、然后使用框架训练出自己想要的AI即可（类似于有很多库函数，只需要找到自己想用的库函数，然后调用它，获取结果即可）。</p>

<h3>      4.我的学习路程</h3>

<p>        1.补充了一些知识</p>

<p>        2.经理又给我补充了一些知识，然后在他的带领下，写了一个 0-9的黑白图像试别AI</p>

<p>        3.经过以上的路程后，开始自己继续探索，训练一个斗地主AI</p>

<p> </p>

<p>       <strong> 注意：训练 == 写，训练一个AI == 写一个AI，有些东西是术语来着，我也不是专业的，但是又接触了，所以有的时候会语无伦次。</strong></p>

<p>        第一篇大概写这么多，后面会接着更新</p>

<p>       </p>
]]></content>
      <categories>
        <category>笔记 AI之路</category>
      </categories>
      <tags>
        <tag>tensorflow 深度学习 python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一个游戏AI（三）0-9手写数字图片识别AI训练</title>
    <url>/2020/08/03/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8FAI%EF%BC%88%E4%B8%89%EF%BC%890-9%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%ABAI%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<span id="more"></span>
<p>       接上回书，那么如何写一个入门的简单AI训练（0-9）数字图片试别AI。本文的程序，配合我训练的模型试别准确率只有98.8%，不过也是算是给我开辟了新的知识面。</p>

<h2>    1.为什么使用卷积神经网络</h2>

<p>        原因有二：1.直观上，使用卷积比全连接网络少很多参数（百度上说的）；2.我经理直接叫我用这个。哈哈哈哈 = =，我只是大概知道，可以用来处理图像。如果有同僚看到这篇文章，有别的见解欢迎指出。</p>

<h2>    <strong>2.在写这个训练AI的代码之前，需要准备什么</strong></h2>

<p><strong>       </strong> 使用卷积训练AI，也就是教会AI试别各种数字的是需要大量的数据进行训练了。<strong>因为是入门，所以我的训练图片是32*32的黑白图像，也就是用画图工具画出来的。</strong>0-9每个数字画了十张。然后写了个python脚本，用每个数字的10张样本，经过简单平移或者旋转生成1000张图。0-9总共是10000张图作为所有的输入数据。<strong>设计好输入和输入</strong>，安装好相应的库，例如<strong>tensorflow，numpy</strong>。</p>

<h2>    3.代码主要分为4个部分：读取图片，读取训练集和校验集，训练，使用模型</h2>

<p>      下面开始进入代码部分，代码部分有足够的注释：</p>

<p>       <strong>a.读取图片：</strong></p>

<pre>
<code class="language-python">def read_sample(file_path):
    ret = numpy.zeros((32, 32))                 #使用numpy构建32*32的数组
    im = Image.open(file_path)
    rgb_im = im.convert('RGB')                  #将打开的image指定真彩色模式 
    for i in range(32):
        for j in range(32):
            r, g, b = rgb_im.getpixel((i, j))   #读取每个点的r,g,b
            average = (r + b + g)/3             
            if average &gt;= 127:                  #因为是黑白图像，非黑即白rgb三原色综合是255，所以可以使用127来区分
                ret[i, j] =  0
            else:
                ret[i, j] = 1

    return ret

# 可以使用以下代码输入一下看看图形转化为数字输入的结果
# ret = read_sample("C:/Users/bfs/Desktop/learning_ai/0/0_1.png")  
# for j in range(32):
#     for i in range(32):
#         print(int(ret[i, j]), end=' ')
#     print('')      
# </code></pre>

<p>         这里随便使用一张图0的图打印结果如下</p>

<p><img alt height="493" src="https://img-blog.csdnimg.cn/20200803195905743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="498"></p>

<p>        可以清晰的看到，转换成数字输入的结果，的确是一个0。</p>

<p><strong>         b.读取训练集和校验集</strong></p>

<p>         这里补充一下，在所有的数据里面，需要把数据分为训练和校验。校验用来验证训练的结果。校验满意后，再生成模型。之后就是直接使用模型了。</p>

<pre>
<code class="language-python">def read_trainset_and_validateset():
    trainset_samples = []               #定义训练集
    validateset_samples = []            #定义校验集

    for i in range(10):
        for root, dirs, files in os.walk("out/"+str(i), topdown=False):
            for name in files:
                pic_path = os.path.join(root, name)
                rand_num = random.random()
                if rand_num &gt; 0.9:                                            #90%为训练集，剩下10%为校验集
                    trainset_samples.append( (read_sample(pic_path), i) )     #插入训练集，内容为 （图像内容，数字）
                else:
                    validateset_samples.append( (read_sample(pic_path), i) )  #插入校验集，内容为 （图像内容，数字）

    return (trainset_samples, validateset_samples)</code></pre>

<p>       <strong>c.训练</strong></p>

<pre>
<code class="language-python">def train():
    print("loading....")
    trainset_samples, valideteset_samples = read_trainset_and_validateset()    #获取训练集和校验集
    x = numpy.zeros((len(trainset_samples), 32, 32, 1))                        #构建训练集, 10个32*32的1通道神经元输入
    y = numpy.zeros((len(trainset_samples), 10))                               #构建训练集, 二维0-9的神经元输出
    validate_x = numpy.zeros((len(valideteset_samples), 32, 32, 1))            #构建校验集, 10个32*32的1通道神经元输入
    validate_y = numpy.zeros((len(valideteset_samples), 10))                   #构建校验集, 二维0-9的神经元输出
    print("conver......")

    for i in range(len(trainset_samples)):
        sample, sample_out = trainset_samples[i]            #sample对应读取的图像结果, sample_out对应结果为哪个数字
        for xi in range(32):    
            for yi in range(32):
                x[i, xi, yi, 0] = sample[xi, yi]            #训练集输入, i对应目前是哪个神经元的输入, sample为读取图像的结果

        y[i, sample_out] = 1                                #训练集输出, 意思为这个神经元的输出结果为1, 即当以上神经元输入时,对应的这个神经元的sample_out的预测结果为1(100%)

    for i in range(len(valideteset_samples)):
        sample, sample_out = valideteset_samples[i]         #sample对应读取的图像结果, sample_out对应结果为哪个数字
        for xi in range(32):
            for yi in range(32):
                validate_x[i, xi, yi, 0] = sample[xi, yi]   #校验集输入, i对应目前是哪个神经元的输入, sample为读取图像的结果

        validate_y[i, sample_out] = 1                       #校验集输出, 意思为这个神经元的输出结果为1, 即当以上神经元输入时,对应的这个神经元的sample_out的预测结果为1(100%)

    input = keras.Input(shape=(32,32,1))                                                    #输入层，32*32个神经元输入，一个输入通道，因为只是一个二维的黑白图像，一个输入通道即可。复杂的情况则需要多个输入通道，可以自己看看别的例子
    layer = keras.layers.Conv2D(filters=32, kernel_size=(5,5), activation='relu')(input)    #卷积层，5*5个神经元感受视野，32个卷积核，激励函数relu做非线性映射
    layer = keras.layers.Conv2D(filters=8, kernel_size=(5,5), activation='relu')(layer)     #卷积层，5*5个神经元感受视野，8个卷积核，激励函数relu做非线性映射
    layer = keras.layers.MaxPool2D(pool_size=(2, 2))(layer)                                 #池化层，maxpool取“池化视野”矩阵中的最大值，当输入经过卷积层时，得到的feature map （特征图）还是比较大，可以通过池化层来对每一个 feature map 进行降维操作
    layer = keras.layers.Dropout(rate=0.4)(layer)                                           #该层的作用相当于对参数进行正则化来防止模型过拟合
    layer = keras.layers.Flatten()(layer)                                                   #将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。
    layer = keras.layers.Dense(128, activation='relu')(layer)                               #全连接层，有128个神经元，激活函数采用‘relu’
    layer = keras.layers.Dense(10, activation='softmax')(layer)                             #输出层，有10个神经元，每个神经元对应一个类别，输出值表示样本属于该类别的概率大小。

    model = keras.Model(input, layer)                                                       #创建模型
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])  #指定一些参数
    print("training.....")
    model.fit(x=x, y=y, batch_size=200, epochs=40, validation_data=(validate_x, validate_y)) #训练模型

    # model.save('C:/Users/bfs/Desktop/learning_ai/pictrue_model.h5')  #训练满意的话则保存

    return model</code></pre>

<p>       训练结果为</p>

<p><img alt height="200" src="https://img-blog.csdnimg.cn/20200803195108826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="992">       可以看到校验集的校验结果精确度达到98.8%左右</p>

<p>      <strong>d.使用模型</strong></p>

<pre>
<code class="language-python">def verify_modle():
    m_model = keras.models.load_model('C:/Users/bfs/Desktop/learning_ai/pictrue_model'+'.h5')
    verify_sample = read_sample('C:/Users/bfs/Desktop/learning_ai/3.png')  #我这里随便使用一张图片来进行实际预测
    test_x = numpy.zeros((1, 32, 32, 1))
    for xi in range(32):
            for yi in range(32):
                test_x[0, xi, yi, 0] = verify_sample[xi, yi]
    predict_result = m_model.predict(x=test_x)               #导入实际使用时的图片数据

    ret = 0
    max_prob = max(predict_result[0])                        #返回最大的概率。训练结果是一个二维数组，相当于一列0-9的概率。最大的概率则为预测结果
    for x in range(10):
        if max_prob == predict_result[0, x]:
            ret = x

    print('解析图片结果结果为', ret)</code></pre>

<h3>      以下为完整代码：</h3>

<pre>
<code class="language-python">#coding:utf-8
from PIL import Image, ImageChops
import os
import numpy
import random
import numpy as np
import tensorflow as tf
from tensorflow import keras

def read_sample(file_path):
    ret = numpy.zeros((32, 32))                 #使用numpy构建32*32的数组
    im = Image.open(file_path)
    rgb_im = im.convert('RGB')                  #将打开的image指定真彩色模式 
    for i in range(32):
        for j in range(32):
            r, g, b = rgb_im.getpixel((i, j))   #读取每个点的r,g,b
            average = (r + b + g)/3             
            if average &gt;= 127:                  #因为是黑白图像，非黑即白rgb三原色综合是255，所以可以使用127来区分
                ret[i, j] =  0
            else:
                ret[i, j] = 1

    return ret

def read_trainset_and_validateset():
    trainset_samples = []               #定义训练集
    validateset_samples = []            #定义校验集

    for i in range(10):
        for root, dirs, files in os.walk("out/"+str(i), topdown=False):
            for name in files:
                pic_path = os.path.join(root, name)
                rand_num = random.random()
                if rand_num &gt; 0.9:                                            #90%为训练集，剩下10%为校验集
                    trainset_samples.append( (read_sample(pic_path), i) )     #插入训练集，内容为 （图像内容，数字）
                else:
                    validateset_samples.append( (read_sample(pic_path), i) )  #插入校验集，内容为 （图像内容，数字）

    return (trainset_samples, validateset_samples)


# ret = read_sample("C:/Users/bfs/Desktop/learning_ai/0/0_1.png")  
# for j in range(32):
#     for i in range(32):
#         print(int(ret[i, j]), end=' ')
#     print('')      
# 

def train():
    print("loading....")
    trainset_samples, valideteset_samples = read_trainset_and_validateset()    #获取训练集和校验集
    x = numpy.zeros((len(trainset_samples), 32, 32, 1))                        #构建训练集, 10个32*32的1通道神经元输入
    y = numpy.zeros((len(trainset_samples), 10))                               #构建训练集, 二维0-9的神经元输出
    validate_x = numpy.zeros((len(valideteset_samples), 32, 32, 1))            #构建校验集, 10个32*32的1通道神经元输入
    validate_y = numpy.zeros((len(valideteset_samples), 10))                   #构建校验集, 二维0-9的神经元输出
    print("conver......")

    for i in range(len(trainset_samples)):
        sample, sample_out = trainset_samples[i]            #sample对应读取的图像结果, sample_out对应结果为哪个数字
        for xi in range(32):    
            for yi in range(32):
                x[i, xi, yi, 0] = sample[xi, yi]            #训练集输入, i对应目前是哪个神经元的输入, sample为读取图像的结果

        y[i, sample_out] = 1                                #训练集输出, 意思为这个神经元的输出结果为1, 即当以上神经元输入时,对应的这个神经元的sample_out的预测结果为1(100%)

    for i in range(len(valideteset_samples)):
        sample, sample_out = valideteset_samples[i]         #sample对应读取的图像结果, sample_out对应结果为哪个数字
        for xi in range(32):
            for yi in range(32):
                validate_x[i, xi, yi, 0] = sample[xi, yi]   #校验集输入, i对应目前是哪个神经元的输入, sample为读取图像的结果

        validate_y[i, sample_out] = 1                       #校验集输出, 意思为这个神经元的输出结果为1, 即当以上神经元输入时,对应的这个神经元的sample_out的预测结果为1(100%)

    input = keras.Input(shape=(32,32,1))                                                    #输入层，32*32个神经元输入，一个输入通道，因为只是一个二维的黑白图像，一个输入通道即可。复杂的情况则需要多个输入通道，可以自己看看别的例子
    layer = keras.layers.Conv2D(filters=32, kernel_size=(5,5), activation='relu')(input)    #卷积层，5*5个神经元感受视野，32个卷积核，激励函数relu做非线性映射
    layer = keras.layers.Conv2D(filters=8, kernel_size=(5,5), activation='relu')(layer)     #卷积层，5*5个神经元感受视野，8个卷积核，激励函数relu做非线性映射
    layer = keras.layers.MaxPool2D(pool_size=(2, 2))(layer)                                 #池化层，maxpool取“池化视野”矩阵中的最大值，当输入经过卷积层时，得到的feature map （特征图）还是比较大，可以通过池化层来对每一个 feature map 进行降维操作
    layer = keras.layers.Dropout(rate=0.4)(layer)                                           #该层的作用相当于对参数进行正则化来防止模型过拟合
    layer = keras.layers.Flatten()(layer)                                                   #将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。
    layer = keras.layers.Dense(128, activation='relu')(layer)                               #全连接层，有128个神经元，激活函数采用‘relu’
    layer = keras.layers.Dense(10, activation='softmax')(layer)                             #输出层，有10个神经元，每个神经元对应一个类别，输出值表示样本属于该类别的概率大小。

    model = keras.Model(input, layer)                                                       #创建模型
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])  #指定一些参数
    print("training.....")
    model.fit(x=x, y=y, batch_size=200, epochs=40, validation_data=(validate_x, validate_y)) #训练模型

    model.save('C:/Users/bfs/Desktop/learning_ai/pictrue_model.h5')

    return model

def verify_modle():
    m_model = keras.models.load_model('C:/Users/bfs/Desktop/learning_ai/pictrue_model'+'.h5')
    verify_sample = read_sample('C:/Users/bfs/Desktop/learning_ai/3.png')  #我这里随便使用一张图片来进行实际预测
    test_x = numpy.zeros((1, 32, 32, 1))
    for xi in range(32):
            for yi in range(32):
                test_x[0, xi, yi, 0] = verify_sample[xi, yi]
    predict_result = m_model.predict(x=test_x)               #导入实际使用时的图片数据

    ret = 0
    max_prob = max(predict_result[0])                        #返回最大的概率。训练结果是一个二维数组，相当于一列0-9的概率。最大的概率则为预测结果
    for x in range(10):
        if max_prob == predict_result[0, x]:
            ret = x

    print('解析图片结果结果为', ret)

if __name__ == "__main__":
    # train()
    verify_modle()

</code></pre>

<p>          使用图像3导入模型结果为：</p>

<p><img alt height="142" src="https://img-blog.csdnimg.cn/20200803200155783.png" width="575"></p>

<p>        最后有几点需要注意。</p>

<p>        <strong>1.我这里写的是很简单的0-9手写数字试别，所以再构建输入的时候只有一个输入通道，如果是复杂的问题，可能需要多个输入通道，比如彩色的图像，可能需要R,G,B三个输入通道。</strong></p>

<p><strong>        2.训练AI是这么个过程，给定输入，给定输入，让AI像人一样去学习。就像一个人要学习一样，告诉自己，这个图像3输入的结果是3。是一定要给出输出的。</strong></p>

<p><strong>        3.AI模型就像我们以前写的函数，给了输入，它就会给输出。像这个0-9的输入是为数字0-9的概率。而不是直接告诉你是什么数字，取出最大的概率对应的数字，就是AI觉得这张图是个什么数字.</strong></p>

<p><strong>        4.我也是初学者，写的注释什么的都是自己的理解，可能不对。如果有发现错误的/有歧义的地方。欢迎指出</strong></p>

<p>        <strong>5.上面的训练就是不断利用卷积神经网络提取各种图像的特征，最后当给定一副新的图，就去匹配其相应的特征，给出结果。</strong></p>

<p>        增加一些知识补充连接：</p>

<p>        1.知乎&lt;如何通俗易懂的理解卷积&gt; https://www.zhihu.com/question/22298352/answer/228543288<br>
        2.卷积神经网络详解 - 卷积层逻辑篇  https://blog.csdn.net/tjlakewalker/article/details/83275322</p>
]]></content>
      <categories>
        <category>AI之路 python</category>
      </categories>
      <tags>
        <tag>神经网络 python 机器学习 tensorflow 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一个游戏AI（二）卷积神经网络是什么，怎么使用？</title>
    <url>/2020/08/12/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8FAI%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<span id="more"></span>
<p>      开始接触卷积神经网络已经有快三个星期了。觉得还是有一些概念，要刚开始知道会比较容易理解这个东西。</p>

<h3>     <strong>1.什么是卷积神经网络</strong></h3>

<p><strong>       </strong>其实这个东西应该是这样读的，卷积  神经网络。卷积是用来提取特征的，神经网络是用来分类的。合起来就是，卷积神经网络用来提取特征然后分类的。下面继续解释</p>

<h3>      <strong>2.为什么卷积可以提取特征</strong></h3>

<p><strong>        </strong>在使用卷积神经网络时，经常看到一个概念叫做<strong>卷积核（滤波器）</strong>，这个东西为什么可以提取特征呢。举个可能不恰当的例子，例如，你现在有一堆混合物（大米+红豆+大豆），要对它们进行分类，这个使用你使用一个筛子，这个筛子就类似于上面说的<strong>卷积核（滤波器）</strong>，你通过改变它，既可以提取特征。就像你改变你的筛子大小，最小的时候，你只能筛出大米，别的东西无法通过筛子，你的卷积核就提取了大米的特征。</p>

<h3>       <strong>3.什么是神经网络</strong></h3>

<p><img alt height="448" src="https://img-blog.csdnimg.cn/20200812195125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="905"></p>

<p><strong>        </strong>如上图所示，这就是一个神经网络的结构，简单来说，就是输入层（两个神经元，红色）---&gt;隐藏层（三个神经元，绿色）---&gt;输出层（两个神经元，黄色）。即，给定了输入，最后得到输出。为什么可以分类，我也不太清楚，可以自行百度。</p>

<h3>         4.使用卷积神经网络的实际例子</h3>

<p>         用大白话举例过程，原理是这样的，但是实际操作会有一些别的不通。比如用卷积神经网络训练了一个可以识别猫、狗图像的AI。</p>

<p>         1.把海量的猫图片、狗图片作为输入</p>

<p>         2.当输入猫图片时，让训练模型输出为A</p>

<p>         3.当输入狗图片时，让训练模型输出为B</p>

<p>         4.当训练的时候，海量的训练数据就会反复调整卷积核，不停的改变参数（也就是学习），最后拿到最优的模型</p>

<p>         5.最后，使用时当你给定一张猫的图片的时候，猫图片输入模型，模型会预测出这张图最大概率结果是A。如果输入的是狗的图片，则这张图最大概率是B</p>

<p> </p>

<p>        <strong>最后有两点要说一说</strong></p>

<p><strong>        1.其实使用卷积神经网络训练AI并没有想象的那么可怕，会自己思考，什么的七七八八。你必须事先告诉它结果。例如，你给他一巴掌作为输入时，输出为AI给你100元。当训练完之后，你给它一巴掌，它只会给你100元，并不会反过来打你一巴掌。</strong></p>

<p><strong>        2.要想使用卷积神经网络训练AI，必须要规定相应的输入和输出作为训练，这个输入和输出是我们程序员自己定的。</strong></p>
]]></content>
      <categories>
        <category>AI之路</category>
      </categories>
      <tags>
        <tag>卷积神经网络 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一个游戏AI（四）如何使用卷积神经网络训练一个斗地主AI</title>
    <url>/2020/08/24/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8FAI%EF%BC%88%E5%9B%9B%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E6%96%97%E5%9C%B0%E4%B8%BBAI/</url>
    <content><![CDATA[<span id="more"></span>
<p>       经过3个星期得努力，终于初步达成效果，由于训练数据少（因为我在公司使用的电脑只能使用CPU训练，所以数据不能太多，否则就要很长时间）训练出了个傻子。之后我便没有在继续这个工作了。原因有二：1.我身后的同事和我一起再搞，他的进度比我快多了，而且也拿到了AI训练的机器的使用权。2.的确我也是来了新的需求。所以AI工作先告一段落。</p>

<p>       下面分享训练AI的思路。至于代码，就不能分享了。因为是工程代码。</p>

<h3>     1.准备数据</h3>

<p>        经过前面几篇关于使用卷积神经网络的blog，已经说明了为什么要准备数据。因为我现在的公司拥有大量的牌局数据，所以对我来说这个也不是什么问题。如果没有数据的话，就难搞了。</p>

<h3>      2.重中之重，设计输入输出</h3>

<p>        卷积神经网络比较有名的应用，就是图像识别，也适合做图像识别。那我们拿到斗地主的牌局数据又有什么用呢？其实只要打开了思维，把牌局数据转化成矩阵，输入到设计的模型里，再规定输出即可。</p>

<p>        而训练出来最终的模型是这样的，给定你设计的输入，AI会告诉你输出的牌型概率。比如，你给定了你的手牌作为输入，然后AI模型会给出概率出什么牌。至于概率对应的出牌，也是你设计的输出。下面给出一张图，可以作为思路参考。至于怎么做，怎么设计，还是在于自己。</p>

<p><img alt height="591" src="https://img-blog.csdnimg.cn/20200824193351606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="1052"></p>

<p>        这篇文章的地址为：<a href="https://gameinstitute.qq.com/course/detail/10132#">https://gameinstitute.qq.com/course/detail/10132#</a>，腾讯大牛的文章。</p>

<p>        至于输出，我觉得都是要枚举出所有的出牌情况，把输出对应好，最后使用模型时看概率出什么牌。</p>

<p>        最后，学会使用卷积神经网络去训练一个AI，按照应用来说，其实是不算难的，难点在于设计模型。</p>
]]></content>
      <categories>
        <category>AI之路 python</category>
      </categories>
      <tags>
        <tag>python 神经网络 机器学习 人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在linux中通过linux源码安装最新的perf，使用perf data convert --force --to-json</title>
    <url>/2022/02/10/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E4%B8%AD%E9%80%9A%E8%BF%87linux%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84perf%EF%BC%8C%E4%BD%BF%E7%94%A8perf%20data%20convert%20--force%20--to-json/</url>
    <content><![CDATA[<span id="more"></span>
<p>perf可以针对进程进行profile，也可以对线程进行profile。再对进程profile之后，拿到perf.data，也可以修改为针对进程下的线程进行profile。所以照理来说应该是可以从perf.data中查看到有多少线程。<br>这也符合我们的一般要求，即有perf.data之后，可以针对线程显示火焰图。经过查询资料发现，perf中有<code>perf data convert --force --to-json temp.json</code>可以把perf.data转成json进行查看，但是要新版本的perf才有…这就恨坑爹，以为着我们需要自己安装最新的perf。</p>
<h1 id="安装perf"><a href="#安装perf" class="headerlink" title="安装perf"></a>安装perf</h1><p>我的系统是RedHat系列，对应的Debian系列需要自己修改一下install相关。<br>拉取最新的内核代码<code>git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth 1000</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ip-10-155-128-114 ~]<span class="comment"># cd linux/tools/perf/</span></span><br><span class="line">[root@ip-10-155-128-114 perf]<span class="comment"># LIBBABELTRACE=1 LIBBABELTRACE_DIR=/usr/local  make</span></span><br><span class="line">  BUILD:   Doing <span class="string">&#x27;make -j2&#x27;</span> parallel build</span><br><span class="line">  HOSTCC  fixdep.o</span><br><span class="line">  HOSTLD  fixdep-in.o</span><br><span class="line">  LINK    fixdep</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/include/uapi/linux/kvm.h&#x27;</span> differs from latest version at <span class="string">&#x27;include/uapi/linux/kvm.h&#x27;</span></span><br><span class="line">diff -u tools/include/uapi/linux/kvm.h include/uapi/linux/kvm.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/include/uapi/linux/perf_event.h&#x27;</span> differs from latest version at <span class="string">&#x27;include/uapi/linux/perf_event.h&#x27;</span></span><br><span class="line">diff -u tools/include/uapi/linux/perf_event.h include/uapi/linux/perf_event.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/include/uapi/linux/prctl.h&#x27;</span> differs from latest version at <span class="string">&#x27;include/uapi/linux/prctl.h&#x27;</span></span><br><span class="line">diff -u tools/include/uapi/linux/prctl.h include/uapi/linux/prctl.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/include/uapi/sound/asound.h&#x27;</span> differs from latest version at <span class="string">&#x27;include/uapi/sound/asound.h&#x27;</span></span><br><span class="line">diff -u tools/include/uapi/sound/asound.h include/uapi/sound/asound.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/arch/x86/include/asm/cpufeatures.h&#x27;</span> differs from latest version at <span class="string">&#x27;arch/x86/include/asm/cpufeatures.h&#x27;</span></span><br><span class="line">diff -u tools/arch/x86/include/asm/cpufeatures.h <span class="built_in">arch</span>/x86/include/asm/cpufeatures.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/arch/x86/include/uapi/asm/prctl.h&#x27;</span> differs from latest version at <span class="string">&#x27;arch/x86/include/uapi/asm/prctl.h&#x27;</span></span><br><span class="line">diff -u tools/arch/x86/include/uapi/asm/prctl.h <span class="built_in">arch</span>/x86/include/uapi/asm/prctl.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/include/uapi/asm-generic/unistd.h&#x27;</span> differs from latest version at <span class="string">&#x27;include/uapi/asm-generic/unistd.h&#x27;</span></span><br><span class="line">diff -u tools/include/uapi/asm-generic/unistd.h include/uapi/asm-generic/unistd.h</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/perf/arch/x86/entry/syscalls/syscall_64.tbl&#x27;</span> differs from latest version at <span class="string">&#x27;arch/x86/entry/syscalls/syscall_64.tbl&#x27;</span></span><br><span class="line">diff -u tools/perf/arch/x86/entry/syscalls/syscall_64.tbl <span class="built_in">arch</span>/x86/entry/syscalls/syscall_64.tbl</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/perf/arch/powerpc/entry/syscalls/syscall.tbl&#x27;</span> differs from latest version at <span class="string">&#x27;arch/powerpc/kernel/syscalls/syscall.tbl&#x27;</span></span><br><span class="line">diff -u tools/perf/arch/powerpc/entry/syscalls/syscall.tbl <span class="built_in">arch</span>/powerpc/kernel/syscalls/syscall.tbl</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/perf/arch/s390/entry/syscalls/syscall.tbl&#x27;</span> differs from latest version at <span class="string">&#x27;arch/s390/kernel/syscalls/syscall.tbl&#x27;</span></span><br><span class="line">diff -u tools/perf/arch/s390/entry/syscalls/syscall.tbl <span class="built_in">arch</span>/s390/kernel/syscalls/syscall.tbl</span><br><span class="line">Warning: Kernel ABI header at <span class="string">&#x27;tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl&#x27;</span> differs from latest version at <span class="string">&#x27;arch/mips/kernel/syscalls/syscall_n64.tbl&#x27;</span></span><br><span class="line">diff -u tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl <span class="built_in">arch</span>/mips/kernel/syscalls/syscall_n64.tbl</span><br><span class="line">Makefile.config:201: *** Error: flex is missing on this system, please install it.  Stop.</span><br><span class="line">make[1]: *** [sub-make] Error 2</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><br>错误原因是没有flex，安装flex，yum install flex，安装flex之后还需要安装bison，yum install bison，安装完毕后重新LIBBABELTRACE=1 LIBBABELTRACE_DIR=/usr/local make即可，前面加环境变量是因为需要在这个环境变量下编译才能使用perf data做转换。否则会报错perf should be compiled with environment variables LIBBABELTRACE=1 and LIBBA。<br>之后便可以用perf data将采集到的数据转成json，这样就可以看到进程中有哪些线程，可以针对单线程做profile。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ip-10-155-136-104 ~]<span class="comment"># ./linux/tools/perf/perf record -g -F 99 -p 3169  ## 3169是进程id</span></span><br><span class="line">[root@ip-10-155-136-104 ~]<span class="comment"># ./linux/tools/perf/perf data convert --force --to-json temp.json</span></span><br></pre></td></tr></table></figure>
<p>最后在写个脚本分析json文件即可。<br>参考：<br><a href="https://stackoverflow.com/questions/11921842/read-and-parse-perf-data">perf.data转成json</a>。<br><a href="https://openlab-mu-internal.web.cern.ch/03_Documents/3_Technical_Documents/Technical_Reports/2011/Urs_Fassler_report.pdf">perf file format</a><br><a href="https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf.data-file-format.txt">perf.data-file-format.txt</a></p>
]]></content>
      <categories>
        <category>Linux 性能优化</category>
      </categories>
      <tags>
        <tag>linux debian</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看进程占用的内存</title>
    <url>/2022/05/29/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p><code>top -P pid</code>，其中RSS为进程当前使用的内存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 22:18:50 up 163 days,  5:48, 64 <span class="built_in">users</span>,  load average: 0.88, 1.07, 1.45</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.5 us,  0.9 sy,  0.0 ni, 97.3 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.3 st</span><br><span class="line">KiB Mem : 32950160 total,  3186404 free, 19244656 used, 10519100 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  1736340 free,   360808 used. 12881604 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1696650 banfush+  20   0  712796 100940  29096 S  11.3  0.3   7659:06 node</span><br></pre></td></tr></table></figure>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p><code>cat /proc/pid/status</code>其中VMRSS为进程使用内存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banfushen@ma100:~/$ <span class="built_in">cat</span> /proc/1696650/status</span><br><span class="line">Name:   node</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   1696650</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    1696650</span><br><span class="line">PPid:   1696531</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    50301   50301   50301   50301</span><br><span class="line">Gid:    50301   50301   50301   50301</span><br><span class="line">FDSize: 128</span><br><span class="line">Groups: 0 4 999 50301</span><br><span class="line">NStgid: 1696650</span><br><span class="line">NSpid:  1696650</span><br><span class="line">NSpgid: 245413</span><br><span class="line">NSsid:  245413</span><br><span class="line">VmPeak:   715100 kB</span><br><span class="line">VmSize:   712796 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:    121080 kB</span><br><span class="line">VmRSS:    100444 kB</span><br><span class="line">RssAnon:           71348 kB</span><br><span class="line">RssFile:           29096 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:   148608 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:     63804 kB</span><br><span class="line">VmLib:      5308 kB</span><br><span class="line">VmPTE:      1300 kB</span><br><span class="line">VmPMD:      1076 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发基本功</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中第一次使用gitlab提交代码，到gitlab CICD自动部署到k8s碰到的坑，最终解决的过程。</title>
    <url>/2021/01/26/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gitlab%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%88%B0gitlab%20CICD%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0k8s%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%8C%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我不是从头开始搭建，而是在已有部分条件的情况下进行，因为是我自己一个人负责集群中，一个服务器的重写，领导就叫我在gitlab上创建仓库，然后自己提交代码。我之前是没用过gitlab的，上一家公司的工作用的是svn，所以对我来说，一切都是未知。我的项目是golang写的。<br>我的目的是：把项目打包成镜像—-&gt;上传到镜像仓库—-&gt;部署到k8s</p>
<h1 id="先建立仓库"><a href="#先建立仓库" class="headerlink" title="先建立仓库"></a>先建立仓库</h1><p>登录gitlab—-&gt;选择New project，会到一下页面，按照自己的情况填写<br><img src="https://img-blog.csdnimg.cn/20210126195740360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里有一点需要注意，当你创建完项目之后，会看到一些指引，例如叫你上传一个readme.md。我刚开始是没有权限的，所以什么也弄不了，直到你获得权限，你就可以操作仓库了。</p>
<h1 id="获得权限后，先拉仓库到本地"><a href="#获得权限后，先拉仓库到本地" class="headerlink" title="获得权限后，先拉仓库到本地"></a>获得权限后，先拉仓库到本地</h1><p><img src="https://img-blog.csdnimg.cn/2021012620053184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>进入你的工程，选择clone，然后选择自己想要的方式，使用git clone拉取仓库到你的本地。拉取之后，就可以用<strong>git add . —-&gt;git commit -m “xxxx” —-&gt;git push origin master</strong>提交到仓库。<br>注意：一般git 提交的时候，需要忽略一些文件，只需要在项目的目录添加一个.gitignore即可。<br>我提交完的文件大概如下，其中只需要知道两个<br><img src="https://img-blog.csdnimg.cn/20210126200949287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> .gitignore 是用来忽略一些不需要提交的文件<br> .gitlab-ci.yaml 是用来自动部署的</p>
<h1 id="先讲解一下gitlab-cicd"><a href="#先讲解一下gitlab-cicd" class="headerlink" title="先讲解一下gitlab cicd"></a>先讲解一下gitlab cicd</h1><p>其实这个东西不难，不知道网上为什么那么多解释，也不能写的都是不易于新手理解的一长串七七八八的概念。cicd需要两个东西：.gitlab-ci.yaml文件、gitlab-runner</p>
<p><strong>.gitlab-ci.yaml</strong><br>其实就是描述了你需要的自动部署过程，例如，你需要打包docker镜像，然后上传，那你就需要在gitlab-ci,yaml中使用它的语法去描述这个过程即可。<br><strong>gitlab-runner</strong><br>这个东西更易于理解，不知道网上哪些什么鬼解释。你既然写了自动部署脚本，那就需要有东西去执行你写的自动部署脚本，而gitlab-runner就是这个东西（类似于一个k8s中的pod，如果不对欢迎指出）。</p>
<p>其实这两个就是很简单的东西，反正我理解完，说出来就这么些。<strong>gitlab-runner跑的地方，就是你的gitlab项目地址，也就是说，你写的脚本就相当于在一台linux机器中，有一个你的项目的文件夹，你就在这个文件夹下写脚本（这是我自己的理解，我也的确是这样做的，如果有什么不对的地方欢迎讨论）</strong>，你完全可以在你的.gitlab-ci.yaml中写脚本用ls，pwd的命令看就知道了。</p>
<h1 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h1><h2 id="编写-gitlab-ci-yaml文件"><a href="#编写-gitlab-ci-yaml文件" class="headerlink" title="编写.gitlab-ci.yaml文件"></a>编写.gitlab-ci.yaml文件</h2><p>一开始我也不知道，上来就是直接用了个golang的cicd的demo（这个东西不用在gitlab添加cicd的时候就可以选择demo），执行之后，发现其实.gitlab-ci.yaml写的就是shell脚本（当时不知道，其实这个是和gitlab-runner相关的，后面再说）。这就简单了啊。<br>关于语法，这里不做说明<br>由于是项目，这里只能贴出部分<br>整个脚本分为三个阶段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">    - build</span><br><span class="line">    - docker_publish</span><br><span class="line">    - deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="build代码上传后，直接写脚本go-build，例如我的文件中这样写"><a href="#build代码上传后，直接写脚本go-build，例如我的文件中这样写" class="headerlink" title="build代码上传后，直接写脚本go build，例如我的文件中这样写"></a>build代码上传后，直接写脚本go build，例如我的文件中这样写</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">    image: golang:1.15.6</span><br><span class="line">    stage: build</span><br><span class="line">    before_script:</span><br><span class="line">      - <span class="built_in">mkdir</span> -p <span class="variable">$GOPATH</span>/src/$(<span class="built_in">dirname</span> <span class="variable">$REPO_NAME</span>)</span><br><span class="line">      - <span class="built_in">ln</span> -svf <span class="variable">$CI_PROJECT_DIR</span> <span class="variable">$GOPATH</span>/src/<span class="variable">$REPO_NAME</span></span><br><span class="line">      - <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/<span class="variable">$REPO_NAME</span></span><br><span class="line">    script:</span><br><span class="line">      - <span class="built_in">pwd</span></span><br><span class="line">      - <span class="built_in">ls</span></span><br><span class="line">      - <span class="built_in">cd</span> realTimeMsg</span><br><span class="line">      - go mod download</span><br><span class="line">      - go build -o <span class="variable">$CI_PROJECT_DIR</span>/RtmServer</span><br><span class="line">    artifacts:</span><br><span class="line">      paths:</span><br><span class="line">        - RtmServer</span><br><span class="line">      expire_in: 2 mos</span><br></pre></td></tr></table></figure>
<p>这个很好理解，主要看script，一看便知。</p>
<h2 id="docker-pulish将输出打包成镜像，这个就需要在docker中使用docker，要使用services如下。"><a href="#docker-pulish将输出打包成镜像，这个就需要在docker中使用docker，要使用services如下。" class="headerlink" title="docker_pulish将输出打包成镜像，这个就需要在docker中使用docker，要使用services如下。"></a>docker_pulish将输出打包成镜像，这个就需要在docker中使用docker，要使用services如下。</h2><p>这个构建也不难，在gitlab中上传你写好的Dockerfile后直接build即可。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker_publish:</span><br><span class="line">  image: docker:latest</span><br><span class="line">  services:</span><br><span class="line">    - docker:dind</span><br><span class="line">  script:</span><br><span class="line">   	...</span><br><span class="line">    - docker build -f Dockerfile --pull -t xxx</span><br><span class="line">    - docker image <span class="built_in">ls</span> </span><br><span class="line">    - docker push xxx</span><br></pre></td></tr></table></figure><br>这里需要注意一些，在.gitlab-ci.yaml文件中，需要定义的环境变量可以在setting—-&gt;cicd里面设置<br><img src="https://img-blog.csdnimg.cn/2021012620364154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="deploy部署，我碰到的最大的问题就在这里"><a href="#deploy部署，我碰到的最大的问题就在这里" class="headerlink" title="deploy部署，我碰到的最大的问题就在这里"></a>deploy部署，我碰到的最大的问题就在这里</h2><p>我的部署脚本中，就是无法dev的k8s中部署，我使用脚本kubectl cluster-info，发现我的脚本跑在的地方根本不是我的dev k8s，所以肯定无法部署。这种情况下我就去查了。<br><img src="https://img-blog.csdnimg.cn/20210126210436704.png" alt="在这里插入图片描述"><br>出现这种问题的原因是：gitlab-runner没有在我想要的环境中跑。所以无法关联到集群。<br>我在项目的部署的时候，也没有创建gitlab-runner，但是我的部署脚本的确跑起来了。<br>经过查询，<strong>原来是我参与的项目中有默认的共享的gitlab-runner</strong>，直接用这个跑了。</p>
<p>我首先尝试了把我的项目添加到k8s，也就是这个按钮，原来是add，我添加之后变成这个<br><img src="https://img-blog.csdnimg.cn/20210126204205559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加方法在这里：<a href="https://segmentfault.com/a/1190000020947651">https://segmentfault.com/a/1190000020947651</a>，我是参考了这个文章。<br>但是并没有解决我的问题。</p>
<p>最后我在dev 的k8s环境中，给我的项目注册了一个gitlab-runner，我的开发环境已经存在gitlab-runner，如果你的不存在，就安装一下。<br>之后这样搞先打开setting—-&gt;cicd—-&gt;runners<br><img src="https://img-blog.csdnimg.cn/20210126204710663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后使用gitlab-runner register<br><img src="https://img-blog.csdnimg.cn/20210126204942387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入之前runner那张图的url<br>输入之前runner那张图的token<br>出入描述<br>输入tag，这个很重要，.gitlab-ci.yaml脚本通过tag关联runner<br>输入选择的执行方式，我选了shell</p>
<p>注册完之后会发现setting—-&gt;cicd—-&gt;runners多了一个runner<br><img src="https://img-blog.csdnimg.cn/20210126205400881.png" alt="在这里插入图片描述"><br>到这里还是不能用，就算在.gitlab-ci.yaml文件中关联了这个tag。这样关联，加上tags即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  image: dtzar/helm-kubectl:2.9.1</span><br><span class="line">  stage: deploy</span><br><span class="line">  tags:</span><br><span class="line">    - goRtm</span><br></pre></td></tr></table></figure>
<p>因为这个runner并不能跑起来，如果能够运行，则是前面是绿色的，tag改过了，和上图对应的不一样，说明一下。<br><img src="https://img-blog.csdnimg.cn/20210126205703316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还要调用gitlab-runner run，调用之后就变成绿色的就可以用了<br><img src="https://img-blog.csdnimg.cn/20210126205935238.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021012621003097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>做完这些，我就可以在提交代码后，自动部署到我想要的k8s中了。</p>
<p>因为文章涉及到公司项目，很多东西不能交代清楚。大概只能这样写了。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>gitlab ci/cd</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么在linux中安装golang, 不需要在windows下载好包</title>
    <url>/2021/01/21/%E6%80%8E%E4%B9%88%E5%9C%A8linux%E4%B8%AD%E5%AE%89%E8%A3%85golang,%20%E4%B8%8D%E9%9C%80%E8%A6%81%E5%9C%A8windows%E4%B8%8B%E8%BD%BD%E5%A5%BD%E5%8C%85/</url>
    <content><![CDATA[<span id="more"></span>
<p>      其实我已经安装了很久了, 久到我已经忘记怎么安装了, 今天在k8s中调试时, 要重新装golang, 上网查了一下, 发现太多文章都是不太方便的, 例如现在windows下载好包, 再考到linux下解压, 有这么麻烦么, 下面直接上流程</p>

<p> </p>

<h1>1.先下载golang的包</h1>

<p>这里网上好多文章都是在windows下搜索, 下载好拷贝过去, 其实不用这么干, 在linux中直接下载就好了</p>

<p>我是debian 64位的系统, 工作目录是/usr/local. 这样下</p>

<pre>
<code>// 如果你看到这篇文章,可能已经过了很久,go的版本自己看着修改
wget https://storage.googleapis.com/golang/go1.15.7.linux-amd64.tar.gz

// 如果没有wget, 先进行以下步骤, 然后再再下载golang
// apt-get update
// apt-get install wget
</code></pre>

<h1>2.解压golang</h1>

<pre>
<code>// 你下载再哪里就在哪里解压
tar -C /usr/local -xzf go1.15.7.linux-amd64.tar.gz</code></pre>

<h1>3.设置环境变量</h1>

<pre>
<code>export PATH=$PATH:/usr/local/go/bin

//这里写你自己的工作目录
export GOPATH=/usr/local/go_project

export GOROOT=/usr/local/go
</code></pre>

<p>最后用go version 查看是否安装成功</p>

<p><img alt height="76" src="https://img-blog.csdnimg.cn/20210121190942174.png" width="486"></p>

<p>打完收工.</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>搬迁</title>
    <url>/2022/05/04/%E6%90%AC%E8%BF%81/</url>
    <content><![CDATA[<h1 id="2022-5-4"><a href="#2022-5-4" class="headerlink" title="2022.5.4"></a>2022.5.4</h1><p>计划将csnd的博客全部搬到github</p>
<ul>
<li><a href="https://www.zhihu.com/question/23934523">搭建参考</a></li>
<li><a href="https://www.cnblogs.com/unirithe/p/15530636.html">无法显示图片解决</a>，放入图片后要进行<code>hexo clean, hexo g, hexo s</code>即可在本地启动中看到</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>最近碰到的一些服务器问题的总结</title>
    <url>/2020/09/23/%E6%9C%80%E8%BF%91%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>
<p>      随着业务的熟悉，也多出更多的时间在注意技术。碰到了一下问题，做一下记录。</p>

<p>1.怎么查看服务器当前的网络状态，怎么看socket是否断开，怎么查看各个端口的连接情况。</p>

<p>使用 <strong>ifconfig</strong> 用来显示所有网络接口的详细情况的，如：ip地址，子网掩码等。</p>

<p>使用 <strong>netstat -na </strong>显示当前网络各个端口连接信息，会显示各个连接的状态（a所有，n显示地址，可以加t指定tcp，l指定显示监听的套接字）。</p>

<p> </p>

<p>2.linux fd(文件描述符)复用时怎么确保不出错。</p>

<p> </p>

<p> </p>

<p>3.客户端怎么异步的去连接服务器。</p>

<p>使用多线程或者多进程去连接服务器（线程池）</p>

<p> </p>

<p>4.怎么查找一个目录和多个目录下含有指定输出的文件</p>

<p>使用 <strong>grep 'xxxx' [目录1] [目录2] -rn，</strong>查找目录1，目录2中出现 ‘xxxx’ 的文件，并显示出现在第几行。</p>

<p> </p>

<p>5.skynet 不小心再 for 循环中使用了 call，另一个服务没有处理，这种情况怎么解决。</p>

<p> </p>

<p>6.lua的table是怎么实现的。</p>

<p>这个我还没有看过，只知道 lua 的 table 是数组和hash一起实现的。有一个有意思的事情是，有一个 table ，table[1000] = 1，这种情况下是数组还是hash（虽然在我们看来是数组，但是实际上却是hash，简单的想，如果是数组也不实际，创建1000个地址，只存贮一个地址）。table 的 取长度，会查找一个整形的key，达成条件</p>

<p><ul><li>table[key] != <strong>nil</strong></li>
    <li>table[key+1] == <strong>nil</strong></li>
</ul></p><p>所以，如果中间含有nil的table，计算长度，会出错。</p><p></p>
<p> </p>

<p>7.怎么判断服务器是否发生死循环。</p>

<p><ol><li><strong>top</strong>：找出占用cpu过高的程序</li>
    <li><strong>top -H -p</strong>：记录下占用cpu的线程号</li>
    <li><strong>gdb attach &lt;进程号&gt;</strong>： 对占用cpu过高的程序进行gdb调试</li>
    <li><strong>info thread</strong> ： 列出线程状态</li>
    <li><strong>thread &lt;线程号&gt;</strong> ： 根据线程号切换到某个线程</li>
    <li><strong>bt</strong> ： 输出堆栈</li>
    <li><strong>l</strong> ： 查看当前代码</li>
    <li><strong>print &lt;变量名&gt;</strong> ：输出必要的变量内容</li>
    <li><strong>detach</strong>：分离线程</li>
    <li><strong>q 退出gdb调试</strong></li>
    <li><strong>处理死循环，重启进程/线程</strong>。</li>
</ol></p><p> </p><p></p>
<p>8.怎么查看自己的服务器到底能够承载多少人。</p>

<p>查看linux服务器的内存，查看一个玩家需要多少内存，进行计算。</p>

<p> </p>

<p>9.socket write的时候，对方如果关闭了，内核缓冲区又还没满，尝试继续写会怎样。</p>

<p>先写入缓冲区，再写得话会返回错误，触发信号。</p>

<p> </p>

<p>10.动态库静态库那个效率高。C++动态库为什么要声明 extern c。调用动态库的方法。</p>

<h3>静态库</h3>

<p>当程序与静态库连接时，库中目标文件所含的所有将被程序使用的函数的机器码被 copy 到最终的可执行文件中。这就会导致最终生成的可执行代码量相对变多，相当于编译器将代码补充完整了，<strong>优点</strong>，这样运行起来相对就快些。不过会有个<strong>缺点</strong>: 占用磁盘和内存空间. 静态库会被添加到和它连接的每个程序中, 而且这些程序运行时, 都会被加载到内存中. 无形中又多消耗了更多的内存空间。</p>

<h3>动态库</h3>

<p>与共享库连接的可执行文件只包含它需要的函数的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才被拷贝到内存中。<strong>优点</strong>，这样就使可执行文件比较小, 节省磁盘空间，更进一步，操作系统使用虚拟内存，使得一份共享库驻留在内存中被多个程序使用，也同时节约了内存。<strong>缺点</strong>，不过由于运行时要去链接库会花费一定的时间，执行速度相对会慢一些，总的来说静态库是牺牲了空间效率，换取了时间效率，共享库是牺牲了时间效率换取了空间效率，没有好与坏的区别，只看具体需要了。</p>

<p>另外，一个程序编好后，有时需要做一些修改和优化，如果我们要修改的刚好是库函数的话，在接口不变的前提下，使用共享库的程序只需要将共享库重新编译就可以了，而使用静态库的程序则需要将静态库重新编译好后，将程序再重新编译一便。这也是使用过程当中的差别，以现在的项目举例，在远程更新的时候，如果只是*.so动态库封装内容变化了，那么只需要更新*.so即可。</p>

<p><strong>被extern "C"修饰的变量和函数是按照C语言方式进行编译和链接的</strong></p>

<p> </p>

<p>11.skynet 使用的 epoll是什么模式，epoll 的水平触发和边缘触发有什么区别</p>

<p><strong>水平触发（Level_triggered</strong><strong>）</strong>，epoll默认是水平触发的，skynet没做修改。</p>

<p><strong>水平触发（Level_triggered</strong><strong>）</strong>：对于socket读来说，文件描述符关联的读内核缓冲区非空，有数据可以读取，就会触发读就绪，对于socket写来说，描述符关联的内核写缓冲区不满，就可以触发写就绪。</p>

<p><strong>边缘触发（Edge_triggered）</strong>：对于socket读来说，一旦有消息达到，触发一次读就绪，如果一次没有读完缓冲区，则剩余的消息将会留在缓冲区，不会触发读就绪。对于socket写来说，只触发一次写就绪，如果写满了缓冲区，当缓冲区发送完毕时，会再触发一次写就绪。如果未满，则也不会触发写就绪。</p>

<p> </p>

<p>12.C++虚函数怎么实现的。</p>

<p>带有虚函数的类，编译器会为其额外分配一个虚函数表，里面记录的使虚函数的地址，当此类被继承时，子类如果也写了虚函数就在子类的虚函数表中将父类的函数地址覆盖，否则继承父类的虚函数地址。</p>

<p>实例化之后，对象有一个虚函数指针，虚函数指针指向虚函数表，这样程序运行的时候，通过虚函数指针找到的虚函数表就是根据对象的类型来指向的了。</p>

<p><img alt height="272" src="https://img-blog.csdnimg.cn/20200923173733453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="802"></p>

<p> </p>

<p>13.skynet定时器是怎么实现的。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>本地复制文本无法在Ubuntu中粘贴问题</title>
    <url>/2020/02/10/%E6%9C%AC%E5%9C%B0%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%97%A0%E6%B3%95%E5%9C%A8Ubuntu%E4%B8%AD%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>        在家办公，安装开发环境后无法粘贴。查询并自己实践后，解决方法如下：</p>

<p><strong>        1. sudo apt-get autoremove open-vm-tools </strong></p>

<p><strong>        2. sudo apt-get install open-vm-tools-desktop </strong></p>

<p><strong>        3.重启虚拟机</strong></p>

<p><strong>        </strong>我通过以上方法即可解决，如果执行步骤1失败，可参考下查看我的另一篇博客 ，看看是否为相同的错误</p>

<p>        “<strong>ubuntu apt-get安装软件Unable to locate package...”</strong></p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏服务器是干什么的（大话、浅析）</title>
    <url>/2019/06/22/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%88%E5%A4%A7%E8%AF%9D%E3%80%81%E6%B5%85%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<p>       在做游戏服务器开发之前之前一直有疑问，服务器是干什么的？问了几位前辈，得到的答案大概都是：<strong>服务器就是一台电脑，你可以访问，然后做一些事情（我现在觉得这个答案是很精辟的）。</strong>这个答案对于之前的我来说，由于根本没接触过服务器，不能理解其中的含义。百度得到的答案也不是我想要的。</p>

<p>       现在做游戏服务器开发两个月了，分享一下自己对游戏服务器的理解，希望能以另外的角度给想做游戏服务器开发的新人一些不同理解方向。如果有什么说的不对的地方，请见谅。</p>

<p>       <strong>游戏服务器其实就是处理游戏逻辑的（这话说的，新手谁看的懂啊。 = =！）</strong></p>

<h3><strong>举个大话例子：餐厅</strong></h3>

<p><strong>      </strong>将一个餐厅点菜比喻成一个游戏，桌子上有菜单，菜单上有：鱼香肉丝，清蒸牛肉，有一位客人看了菜单之后点了一道菜（鱼香肉丝）后，服务员将这道菜名告诉了厨房，厨房做好菜后递给服务员，最后服务员给你端上来了。</p>

<p>     在这个游戏中，餐桌相当于游戏的客户端，厨房相当于游戏服务器，服务员相当于客户端与服务器的通信，客人相当于玩家<strong>。</strong></p>

<p>     <strong>客户端：</strong>桌子上的菜单和上的菜（鱼香肉丝），这些都是客户端给玩家显示的。</p>

<p>     <strong>服务器：</strong>当菜名到达了厨房之后的一系列操作都是服务器做的（厨房开始准备，切菜，炒菜，完成后，告诉服务员，让他把菜端出去）。</p>

<p>     做这个游戏的服务器开发，就相当于，增加餐厅能提供的菜。比如餐厅要求增加一道番茄炒蛋的菜，你就要教会厨房怎么弄番茄炒蛋，确保经过你的调教之后，厨房在收到这个菜名时一定能做出这道菜，或者做不出菜的时候会给客户端提示（卖完了之类的）游戏就能更新，客户端就会在菜单上新增加一道番茄炒蛋的菜，客人就能点这道菜。</p>

<p>     出现bug又是个什么情况呢？例如你在调教厨房做这道菜时，只教会了厨房做菜，没有做什么别的操作。当点了这道菜，然后番茄用完了，这时候厨房由于你只教厨房做菜，没告诉它出现这种情况怎么办，厨房就不知道怎么办（出现了bug），最后客人一直在等，最后却没有上这道菜。</p>

<p> </p>

<h3>举个实际游戏例子：简单描述斗地主的一个简单流程</h3>

<p>      当你（玩家2）的上家（玩家1）出了一个3，轮到你出牌，你手上有345JK。</p>

<p>      <strong>客户端：1.显示三位玩家的牌，你的上家和下家的牌都是背对着你的。</strong></p>

<p><strong>                     2.显示你的手牌，供你选择。</strong></p>

<p><strong>                     3.收到服务器发来的消息（玩家1出了3），显示给你看。</strong></p>

<p>      这时候你点了一个3，然后点击出牌。<strong>客户端-------&gt;服务器</strong>，玩家2出个3。</p>

<p>      <strong>服务器：1.收到客户端发来的消息（玩家2出3）。</strong></p>

<p><strong>                     2.判断你是否能出这张牌。</strong></p>

<p><strong>                     3.将判断结果（不符合出牌规则，不许出）返回给客户端。</strong></p>

<p>      这时候<strong>客户端收到消息</strong>。</p>

<p>      <strong>客户端：1.显示提示：你出的牌不服务规范。（这张牌一直出不去）</strong></p>

<p>      这时候你点了一个4，然后点击出牌。<strong>客户端-------&gt;服务器</strong>，玩家2出个4。</p>

<p>     <strong> 服务器：1.收到客户端发来的消息（玩家2出4）。</strong></p>

<p><strong>                     2.判断你是否能出这张牌。</strong></p>

<p><strong>                     3.将判断结果（可以出牌）返回给客户端。</strong></p>

<p>      这时候<strong>客户端收到消息</strong>。</p>

<p>      <strong>客户端：1.你的手牌少了一张4。</strong></p>

<p><strong>                     2.牌桌上多了一张4。</strong></p>

<p>      然后轮到下一家出牌。</p>

<p>     </p>

<p>       在这些例子中，服务器做的事情，都是需要游戏服务器开发人员通过代码来实现的。回到我几位前辈对我的回答：<strong>服务器就是一台电脑（电脑是硬件服务器，写的游戏服务器是软件，需要有硬件载体），你可以访问（客户端连接服务器），然后做一些事情（玩家出了一张3，请服务器告诉我，可不可以出）。</strong></p>

<p>       以上就是对游戏服务器的理解，希望能给你提供一个理解游戏服务器是干什么的思路。如果有什么说的不对的地方，请指出，我会尽快修改。</p>

<p> </p>

<p>         </p>

<p> </p>

<p>    </p>

<p>    </p>

<p>    </p>

<p> </p>

<p> </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游戏服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次服务器上限需要资源评估</title>
    <url>/2021/08/05/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%99%90%E9%9C%80%E8%A6%81%E8%B5%84%E6%BA%90%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<span id="more"></span>
<p>本是小辣鸡。以前也只是写业务代码，全靠领导给机会让我自己负责一个服务器的编写，部署，上线需要的资源评估。记录第一次做上线资源评估的过程。</p>
<p>项目背景是，搭在云服务商上的集群，集群管理是kubernetes。首次内测目标5000个用户。</p>
<h1 id="主要如下"><a href="#主要如下" class="headerlink" title="主要如下"></a>主要如下</h1><p>1.服务器需要多少内存<br>2.服务器需要多少cpu<br>3.了解购买的云服务参数<br>4.修改kubernetes部署文件</p>
<p>首先需要做压测，我写的服务器是用golang写的用于聊天服务器，所以在世界聊天的时候，压力就会非常大。压力也是要测试这里，看看需要消耗多少性能。</p>
<h1 id="服务器需要多少内存"><a href="#服务器需要多少内存" class="headerlink" title="服务器需要多少内存"></a>服务器需要多少内存</h1><p>我使用了golang的profile进行分析，登录了5000玩家后，在profile中，查看到内存情况总共消耗171000000字节左右。计算出一个玩家大约使用32KB的内存。服务器本身启动不占多少内存，最后评估需要256m的内存。</p>
<h1 id="服务器需要多少cpu"><a href="#服务器需要多少cpu" class="headerlink" title="服务器需要多少cpu"></a>服务器需要多少cpu</h1><p>在压测的时候，已经看了cpu的profile，看上去一切正常。剩下就是发消息。我启动服务器的机器是16核，2.2GHz的服务器。在每秒200人同时发消息到世界频道，5000人接收的情况下。使用top命令查看最高的时候，跑了586%的cpu，按6个计算，就是6*2200mhz = 13200mhz。也就是说在最极端的情况下，全部人都不玩游戏，只在大厅聊天，每秒200个人发，按照计算最多需要13200mhz的cpu。</p>
<h1 id="了解购买的云服务参数"><a href="#了解购买的云服务参数" class="headerlink" title="了解购买的云服务参数"></a>了解购买的云服务参数</h1><p>集群中总共有8台机器，每台8G内存，4个cpu，每个cpu是3.4Ghz约等于3400mhz，4个cpu大约13600mhz。</p>
<h1 id="修改kubernetes部署文件"><a href="#修改kubernetes部署文件" class="headerlink" title="修改kubernetes部署文件"></a>修改kubernetes部署文件</h1><p>因为要充分利用机器性能，所以不能够只部署一个pod，我的服务器之部署一个pod的话，会直接压干一台云服务器的cpu，导致这台云服务器只剩下400mhz的cpu，可能无法起别的pod，上面的内存也将被浪费掉。所以必须起多个pod。最终决定用以下配置，每个pod请求1000M内存，1整个核心的cpu，最大只给2000M内存和两个核心的cpu。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1000Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line"><span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">2000Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">2000m</span></span><br></pre></td></tr></table></figure><br>这样，一台云机器最少还有6G内存，和3个cpu可以分配给别的pod，不会造成资源浪费。另外，等到真正上线的时候，如果人太多了，资源不够用也是不怕的。kubernetes还有自动扩容。</p>
]]></content>
      <categories>
        <category>笔记 k8s</category>
      </categories>
      <tags>
        <tag>kubernetes 后端</tag>
      </tags>
  </entry>
  <entry>
    <title>VC++ 6.0开发OCX控件时遇到LIBCMT.lib(crt0.obj)：error：LNK2001 unresolved external symbol _main问题解决记录</title>
    <url>/2019/01/05/VC++%206.0%E5%BC%80%E5%8F%91OCX%E6%8E%A7%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0LIBCMT.lib(crt0.obj)%20!%20error%20LNK2001!%20unresolved%20external%20symbol%20_main%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<p>当你OCX控件的ReleaseMinDependency版时，你得到了下面这个链接错误：</p>

<p>   <strong>LIBCMT.LIB(crt0.obj) : error LNK2001: unresolved external symbol _main</strong></p>

<p>而Debug版本的编连却顺利通过。</p>

<p><br>
出错原因：<br>
如果你在工程中使用了CRT函数，而这些函数又需要CRT启动代码，就会出现这种链接错误。默认情况下，ReleaseMinDepende配置的Preprocessor definitions中定义了<span style="color:#f33b45;"><strong>_ATL_MIN_CRT</strong></span>，它将CRT启动代码从你的EXE或DLL剔出去了。</p>

<p> </p>

<p>背景知识：</p>

<p>ATL支持把一个服务器编连优化成最小尺寸或者依赖性最小。我们可以定义三个预处理器符号来影响服务器的优化。</p>

<p>_ATL_MIN_CRT             服务器不链接标准的C/C++运行库</p>

<p>_ATL_DLL                  服务器动态链接工具函数库atl.dll</p>

<p>_ATL_STATIC_REGISTRY    服务器静态链接对组件注册的支持</p>

<p>如果定义了预处理器符号_ATL_MIN_CRT，那么我们的服务器不链接C/C++运行库，并且ATL提供了函数malloc、realloc、new和delete的一个实现。当定义了这个符号时，我们不能调用任何其他的C/C++运行库的函数。否则，就会受到这样的待遇：</p>

<p>LIBCMT.LIB(crt0.obj) : error LNK2001: unresolved external symbol _main</p>

<p>ATL向导生成的ATL工程为所有的Release版本的编连定义了_ATL_MIN_CRT，但是没有为Debug版本定义这个符号。</p>

<p>Debug配置没有定义这三个符号中的任何一个。</p>

<p>RelMinSize配置定义了_ATL_MIN_CRT和_ATL_DLL。</p>

<p>RelMinDependency配置定义了_ATL_MIN_CRT和_ATL_STATIC_REGISTRY。</p>

<p> </p>

<p> </p>

<p>解决方法：</p>

<p>Project -----&gt; Settings-----&gt; C/C++</p>

<p>在Category中选择General ;</p>

<p>去除<span style="color:#f33b45;"><strong>_ATL_MIN_CRT</strong></span>这个预处理符号；</p>

<p> </p>

<p> </p>

<p>参考来自：<a href="https://blog.csdn.net/richie12/article/details/5799097">https://blog.csdn.net/richie12/article/details/5799097</a></p>]]></content>
      <tags>
        <tag>VC 6.0 OCX控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell连接虚拟机失败Could not connect to &#39;192.xxx.xx.xxx&#39; (port 22)：Connection failed.</title>
    <url>/2019/05/27/Xshell%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%B1%E8%B4%A5Could%20not%20connect%20to%20&#39;192.xxx.xx.xxx&#39;%20(port%2022)!%20Connection%20failed/</url>
    <content><![CDATA[<span id="more"></span>
<p>之后的工作会使用Xshell，今天搞一个下来连接自己的虚拟机，发现连接失败：</p>

<p><img alt class="has" height="106" src="https://img-blog.csdnimg.cn/20190527100348655.png" width="527"></p>

<p>猜想是可能是虚拟机或者Xshell部分没设置好</p>

<p>查询后通过以下方法解决，做此记录：</p>

<p>1.安装OpenSSH，执行<strong>sudo apt-get install openssh-server openssh-client</strong>命令。</p>

<p><img alt class="has" height="252" src="https://img-blog.csdnimg.cn/20190527100736178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="734"></p>

<p>2.执行<strong>netstat -tnl</strong>命令，查看22端口。</p>

<p><img alt class="has" height="199" src="https://img-blog.csdnimg.cn/20190527100842369.png" width="761"></p>

<p>博主通过以上方法已可以接连上。</p>

<p><img alt class="has" height="328" src="https://img-blog.csdnimg.cn/20190527101126749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="627"></p>

<p>参考地址：<a href="https://blog.csdn.net/s243471087/article/details/80208985">https://blog.csdn.net/s243471087/article/details/80208985</a></p>

<p> </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>golang net/http包在k8s使用中碰到http：superfluous response.WriteHeader call from xxx的问题</title>
    <url>/2021/01/21/golang%20net!http%E5%8C%85%E5%9C%A8k8s%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%A2%B0%E5%88%B0http!%20superfluous%20response.WriteHeader%20call%20from%20xxx%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>      在项目中，需要使用golang写http服务器并部署在k8s中，在server deployment.yaml中存在livenessProbe(存活探针)以及readinessProbe(就绪探针)，这两个我都是写了向服务器发送一个http请求，如果服务器收到并回复，则表示成功，但是在使用过程中，日志一直输出，这些会干扰日志的查看。</p>

<p><img alt height="346" src="https://img-blog.csdnimg.cn/20210121174550591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmZ1c2hlbjAwNw==,size_16,color_FFFFFF,t_70" width="688"></p>

<p>经过查询与测试，最后修复，做此纪录，代码如下。</p>

<pre>
<code class="language-Go">func healthcheck(w http.ResponseWriter, r *http.Request) &#123;
    //fmt.Fprintf(w, "i m live") 原来就是因为多了这行,然后一直输出,屏蔽了即可
    w.WriteHeader(200)
&#125;

func main() &#123;
    router := http.NewServeMux()
    router.HandleFunc("/healthcheck", healthcheck)
    port := fmt.Sprint(":", *config.Conf.HttpPort)
    srv := &amp;http.Server&#123;
        Addr:    port,
        Handler: router,
    &#125;

    logger.Info("[HTTP] http server listen", port)
    if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed &#123;
        logger.Error("[HTTP] server listen on", port, ", err:", err)
        os.Exit(1)
    &#125;
&#125;</code></pre>

<p> </p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
